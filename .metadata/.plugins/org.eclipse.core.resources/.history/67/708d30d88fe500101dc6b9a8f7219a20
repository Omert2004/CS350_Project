/*
 * BL_Functions.c
 *
 *  Created on: 30 Ara 2025
 *      Author: marda
 */

#include "BL_Functions.h"
#include "mem_layout.h"
#include "tiny_printf.h"
#include "stm32f4xx_hal.h"
#include "jump_to_app.h"

extern UART_HandleTypeDef huart1;
#define RX_CHUNK_BYTES   1024
#define RX_BUF_SIZE_WORDS   (RX_CHUNK_BYTES / 4)
extern uint32_t firmware_size;

uint8_t  rx_buf[RX_CHUNK_BYTES];
uint32_t buf_idx = 0;
uint8_t  byte;
uint32_t flash_addr = APP_ACTIVE_START_ADDR ;
uint8_t size_buf[4];
uint32_t firmware_size  = 0;


/**
 * @brief  Reads bootloader configuration from flash memory.
 *
 * This function loads the persistent boot configuration structure
 * from the dedicated configuration flash sector (Sector 2).
 * If the configuration is missing or invalid (magic number mismatch),
 * default values are initialized in RAM.
 *
 * @param[out] cfg  Pointer to BootConfig_t structure to be filled.
 *
 * @retval 1  Configuration was empty or invalid and defaults were applied.
 * @retval 0  Configuration was valid and read successfully.
 */
uint8_t BL_ReadConfig(BootConfig_t *cfg) {
	uint8_t config_was_empty = 0;
    // Direct memory read
    memcpy(cfg, (void *)CONFIG_SECTOR_ADDR, sizeof(BootConfig_t));

    // If config is empty (0xFFFFFFFF) or invalid, set defaults
    if (cfg->magic_number != 0xDEADBEEF) {
        cfg->magic_number = 0xDEADBEEF;
        cfg->system_status = STATE_NORMAL;
        cfg->boot_failure_count = 0;
        cfg->active_slot = 1;
        cfg->current_version = 0;

        config_was_empty = 1;
    }
    return config_was_empty;
}

/**
 * @brief  Writes bootloader configuration to flash memory.
 *
 * This function erases the dedicated configuration sector (Sector 2)
 * and programs the provided BootConfig_t structure into flash.
 * Flash programming is performed using 64-bit double-word writes.
 *
 * @warning This function performs a flash erase operation.
 *          It must NOT be interrupted or executed from flash
 *          regions being erased.
 *
 * @param[in] cfg  Pointer to the configuration structure to be written.
 *
 * @retval 1  Configuration written successfully.
 * @retval 0  Flash erase or programming failed.
 */
uint8_t BL_WriteFromPython(void) {
    // 1. SIZE OKUMA
    for (int i = 0; i < 4; i++) {
        HAL_UART_Receive(&huart1, &size_buf[i], 1, HAL_MAX_DELAY);
    }

    firmware_size =
          ((uint32_t)size_buf[0])
        | ((uint32_t)size_buf[1] << 8)
        | ((uint32_t)size_buf[2] << 16)
        | ((uint32_t)size_buf[3] << 24);

    tfp_printf("SIZE OK\r\n");

    // -- DEGISKENLER --
    uint32_t total_received = 0;  // DUZELTME 1: uint32_t yapildi
    uint32_t current_chunk_idx = 0;

    // Flash yazma icin pointer
    uint32_t *word_buf = (uint32_t*)rx_buf;

    // -- ANA DONGU --
    while (total_received < firmware_size - 1)
    {
        // 1. Python'dan veri iste
        tfp_printf("A\n");

        // 2. Veriyi al
        if (HAL_UART_Receive(&huart1, &rx_buf[current_chunk_idx], 1, 1000) == HAL_OK) // 1sn timeout
        {
            current_chunk_idx++;
            total_received++;
        }
        else
        {
            // Timeout hatasi - Donguden cikilabilir veya retry yapilabilir
            break;
        }

        // 3. Buffer Doldu mu VEYA Dosya Bitti mi?
        // DUZELTME 2: Sadece 1024 dolunca degil, dosya bitince de yazmali
        if (current_chunk_idx == RX_CHUNK_BYTES || total_received == firmware_size)
        {
            HAL_Delay(5); // Kisa bekleme
            tfp_printf("BUFFER_DOLU\n");

            // --- Flash Yazma ---
            HAL_FLASH_Unlock();

            // Kac kelime (word) yazilacak? (4'e bol, yukari yuvarla veya kalanlari padding yap)
            // Not: Dosya boyutu 4'un kati degilse son 1-3 byte flasha yazilmayabilir.
            // Python tarafinda padding yapmak en iyisidir.
            // Burada basitce 4'er 4'er yaziyoruz:
            uint32_t words_to_write = (current_chunk_idx + 3) / 4;

            for (uint32_t j = 0; j < words_to_write; j++)
            {
                HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, flash_addr, word_buf[j]);
                flash_addr += 4;
            }
            HAL_FLASH_Lock();

            // --- Reset ---
            current_chunk_idx = 0; // Buffer indexi basa sar

            // --- Devam Etme Kontrolu ---
            if (total_received < firmware_size)
            {
                // Daha veri varsa Python'a devam et diyoruz
                tfp_printf("DEVAM\n");
            }
        }
    }

    // Islem bitti
    tfp_printf("DONE\n"); // Opsiyonel: Python'a bittigini soyle
    return 1;
}

/*// --- Helper: Copy One Sector to Another (No RAM Buffer) ---
static uint8_t BL_Direct_Copy(uint32_t src_addr, uint32_t dest_addr) {

    // [SAFETY] Disable interrupts to prevent Vector Table fetches during Erase
    __disable_irq();

    // 1. We MUST erase the destination first.
    FLASH_EraseInitTypeDef erase;
    uint32_t error;

    if (dest_addr == APP_ACTIVE_START_ADDR) erase.Sector = FLASH_SECTOR_5;
    else if (dest_addr == APP_DOWNLOAD_START_ADDR) erase.Sector = FLASH_SECTOR_6;
    else erase.Sector = FLASH_SECTOR_7;

    erase.TypeErase = FLASH_TYPEERASE_SECTORS;
    erase.VoltageRange = FLASH_VOLTAGE_RANGE_3;
    erase.NbSectors = 1;

    // Erase
    if (HAL_FLASHEx_Erase(&erase, &error) != HAL_OK) {
        __enable_irq(); // [SAFETY] Re-enable on failure
        return 0; // Error
    }

    // 2. The Loop: Read -> Write directly (32-bit WORD)
    // CHANGE 1: Loop condition uses *4 instead of *8
    for (uint32_t i = 0; (i * 4) < SLOT_SIZE; i++) {

        // CHANGE 2: Read 32-bit word (uint32_t)
        // We cast the source address to a uint32_t pointer
    	uint32_t data = *(uint32_t*)(src_addr + (i * 4));

        // CHANGE 3: Write using FLASH_TYPEPROGRAM_WORD
        // Note: HAL_FLASH_Program takes 64-bit Data arg, but uses lower 32-bits for WORD type.
        if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, dest_addr + (i * 4), data) != HAL_OK) {
            __enable_irq(); // [SAFETY] Re-enable on failure
            return 0; // Error
        }
    }

    // [SAFETY] Re-enable interrupts after success
    __enable_irq();
    return 1; // Success
}
*/

// --- Main Swap Function ---
/*
void BL_Swap_NoBuffer(void) {
    HAL_FLASH_Unlock();
    printf("Starting Direct Swap (Zero-RAM Mode)...\r\n");

    // 1. Copy New App (S6) -> Scratchpad (S7)
    if (!BL_Direct_Copy(APP_DOWNLOAD_START_ADDR, SCRATCH_ADDR)) {
        printf("Fail: Copy S6->S7\r\n");
        HAL_FLASH_Lock(); return;
    }

    // 2. Copy Old App (S5) -> Backup (S6)
    if (!BL_Direct_Copy(APP_ACTIVE_START_ADDR, APP_DOWNLOAD_START_ADDR)) {
        printf("Fail: Copy S5->S6\r\n");
        HAL_FLASH_Lock(); return;
    }

    // 3. Copy New App (S7) -> Active (S5)
    if (!BL_Direct_Copy(SCRATCH_ADDR, APP_ACTIVE_START_ADDR)) {
        printf("Fail: Copy S7->S5\r\n");
        // CRITICAL: S5 is corrupted. Recovery needed on reboot.
        HAL_FLASH_Lock(); return;
    }

    HAL_FLASH_Lock();
    printf("Swap Complete.\r\n");
}
*/
