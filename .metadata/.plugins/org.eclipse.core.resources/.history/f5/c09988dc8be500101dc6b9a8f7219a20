/*
 * BL_Functions.c
 *
 *  Created on: 30 Ara 2025
 *      Author: marda
 */

#include "BL_Functions.h"
#include "mem_layout.h"
#include "tiny_printf.h"
#include "stm32f4xx_hal.h"
#include "jump_to_app.h"

extern UART_HandleTypeDef huart1;
#define RX_CHUNK_BYTES   1024
#define RX_BUF_SIZE_WORDS   (RX_CHUNK_BYTES / 4)
extern uint32_t firmware_size;

uint8_t  rx_buf[RX_CHUNK_BYTES];
uint32_t buf_idx = 0;
uint8_t  byte;
uint32_t flash_addr = APP_ACTIVE_START_ADDR ;


/**
 * @brief  Reads bootloader configuration from flash memory.
 *
 * This function loads the persistent boot configuration structure
 * from the dedicated configuration flash sector (Sector 2).
 * If the configuration is missing or invalid (magic number mismatch),
 * default values are initialized in RAM.
 *
 * @param[out] cfg  Pointer to BootConfig_t structure to be filled.
 *
 * @retval 1  Configuration was empty or invalid and defaults were applied.
 * @retval 0  Configuration was valid and read successfully.
 */
uint8_t BL_ReadConfig(BootConfig_t *cfg) {
	uint8_t config_was_empty = 0;
    // Direct memory read
    memcpy(cfg, (void *)CONFIG_SECTOR_ADDR, sizeof(BootConfig_t));

    // If config is empty (0xFFFFFFFF) or invalid, set defaults
    if (cfg->magic_number != 0xDEADBEEF) {
        cfg->magic_number = 0xDEADBEEF;
        cfg->system_status = STATE_NORMAL;
        cfg->boot_failure_count = 0;
        cfg->active_slot = 1;
        cfg->current_version = 0;

        config_was_empty = 1;
    }
    return config_was_empty;
}

/**
 * @brief  Writes bootloader configuration to flash memory.
 *
 * This function erases the dedicated configuration sector (Sector 2)
 * and programs the provided BootConfig_t structure into flash.
 * Flash programming is performed using 64-bit double-word writes.
 *
 * @warning This function performs a flash erase operation.
 *          It must NOT be interrupted or executed from flash
 *          regions being erased.
 *
 * @param[in] cfg  Pointer to the configuration structure to be written.
 *
 * @retval 1  Configuration written successfully.
 * @retval 0  Flash erase or programming failed.
 */
uint8_t BL_WriteFromPython(void) {
	//__enable_irq();
	//HAL_Init();


    for (int i = 0; i < 4; i++)
    {
        HAL_UART_Receive(&huart1, &size_buf[i], 1, HAL_MAX_DELAY);
    }


    firmware_size =
          ((uint32_t)size_buf[0])
        | ((uint32_t)size_buf[1] << 8)
        | ((uint32_t)size_buf[2] << 16)
        | ((uint32_t)size_buf[3] << 24);



    tfp_printf("SIZE OK\r\n");

    // -- (byte by byte) --
	uint8_t count = 0;
    while (count < firmware_size)
    {
    	/* ---- Receive exactly 1024 bytes ---- */

		for (uint32_t i = 0; i < RX_CHUNK_BYTES; i++)
		{
			tfp_printf("A\n");
			HAL_UART_Receive(&huart1, &rx_buf[i], 1, HAL_MAX_DELAY);
			count++;
		}
        /* Buffer FULL: 1024 bytes */
		/* Tell Python to STOP */
		HAL_Delay(10);
		tfp_printf("BUFFER_DOLU\n");

		/* Write to flash WORD by WORD */
		uint32_t *word_buf = (uint32_t*)rx_buf;  // burda word yapÄ±oz

		HAL_FLASH_Unlock();

		for (uint32_t j = 0; j < RX_BUF_SIZE_WORDS; j++)
		{
			HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
							  flash_addr,
							  word_buf[j]);
			flash_addr += 4;
		}

		HAL_FLASH_Lock();

		/* Reset buffer */
		buf_idx = 0;

		/* Tell Python to CONTINUE */
		HAL_UART_Transmit(&huart1,
						  (uint8_t*)"DEVAM\n",
						  6,
						  HAL_MAX_DELAY);
        }
    //__disable_irq();
    //HAL_DeInit();

}

/*// --- Helper: Copy One Sector to Another (No RAM Buffer) ---
static uint8_t BL_Direct_Copy(uint32_t src_addr, uint32_t dest_addr) {

    // [SAFETY] Disable interrupts to prevent Vector Table fetches during Erase
    __disable_irq();

    // 1. We MUST erase the destination first.
    FLASH_EraseInitTypeDef erase;
    uint32_t error;

    if (dest_addr == APP_ACTIVE_START_ADDR) erase.Sector = FLASH_SECTOR_5;
    else if (dest_addr == APP_DOWNLOAD_START_ADDR) erase.Sector = FLASH_SECTOR_6;
    else erase.Sector = FLASH_SECTOR_7;

    erase.TypeErase = FLASH_TYPEERASE_SECTORS;
    erase.VoltageRange = FLASH_VOLTAGE_RANGE_3;
    erase.NbSectors = 1;

    // Erase
    if (HAL_FLASHEx_Erase(&erase, &error) != HAL_OK) {
        __enable_irq(); // [SAFETY] Re-enable on failure
        return 0; // Error
    }

    // 2. The Loop: Read -> Write directly (32-bit WORD)
    // CHANGE 1: Loop condition uses *4 instead of *8
    for (uint32_t i = 0; (i * 4) < SLOT_SIZE; i++) {

        // CHANGE 2: Read 32-bit word (uint32_t)
        // We cast the source address to a uint32_t pointer
    	uint32_t data = *(uint32_t*)(src_addr + (i * 4));

        // CHANGE 3: Write using FLASH_TYPEPROGRAM_WORD
        // Note: HAL_FLASH_Program takes 64-bit Data arg, but uses lower 32-bits for WORD type.
        if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, dest_addr + (i * 4), data) != HAL_OK) {
            __enable_irq(); // [SAFETY] Re-enable on failure
            return 0; // Error
        }
    }

    // [SAFETY] Re-enable interrupts after success
    __enable_irq();
    return 1; // Success
}
*/

// --- Main Swap Function ---
/*
void BL_Swap_NoBuffer(void) {
    HAL_FLASH_Unlock();
    printf("Starting Direct Swap (Zero-RAM Mode)...\r\n");

    // 1. Copy New App (S6) -> Scratchpad (S7)
    if (!BL_Direct_Copy(APP_DOWNLOAD_START_ADDR, SCRATCH_ADDR)) {
        printf("Fail: Copy S6->S7\r\n");
        HAL_FLASH_Lock(); return;
    }

    // 2. Copy Old App (S5) -> Backup (S6)
    if (!BL_Direct_Copy(APP_ACTIVE_START_ADDR, APP_DOWNLOAD_START_ADDR)) {
        printf("Fail: Copy S5->S6\r\n");
        HAL_FLASH_Lock(); return;
    }

    // 3. Copy New App (S7) -> Active (S5)
    if (!BL_Direct_Copy(SCRATCH_ADDR, APP_ACTIVE_START_ADDR)) {
        printf("Fail: Copy S7->S5\r\n");
        // CRITICAL: S5 is corrupted. Recovery needed on reboot.
        HAL_FLASH_Lock(); return;
    }

    HAL_FLASH_Lock();
    printf("Swap Complete.\r\n");
}
*/
