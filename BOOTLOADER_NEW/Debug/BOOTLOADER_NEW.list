
BOOTLOADER_NEW.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .shared_api_section 00000014  08017000  08017000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00004f78  08017020  08017020  00002020  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000840  0801bf98  0801bf98  00006f98  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  0801c7d8  0801c7d8  00008068  2**0
                  CONTENTS, READONLY
  5 .ARM          00000008  0801c7d8  0801c7d8  000077d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  0801c7e0  0801c7e0  00008068  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  0801c7e0  0801c7e0  000077e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .fini_array   00000004  0801c7e4  0801c7e4  000077e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         00000068  20000000  0801c7e8  00008000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          00001a38  20000068  0801c850  00008068  2**2
                  ALLOC
 11 ._user_heap_stack 00000600  20001aa0  0801c850  00008aa0  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00008068  2**0
                  CONTENTS, READONLY
 13 .debug_info   000323cc  00000000  00000000  00008098  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00004ba0  00000000  00000000  0003a464  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loclists 0002a144  00000000  00000000  0003f004  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 000010b8  00000000  00000000  00069148  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00005782  00000000  00000000  0006a200  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  00028bf8  00000000  00000000  0006f982  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   000297f8  00000000  00000000  0009857a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000f2107  00000000  00000000  000c1d72  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .comment      00000045  00000000  00000000  001b3e79  2**0
                  CONTENTS, READONLY
 22 .debug_frame  00003694  00000000  00000000  001b3ec0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_line_str 00000232  00000000  00000000  001b7554  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08017020 <memchr>:
 8017020:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8017024:	2a10      	cmp	r2, #16
 8017026:	db2b      	blt.n	8017080 <memchr+0x60>
 8017028:	f010 0f07 	tst.w	r0, #7
 801702c:	d008      	beq.n	8017040 <memchr+0x20>
 801702e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8017032:	3a01      	subs	r2, #1
 8017034:	428b      	cmp	r3, r1
 8017036:	d02d      	beq.n	8017094 <memchr+0x74>
 8017038:	f010 0f07 	tst.w	r0, #7
 801703c:	b342      	cbz	r2, 8017090 <memchr+0x70>
 801703e:	d1f6      	bne.n	801702e <memchr+0xe>
 8017040:	b4f0      	push	{r4, r5, r6, r7}
 8017042:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8017046:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 801704a:	f022 0407 	bic.w	r4, r2, #7
 801704e:	f07f 0700 	mvns.w	r7, #0
 8017052:	2300      	movs	r3, #0
 8017054:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8017058:	3c08      	subs	r4, #8
 801705a:	ea85 0501 	eor.w	r5, r5, r1
 801705e:	ea86 0601 	eor.w	r6, r6, r1
 8017062:	fa85 f547 	uadd8	r5, r5, r7
 8017066:	faa3 f587 	sel	r5, r3, r7
 801706a:	fa86 f647 	uadd8	r6, r6, r7
 801706e:	faa5 f687 	sel	r6, r5, r7
 8017072:	b98e      	cbnz	r6, 8017098 <memchr+0x78>
 8017074:	d1ee      	bne.n	8017054 <memchr+0x34>
 8017076:	bcf0      	pop	{r4, r5, r6, r7}
 8017078:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 801707c:	f002 0207 	and.w	r2, r2, #7
 8017080:	b132      	cbz	r2, 8017090 <memchr+0x70>
 8017082:	f810 3b01 	ldrb.w	r3, [r0], #1
 8017086:	3a01      	subs	r2, #1
 8017088:	ea83 0301 	eor.w	r3, r3, r1
 801708c:	b113      	cbz	r3, 8017094 <memchr+0x74>
 801708e:	d1f8      	bne.n	8017082 <memchr+0x62>
 8017090:	2000      	movs	r0, #0
 8017092:	4770      	bx	lr
 8017094:	3801      	subs	r0, #1
 8017096:	4770      	bx	lr
 8017098:	2d00      	cmp	r5, #0
 801709a:	bf06      	itte	eq
 801709c:	4635      	moveq	r5, r6
 801709e:	3803      	subeq	r0, #3
 80170a0:	3807      	subne	r0, #7
 80170a2:	f015 0f01 	tst.w	r5, #1
 80170a6:	d107      	bne.n	80170b8 <memchr+0x98>
 80170a8:	3001      	adds	r0, #1
 80170aa:	f415 7f80 	tst.w	r5, #256	@ 0x100
 80170ae:	bf02      	ittt	eq
 80170b0:	3001      	addeq	r0, #1
 80170b2:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 80170b6:	3001      	addeq	r0, #1
 80170b8:	bcf0      	pop	{r4, r5, r6, r7}
 80170ba:	3801      	subs	r0, #1
 80170bc:	4770      	bx	lr
 80170be:	bf00      	nop

080170c0 <__aeabi_uldivmod>:
 80170c0:	b953      	cbnz	r3, 80170d8 <__aeabi_uldivmod+0x18>
 80170c2:	b94a      	cbnz	r2, 80170d8 <__aeabi_uldivmod+0x18>
 80170c4:	2900      	cmp	r1, #0
 80170c6:	bf08      	it	eq
 80170c8:	2800      	cmpeq	r0, #0
 80170ca:	bf1c      	itt	ne
 80170cc:	f04f 31ff 	movne.w	r1, #4294967295
 80170d0:	f04f 30ff 	movne.w	r0, #4294967295
 80170d4:	f000 b80c 	b.w	80170f0 <__aeabi_idiv0>
 80170d8:	f1ad 0c08 	sub.w	ip, sp, #8
 80170dc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80170e0:	f004 fdbe 	bl	801bc60 <__udivmoddi4>
 80170e4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80170e8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80170ec:	b004      	add	sp, #16
 80170ee:	4770      	bx	lr

080170f0 <__aeabi_idiv0>:
 80170f0:	4770      	bx	lr
 80170f2:	bf00      	nop

080170f4 <deregister_tm_clones>:
 80170f4:	4803      	ldr	r0, [pc, #12]	@ (8017104 <deregister_tm_clones+0x10>)
 80170f6:	4b04      	ldr	r3, [pc, #16]	@ (8017108 <deregister_tm_clones+0x14>)
 80170f8:	4283      	cmp	r3, r0
 80170fa:	d002      	beq.n	8017102 <deregister_tm_clones+0xe>
 80170fc:	4b03      	ldr	r3, [pc, #12]	@ (801710c <deregister_tm_clones+0x18>)
 80170fe:	b103      	cbz	r3, 8017102 <deregister_tm_clones+0xe>
 8017100:	4718      	bx	r3
 8017102:	4770      	bx	lr
 8017104:	20000068 	.word	0x20000068
 8017108:	20000068 	.word	0x20000068
 801710c:	00000000 	.word	0x00000000

08017110 <register_tm_clones>:
 8017110:	4805      	ldr	r0, [pc, #20]	@ (8017128 <register_tm_clones+0x18>)
 8017112:	4b06      	ldr	r3, [pc, #24]	@ (801712c <register_tm_clones+0x1c>)
 8017114:	1a1b      	subs	r3, r3, r0
 8017116:	0fd9      	lsrs	r1, r3, #31
 8017118:	eb01 01a3 	add.w	r1, r1, r3, asr #2
 801711c:	1049      	asrs	r1, r1, #1
 801711e:	d002      	beq.n	8017126 <register_tm_clones+0x16>
 8017120:	4b03      	ldr	r3, [pc, #12]	@ (8017130 <register_tm_clones+0x20>)
 8017122:	b103      	cbz	r3, 8017126 <register_tm_clones+0x16>
 8017124:	4718      	bx	r3
 8017126:	4770      	bx	lr
 8017128:	20000068 	.word	0x20000068
 801712c:	20000068 	.word	0x20000068
 8017130:	00000000 	.word	0x00000000

08017134 <__do_global_dtors_aux>:
 8017134:	b510      	push	{r4, lr}
 8017136:	4c06      	ldr	r4, [pc, #24]	@ (8017150 <__do_global_dtors_aux+0x1c>)
 8017138:	7823      	ldrb	r3, [r4, #0]
 801713a:	b943      	cbnz	r3, 801714e <__do_global_dtors_aux+0x1a>
 801713c:	f7ff ffda 	bl	80170f4 <deregister_tm_clones>
 8017140:	4b04      	ldr	r3, [pc, #16]	@ (8017154 <__do_global_dtors_aux+0x20>)
 8017142:	b113      	cbz	r3, 801714a <__do_global_dtors_aux+0x16>
 8017144:	4804      	ldr	r0, [pc, #16]	@ (8017158 <__do_global_dtors_aux+0x24>)
 8017146:	f3af 8000 	nop.w
 801714a:	2301      	movs	r3, #1
 801714c:	7023      	strb	r3, [r4, #0]
 801714e:	bd10      	pop	{r4, pc}
 8017150:	20000068 	.word	0x20000068
 8017154:	00000000 	.word	0x00000000
 8017158:	0801bf80 	.word	0x0801bf80

0801715c <frame_dummy>:
 801715c:	b508      	push	{r3, lr}
 801715e:	4b05      	ldr	r3, [pc, #20]	@ (8017174 <frame_dummy+0x18>)
 8017160:	b11b      	cbz	r3, 801716a <frame_dummy+0xe>
 8017162:	4905      	ldr	r1, [pc, #20]	@ (8017178 <frame_dummy+0x1c>)
 8017164:	4805      	ldr	r0, [pc, #20]	@ (801717c <frame_dummy+0x20>)
 8017166:	f3af 8000 	nop.w
 801716a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 801716e:	f7ff bfcf 	b.w	8017110 <register_tm_clones>
 8017172:	bf00      	nop
 8017174:	00000000 	.word	0x00000000
 8017178:	2000006c 	.word	0x2000006c
 801717c:	0801bf80 	.word	0x0801bf80

08017180 <Crypto_SHA256_Flash>:

/* * Calculates SHA-256 of the Flash Memory area
 * Returns 1 on Success, 0 on Failure
 */
int Crypto_SHA256_Flash(const uint8_t *addr, uint32_t size, uint8_t *digest)
{
 8017180:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017182:	b09d      	sub	sp, #116	@ 0x74
 8017184:	4605      	mov	r5, r0
 8017186:	460c      	mov	r4, r1
 8017188:	4617      	mov	r7, r2
    struct tc_sha256_state_struct s;
    (void)tc_sha256_init(&s);
 801718a:	4668      	mov	r0, sp
 801718c:	f003 fce8 	bl	801ab60 <tc_sha256_init>

    // Process in chunks to avoid blocking CPU for too long (optional but good practice)
    uint32_t remaining = size;
    const uint8_t *ptr = addr;

    while (remaining > 0) {
 8017190:	b934      	cbnz	r4, 80171a0 <Crypto_SHA256_Flash+0x20>
        (void)tc_sha256_update(&s, ptr, chunk);
        ptr += chunk;
        remaining -= chunk;
    }

    (void)tc_sha256_final(digest, &s);
 8017192:	4669      	mov	r1, sp
 8017194:	4638      	mov	r0, r7
 8017196:	f003 fd35 	bl	801ac04 <tc_sha256_final>
    return 1;
}
 801719a:	2001      	movs	r0, #1
 801719c:	b01d      	add	sp, #116	@ 0x74
 801719e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uint32_t chunk = (remaining > 4096) ? 4096 : remaining;
 80171a0:	f5b4 5f80 	cmp.w	r4, #4096	@ 0x1000
 80171a4:	4626      	mov	r6, r4
        (void)tc_sha256_update(&s, ptr, chunk);
 80171a6:	4629      	mov	r1, r5
 80171a8:	4668      	mov	r0, sp
        uint32_t chunk = (remaining > 4096) ? 4096 : remaining;
 80171aa:	bf28      	it	cs
 80171ac:	f44f 5680 	movcs.w	r6, #4096	@ 0x1000
        (void)tc_sha256_update(&s, ptr, chunk);
 80171b0:	4632      	mov	r2, r6
        ptr += chunk;
 80171b2:	4435      	add	r5, r6
        remaining -= chunk;
 80171b4:	1ba4      	subs	r4, r4, r6
        (void)tc_sha256_update(&s, ptr, chunk);
 80171b6:	f003 fcff 	bl	801abb8 <tc_sha256_update>
        remaining -= chunk;
 80171ba:	e7e9      	b.n	8017190 <Crypto_SHA256_Flash+0x10>

080171bc <Crypto_ECDSA_P256_VerifyHash>:

/* * Verifies the ECDSA P-256 Signature
 * Returns 1 if Valid, 0 if Invalid
 */
int Crypto_ECDSA_P256_VerifyHash(const uint8_t *pubkey, const uint8_t *hash, const uint8_t *sig)
{
 80171bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    // TinyCrypt expects the public key as 64 raw bytes (X + Y)
    // If your keys.c has them separate, we combine them here:
    uint8_t pub_key_combined[64];
    memcpy(pub_key_combined, public_key_x, 32);
 80171c0:	4c14      	ldr	r4, [pc, #80]	@ (8017214 <Crypto_ECDSA_P256_VerifyHash+0x58>)
{
 80171c2:	b092      	sub	sp, #72	@ 0x48
 80171c4:	460f      	mov	r7, r1
 80171c6:	4690      	mov	r8, r2
    memcpy(pub_key_combined, public_key_x, 32);
 80171c8:	ad02      	add	r5, sp, #8
 80171ca:	f104 0320 	add.w	r3, r4, #32
 80171ce:	6820      	ldr	r0, [r4, #0]
 80171d0:	3408      	adds	r4, #8
 80171d2:	f854 1c04 	ldr.w	r1, [r4, #-4]
 80171d6:	462e      	mov	r6, r5
 80171d8:	429c      	cmp	r4, r3
 80171da:	c603      	stmia	r6!, {r0, r1}
 80171dc:	4635      	mov	r5, r6
 80171de:	d1f6      	bne.n	80171ce <Crypto_ECDSA_P256_VerifyHash+0x12>
    memcpy(&pub_key_combined[32], public_key_y, 32);
 80171e0:	4c0d      	ldr	r4, [pc, #52]	@ (8017218 <Crypto_ECDSA_P256_VerifyHash+0x5c>)
 80171e2:	ae0a      	add	r6, sp, #40	@ 0x28
 80171e4:	f104 0320 	add.w	r3, r4, #32
 80171e8:	6820      	ldr	r0, [r4, #0]
 80171ea:	3408      	adds	r4, #8
 80171ec:	f854 1c04 	ldr.w	r1, [r4, #-4]
 80171f0:	4635      	mov	r5, r6
 80171f2:	429c      	cmp	r4, r3
 80171f4:	c503      	stmia	r5!, {r0, r1}
 80171f6:	462e      	mov	r6, r5
 80171f8:	d1f6      	bne.n	80171e8 <Crypto_ECDSA_P256_VerifyHash+0x2c>
    // The signature in the footer is 64 bytes (R + S)
    // TinyCrypt verify function:
    // int uECC_verify(const uint8_t *public_key, const uint8_t *message_hash,
    //                 unsigned hash_size, const uint8_t *signature, uECC_Curve curve);

    int result = uECC_verify(pub_key_combined,
 80171fa:	f003 f975 	bl	801a4e8 <uECC_secp256r1>
 80171fe:	4643      	mov	r3, r8
 8017200:	2220      	movs	r2, #32
 8017202:	4639      	mov	r1, r7
 8017204:	9000      	str	r0, [sp, #0]
 8017206:	a802      	add	r0, sp, #8
 8017208:	f003 fa5d 	bl	801a6c6 <uECC_verify>
                             32, // SHA256 Hash size
                             sig,
                             uECC_secp256r1());

    return result; // uECC returns 1 on success
}
 801720c:	b012      	add	sp, #72	@ 0x48
 801720e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8017212:	bf00      	nop
 8017214:	0801bfe4 	.word	0x0801bfe4
 8017218:	0801bfc4 	.word	0x0801bfc4

0801721c <Bootloader_InternalVerify>:
	if (slot_size < sizeof(fw_footer_t)) return 0;
 801721c:	294b      	cmp	r1, #75	@ 0x4b
{
 801721e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017220:	b089      	sub	sp, #36	@ 0x24
	if (slot_size < sizeof(fw_footer_t)) return 0;
 8017222:	d90a      	bls.n	801723a <Bootloader_InternalVerify+0x1e>
	uint32_t slot_end = slot_start + slot_size;
 8017224:	1846      	adds	r6, r0, r1
	for (uint32_t addr = slot_end - 4; addr >= slot_start + sizeof(fw_footer_t); addr -= 4)
 8017226:	f100 074c 	add.w	r7, r0, #76	@ 0x4c
		if (*(uint32_t*)addr == FOOTER_MAGIC)
 801722a:	f8df c06c 	ldr.w	ip, [pc, #108]	@ 8017298 <Bootloader_InternalVerify+0x7c>
 801722e:	bf2c      	ite	cs
 8017230:	2501      	movcs	r5, #1
 8017232:	2500      	movcc	r5, #0
	for (uint32_t addr = slot_end - 4; addr >= slot_start + sizeof(fw_footer_t); addr -= 4)
 8017234:	1f32      	subs	r2, r6, #4
 8017236:	42ba      	cmp	r2, r7
 8017238:	d201      	bcs.n	801723e <Bootloader_InternalVerify+0x22>
    if (footer_addr == 0) return BL_ERR_FOOTER_NOT_FOUND;
 801723a:	2001      	movs	r0, #1
 801723c:	e025      	b.n	801728a <Bootloader_InternalVerify+0x6e>
		if (*(uint32_t*)addr == FOOTER_MAGIC)
 801723e:	6813      	ldr	r3, [r2, #0]
 8017240:	4563      	cmp	r3, ip
 8017242:	d111      	bne.n	8017268 <Bootloader_InternalVerify+0x4c>
			if (f->version == 0 || f->version == 0xFFFFFFFF) continue;
 8017244:	f852 3c08 	ldr.w	r3, [r2, #-8]
 8017248:	f1a2 0448 	sub.w	r4, r2, #72	@ 0x48
 801724c:	3b01      	subs	r3, #1
 801724e:	3303      	adds	r3, #3
 8017250:	d80a      	bhi.n	8017268 <Bootloader_InternalVerify+0x4c>
			if ((f->image_size % 4) != 0) continue;
 8017252:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 8017254:	f013 0f03 	tst.w	r3, #3
 8017258:	d106      	bne.n	8017268 <Bootloader_InternalVerify+0x4c>
			if (f->image_size == 0 || f->image_size > slot_size) continue;
 801725a:	b12b      	cbz	r3, 8017268 <Bootloader_InternalVerify+0x4c>
 801725c:	4299      	cmp	r1, r3
 801725e:	d303      	bcc.n	8017268 <Bootloader_InternalVerify+0x4c>
			uint32_t expected_footer_addr = slot_start + f->image_size;
 8017260:	eb00 0e03 	add.w	lr, r0, r3
			if (expected_footer_addr == footer_start)
 8017264:	4574      	cmp	r4, lr
 8017266:	d012      	beq.n	801728e <Bootloader_InternalVerify+0x72>
	for (uint32_t addr = slot_end - 4; addr >= slot_start + sizeof(fw_footer_t); addr -= 4)
 8017268:	3a04      	subs	r2, #4
 801726a:	e7e4      	b.n	8017236 <Bootloader_InternalVerify+0x1a>
    if (image_end > slot_end) return BL_ERR_IMAGE_RANGE_BAD;
 801726c:	42b4      	cmp	r4, r6
 801726e:	d810      	bhi.n	8017292 <Bootloader_InternalVerify+0x76>
	if (!Crypto_SHA256_Flash((const uint8_t *)slot_start, f->image_size, hash)) {
 8017270:	4619      	mov	r1, r3
 8017272:	466a      	mov	r2, sp
 8017274:	f7ff ff84 	bl	8017180 <Crypto_SHA256_Flash>
	if (!Crypto_ECDSA_P256_VerifyHash(NULL, hash, f->signature)) {
 8017278:	4622      	mov	r2, r4
 801727a:	4669      	mov	r1, sp
 801727c:	4628      	mov	r0, r5
 801727e:	f7ff ff9d 	bl	80171bc <Crypto_ECDSA_P256_VerifyHash>
    return BL_OK;
 8017282:	42a8      	cmp	r0, r5
 8017284:	bf0c      	ite	eq
 8017286:	2007      	moveq	r0, #7
 8017288:	4628      	movne	r0, r5
}
 801728a:	b009      	add	sp, #36	@ 0x24
 801728c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (slot_end < slot_start) return BL_ERR_IMAGE_RANGE_BAD;    // overflow protection
 801728e:	2d00      	cmp	r5, #0
 8017290:	d0ec      	beq.n	801726c <Bootloader_InternalVerify+0x50>
 8017292:	2004      	movs	r0, #4
 8017294:	e7f9      	b.n	801728a <Bootloader_InternalVerify+0x6e>
 8017296:	bf00      	nop
 8017298:	454e4421 	.word	0x454e4421

0801729c <__NVIC_SystemReset>:
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 801729c:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80172a0:	4905      	ldr	r1, [pc, #20]	@ (80172b8 <__NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80172a2:	4b06      	ldr	r3, [pc, #24]	@ (80172bc <__NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 80172a4:	68ca      	ldr	r2, [r1, #12]
 80172a6:	f402 62e0 	and.w	r2, r2, #1792	@ 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 80172aa:	4313      	orrs	r3, r2
 80172ac:	60cb      	str	r3, [r1, #12]
 80172ae:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 80172b2:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 80172b4:	e7fd      	b.n	80172b2 <__NVIC_SystemReset+0x16>
 80172b6:	bf00      	nop
 80172b8:	e000ed00 	.word	0xe000ed00
 80172bc:	05fa0004 	.word	0x05fa0004

080172c0 <Bootloader_SetStatus>:
// --- EXTERNAL VARIABLES (Fixes 'undeclared' errors) ---
// These tell the compiler: "Trust me, these exist in main.c and keys.c"
extern RTC_HandleTypeDef hrtc;           // Defined in main.c
extern const uint8_t AES_SECRET_KEY[16]; // Defined in keys.c

void Bootloader_SetStatus(uint32_t status) {
 80172c0:	b510      	push	{r4, lr}
 80172c2:	4604      	mov	r4, r0
    HAL_PWR_EnableBkUpAccess();
 80172c4:	f001 f822 	bl	801830c <HAL_PWR_EnableBkUpAccess>
    HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR1, status);
 80172c8:	2101      	movs	r1, #1
 80172ca:	4804      	ldr	r0, [pc, #16]	@ (80172dc <Bootloader_SetStatus+0x1c>)
 80172cc:	4622      	mov	r2, r4
 80172ce:	f001 fe1a 	bl	8018f06 <HAL_RTCEx_BKUPWrite>
    HAL_PWREx_DisableBkUpReg();
}
 80172d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_PWREx_DisableBkUpReg();
 80172d6:	f001 b821 	b.w	801831c <HAL_PWREx_DisableBkUpReg>
 80172da:	bf00      	nop
 80172dc:	2000190c 	.word	0x2000190c

080172e0 <BL_RequestUpdate>:

void BL_RequestUpdate(void) {
 80172e0:	b508      	push	{r3, lr}
    HAL_PWR_EnableBkUpAccess();
 80172e2:	f001 f813 	bl	801830c <HAL_PWR_EnableBkUpAccess>
    HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR0, 0xCAFEBABE); // Magic Flag
 80172e6:	4a03      	ldr	r2, [pc, #12]	@ (80172f4 <BL_RequestUpdate+0x14>)
 80172e8:	2100      	movs	r1, #0
 80172ea:	4803      	ldr	r0, [pc, #12]	@ (80172f8 <BL_RequestUpdate+0x18>)
 80172ec:	f001 fe0b 	bl	8018f06 <HAL_RTCEx_BKUPWrite>
    NVIC_SystemReset();
 80172f0:	f7ff ffd4 	bl	801729c <__NVIC_SystemReset>
 80172f4:	cafebabe 	.word	0xcafebabe
 80172f8:	2000190c 	.word	0x2000190c

080172fc <BL_GetStatus>:
    HAL_PWREx_DisableBkUpReg();
}

uint32_t BL_GetStatus(void) {
    return HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR1);
 80172fc:	2101      	movs	r1, #1
 80172fe:	4801      	ldr	r0, [pc, #4]	@ (8017304 <BL_GetStatus+0x8>)
 8017300:	f001 be06 	b.w	8018f10 <HAL_RTCEx_BKUPRead>
 8017304:	2000190c 	.word	0x2000190c

08017308 <Install_Update_Stream>:
}

/* Returns 1 on Success, 0 on Failure */
int Install_Update_Stream(uint8_t is_dry_run) {
 8017308:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    struct tc_aes_key_sched_struct sched;
    uint8_t iv[16];
    uint8_t next_iv[16];

    /* Read Initial IV */
    memcpy(iv, (void*)read_addr, 16);
 801730c:	4b33      	ldr	r3, [pc, #204]	@ (80173dc <Install_Update_Stream+0xd4>)
int Install_Update_Stream(uint8_t is_dry_run) {
 801730e:	b0b7      	sub	sp, #220	@ 0xdc
 8017310:	4683      	mov	fp, r0
    uint32_t write_addr = APP_ACTIVE_START_ADDR;
 8017312:	f8df 80e4 	ldr.w	r8, [pc, #228]	@ 80173f8 <Install_Update_Stream+0xf0>
    memcpy(iv, (void*)read_addr, 16);
 8017316:	ac02      	add	r4, sp, #8
    read_addr += 16;
 8017318:	4f31      	ldr	r7, [pc, #196]	@ (80173e0 <Install_Update_Stream+0xd8>)
    uint32_t end_addr = APP_DOWNLOAD_START_ADDR + APP_DOWNLOAD_SIZE;

    while (read_addr < end_addr) {

        // A. Read Encrypted Chunk
        memcpy(enc_buffer, (void*)read_addr, ENC_CHUNK_SIZE);
 801731a:	f8df 90cc 	ldr.w	r9, [pc, #204]	@ 80173e8 <Install_Update_Stream+0xe0>
		}

		// D. Decompress (LZ4)
		// Note: Input is &dec_buffer[2] (skipping the size header)
		//       Input Size is compressed_len (exact size)
		int bytes_out = LZ4_decompress_safe((const char*)&dec_buffer[2],
 801731e:	f8df a0dc 	ldr.w	sl, [pc, #220]	@ 80173fc <Install_Update_Stream+0xf4>
    memcpy(iv, (void*)read_addr, 16);
 8017322:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8017324:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    tc_aes128_set_decrypt_key(&sched, AES_SECRET_KEY);
 8017328:	492e      	ldr	r1, [pc, #184]	@ (80173e4 <Install_Update_Stream+0xdc>)
 801732a:	a80a      	add	r0, sp, #40	@ 0x28
 801732c:	f002 fb36 	bl	801999c <tc_aes128_set_decrypt_key>
        memcpy(enc_buffer, (void*)read_addr, ENC_CHUNK_SIZE);
 8017330:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8017334:	4639      	mov	r1, r7
 8017336:	482c      	ldr	r0, [pc, #176]	@ (80173e8 <Install_Update_Stream+0xe0>)
 8017338:	f003 ff57 	bl	801b1ea <memcpy>
        if (*(uint32_t*)enc_buffer == 0xFFFFFFFF) break;
 801733c:	f8d9 3000 	ldr.w	r3, [r9]
 8017340:	3301      	adds	r3, #1
 8017342:	d039      	beq.n	80173b8 <Install_Update_Stream+0xb0>
        memcpy(next_iv, &enc_buffer[ENC_CHUNK_SIZE - 16], 16);
 8017344:	4b29      	ldr	r3, [pc, #164]	@ (80173ec <Install_Update_Stream+0xe4>)
 8017346:	aa06      	add	r2, sp, #24
 8017348:	f103 0c10 	add.w	ip, r3, #16
 801734c:	4615      	mov	r5, r2
 801734e:	6818      	ldr	r0, [r3, #0]
 8017350:	3308      	adds	r3, #8
 8017352:	f853 1c04 	ldr.w	r1, [r3, #-4]
 8017356:	4616      	mov	r6, r2
 8017358:	4563      	cmp	r3, ip
 801735a:	c603      	stmia	r6!, {r0, r1}
 801735c:	4632      	mov	r2, r6
 801735e:	d1f6      	bne.n	801734e <Install_Update_Stream+0x46>
		if (tc_cbc_mode_decrypt(dec_buffer, ENC_CHUNK_SIZE, enc_buffer, ENC_CHUNK_SIZE, iv, &sched) == 0) {
 8017360:	ab0a      	add	r3, sp, #40	@ 0x28
 8017362:	4e23      	ldr	r6, [pc, #140]	@ (80173f0 <Install_Update_Stream+0xe8>)
 8017364:	464a      	mov	r2, r9
 8017366:	4630      	mov	r0, r6
 8017368:	e9cd 4300 	strd	r4, r3, [sp]
 801736c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8017370:	4619      	mov	r1, r3
 8017372:	f002 fc4d 	bl	8019c10 <tc_cbc_mode_decrypt>
 8017376:	b918      	cbnz	r0, 8017380 <Install_Update_Stream+0x78>
			 return 0; // Decrypt Error
 8017378:	2000      	movs	r0, #0
        read_addr += ENC_CHUNK_SIZE;
        write_addr += bytes_out;
    }

    return 1; // Stream is valid
}
 801737a:	b037      	add	sp, #220	@ 0xdc
 801737c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memcpy(iv, next_iv, 16); // Update IV
 8017380:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8017384:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		uint16_t compressed_len = *(uint16_t*)dec_buffer;
 8017388:	8832      	ldrh	r2, [r6, #0]
		if (compressed_len > (ENC_CHUNK_SIZE - 2) || compressed_len == 0) {
 801738a:	f240 31fd 	movw	r1, #1021	@ 0x3fd
 801738e:	1e53      	subs	r3, r2, #1
 8017390:	b29b      	uxth	r3, r3
 8017392:	428b      	cmp	r3, r1
 8017394:	d8f0      	bhi.n	8017378 <Install_Update_Stream+0x70>
		int bytes_out = LZ4_decompress_safe((const char*)&dec_buffer[2],
 8017396:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 801739a:	4651      	mov	r1, sl
 801739c:	1cb0      	adds	r0, r6, #2
 801739e:	f002 f829 	bl	80193f4 <LZ4_decompress_safe>
		if (bytes_out < 0) return 0; // CORRUPTION DETECTED!
 80173a2:	1e05      	subs	r5, r0, #0
 80173a4:	dbe8      	blt.n	8017378 <Install_Update_Stream+0x70>
        if (!is_dry_run) {
 80173a6:	f1bb 0f00 	cmp.w	fp, #0
 80173aa:	d015      	beq.n	80173d8 <Install_Update_Stream+0xd0>
        read_addr += ENC_CHUNK_SIZE;
 80173ac:	f507 6780 	add.w	r7, r7, #1024	@ 0x400
    while (read_addr < end_addr) {
 80173b0:	4b10      	ldr	r3, [pc, #64]	@ (80173f4 <Install_Update_Stream+0xec>)
        write_addr += bytes_out;
 80173b2:	44a8      	add	r8, r5
    while (read_addr < end_addr) {
 80173b4:	429f      	cmp	r7, r3
 80173b6:	d1bb      	bne.n	8017330 <Install_Update_Stream+0x28>
    return 1; // Stream is valid
 80173b8:	2001      	movs	r0, #1
 80173ba:	e7de      	b.n	801737a <Install_Update_Stream+0x72>
                if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, write_addr + i, *(uint32_t*)(raw_buffer + i)) != HAL_OK) {
 80173bc:	f85a 2006 	ldr.w	r2, [sl, r6]
 80173c0:	2300      	movs	r3, #0
 80173c2:	eb08 0106 	add.w	r1, r8, r6
 80173c6:	2002      	movs	r0, #2
 80173c8:	f000 fdf4 	bl	8017fb4 <HAL_FLASH_Program>
 80173cc:	2800      	cmp	r0, #0
 80173ce:	d1d3      	bne.n	8017378 <Install_Update_Stream+0x70>
            for (int i = 0; i < bytes_out; i += 4) {
 80173d0:	3604      	adds	r6, #4
 80173d2:	42ae      	cmp	r6, r5
 80173d4:	dbf2      	blt.n	80173bc <Install_Update_Stream+0xb4>
 80173d6:	e7e9      	b.n	80173ac <Install_Update_Stream+0xa4>
 80173d8:	465e      	mov	r6, fp
 80173da:	e7fa      	b.n	80173d2 <Install_Update_Stream+0xca>
 80173dc:	08080000 	.word	0x08080000
 80173e0:	08080010 	.word	0x08080010
 80173e4:	0801c004 	.word	0x0801c004
 80173e8:	20001484 	.word	0x20001484
 80173ec:	20001874 	.word	0x20001874
 80173f0:	20001084 	.word	0x20001084
 80173f4:	08100010 	.word	0x08100010
 80173f8:	08018000 	.word	0x08018000
 80173fc:	20000084 	.word	0x20000084

08017400 <Bootloader_HandleUpdate>:

void Bootloader_HandleUpdate(void) {
 8017400:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

    // --- STEP 1: SAFETY CHECK (DRY RUN) ---
    // We process the whole file but DO NOT erase or write anything.
    // This checks if the file is corrupt, truncated, or has the wrong key.

    if (Install_Update_Stream(1) == 0) {
 8017402:	2001      	movs	r0, #1
 8017404:	f7ff ff80 	bl	8017308 <Install_Update_Stream>
 8017408:	b920      	cbnz	r0, 8017414 <Bootloader_HandleUpdate+0x14>
        // DRY RUN FAILED!
        // The download slot contains garbage.
        // We abort immediately. The Active Slot is still perfectly valid.
        Bootloader_SetStatus(BL_STATUS_ERROR);
 801740a:	4817      	ldr	r0, [pc, #92]	@ (8017468 <Bootloader_HandleUpdate+0x68>)

        // --- STEP 4: FINAL SIGNATURE VERIFY ---
        // We verified the stream structure (LZ4), but now we verify
        // the cryptographic signature of the code we just wrote.
        if (Bootloader_InternalVerify(APP_ACTIVE_START_ADDR, APP_ACTIVE_SIZE) == 1) {
            Bootloader_SetStatus(BL_STATUS_UPDATED);
 801740c:	f7ff ff58 	bl	80172c0 <Bootloader_SetStatus>
            NVIC_SystemReset();
 8017410:	f7ff ff44 	bl	801729c <__NVIC_SystemReset>
    HAL_FLASH_Unlock();
 8017414:	f000 fd86 	bl	8017f24 <HAL_FLASH_Unlock>
    EraseInit.Sector = FLASH_SECTOR_2;
 8017418:	2200      	movs	r2, #0
 801741a:	2302      	movs	r3, #2
    if (HAL_FLASHEx_Erase(&EraseInit, &SectorError) != HAL_OK) {
 801741c:	a802      	add	r0, sp, #8
    EraseInit.Sector = FLASH_SECTOR_2;
 801741e:	e9cd 2302 	strd	r2, r3, [sp, #8]
    EraseInit.NbSectors = 4; // Sectors 2,3,4,5
 8017422:	2204      	movs	r2, #4
    if (HAL_FLASHEx_Erase(&EraseInit, &SectorError) != HAL_OK) {
 8017424:	eb0d 0102 	add.w	r1, sp, r2
    EraseInit.VoltageRange = FLASH_VOLTAGE_RANGE_3;
 8017428:	e9cd 2304 	strd	r2, r3, [sp, #16]
    if (HAL_FLASHEx_Erase(&EraseInit, &SectorError) != HAL_OK) {
 801742c:	f000 fe34 	bl	8018098 <HAL_FLASHEx_Erase>
 8017430:	b118      	cbz	r0, 801743a <Bootloader_HandleUpdate+0x3a>
        HAL_FLASH_Lock();
 8017432:	f000 fd89 	bl	8017f48 <HAL_FLASH_Lock>
        Error_Handler(); // Hardware failure
 8017436:	f000 f9ff 	bl	8017838 <Error_Handler>
    if (Install_Update_Stream(0) == 1) {
 801743a:	2000      	movs	r0, #0
 801743c:	f7ff ff64 	bl	8017308 <Install_Update_Stream>
 8017440:	2801      	cmp	r0, #1
 8017442:	d10b      	bne.n	801745c <Bootloader_HandleUpdate+0x5c>
        HAL_FLASH_Lock();
 8017444:	f000 fd80 	bl	8017f48 <HAL_FLASH_Lock>
        if (Bootloader_InternalVerify(APP_ACTIVE_START_ADDR, APP_ACTIVE_SIZE) == 1) {
 8017448:	f44f 21d0 	mov.w	r1, #425984	@ 0x68000
 801744c:	4807      	ldr	r0, [pc, #28]	@ (801746c <Bootloader_HandleUpdate+0x6c>)
 801744e:	f7ff fee5 	bl	801721c <Bootloader_InternalVerify>
 8017452:	2801      	cmp	r0, #1
 8017454:	d104      	bne.n	8017460 <Bootloader_HandleUpdate+0x60>
            Bootloader_SetStatus(BL_STATUS_UPDATED);
 8017456:	f04f 30aa 	mov.w	r0, #2863311530	@ 0xaaaaaaaa
 801745a:	e7d7      	b.n	801740c <Bootloader_HandleUpdate+0xc>
            // We are now bricked (Active Slot is erased/written but invalid).
            Error_Handler();
        }
    } else {
        // Write failed halfway?
        HAL_FLASH_Lock();
 801745c:	f000 fd74 	bl	8017f48 <HAL_FLASH_Lock>
        Error_Handler();
 8017460:	f000 f9ea 	bl	8017838 <Error_Handler>
    }
}
 8017464:	b007      	add	sp, #28
 8017466:	bd00      	pop	{pc}
 8017468:	deaddead 	.word	0xdeaddead
 801746c:	08018000 	.word	0x08018000

08017470 <Bootloader_JumpToApp>:
#include "jump_to_app.h"
#include "mem_layout.h"

void Bootloader_JumpToApp(void) {
    uint32_t app_addr = APP_ACTIVE_START_ADDR;
    uint32_t app_stack_addr = *(volatile uint32_t*)app_addr;
 8017470:	4b14      	ldr	r3, [pc, #80]	@ (80174c4 <Bootloader_JumpToApp+0x54>)
void Bootloader_JumpToApp(void) {
 8017472:	b570      	push	{r4, r5, r6, lr}
    uint32_t app_stack_addr = *(volatile uint32_t*)app_addr;
 8017474:	681d      	ldr	r5, [r3, #0]
    uint32_t app_reset_handler = *(volatile uint32_t*)(app_addr + 4);
 8017476:	685e      	ldr	r6, [r3, #4]

    if ((app_stack_addr & 0x20000000) != 0x20000000) {
 8017478:	00ab      	lsls	r3, r5, #2
 801747a:	d521      	bpl.n	80174c0 <Bootloader_JumpToApp+0x50>
        return;
    }

    // 2. DISABLE MPU & CACHE
    HAL_MPU_Disable();
 801747c:	f000 fc84 	bl	8017d88 <HAL_MPU_Disable>


    // 3. DISABLE SYSTICK (Crucial!)
    SysTick->CTRL = 0;
 8017480:	2400      	movs	r4, #0
 8017482:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8017486:	611c      	str	r4, [r3, #16]
    SysTick->LOAD = 0;
 8017488:	615c      	str	r4, [r3, #20]
    SysTick->VAL  = 0;
 801748a:	619c      	str	r4, [r3, #24]
    // 5. DE-INIT
    HAL_DeInit();
 801748c:	f000 fbbe 	bl	8017c0c <HAL_DeInit>
  __ASM volatile ("cpsid i" : : : "memory");
 8017490:	b672      	cpsid	i
    // 6. DISABLE INTERRUPTS
    __disable_irq();

    // 7. CLEAR PENDING INTERRUPTS
    for (int i = 0; i < 8; i++) {
        NVIC->ICER[i] = 0xFFFFFFFF;
 8017492:	f04f 32ff 	mov.w	r2, #4294967295
 8017496:	00a3      	lsls	r3, r4, #2
    for (int i = 0; i < 8; i++) {
 8017498:	3401      	adds	r4, #1
 801749a:	f103 4360 	add.w	r3, r3, #3758096384	@ 0xe0000000
 801749e:	2c08      	cmp	r4, #8
 80174a0:	f503 4361 	add.w	r3, r3, #57600	@ 0xe100
        NVIC->ICER[i] = 0xFFFFFFFF;
 80174a4:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
        NVIC->ICPR[i] = 0xFFFFFFFF;
 80174a8:	f8c3 2180 	str.w	r2, [r3, #384]	@ 0x180
    for (int i = 0; i < 8; i++) {
 80174ac:	d1f3      	bne.n	8017496 <Bootloader_JumpToApp+0x26>
    }

    // 8. RELOCATE VECTOR TABLE
    SCB->VTOR = app_addr;
 80174ae:	4b06      	ldr	r3, [pc, #24]	@ (80174c8 <Bootloader_JumpToApp+0x58>)
 80174b0:	4a04      	ldr	r2, [pc, #16]	@ (80174c4 <Bootloader_JumpToApp+0x54>)
 80174b2:	609a      	str	r2, [r3, #8]
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 80174b4:	f385 8808 	msr	MSP, r5

    // 9. JUMP
    __set_MSP(app_stack_addr);
    void (*pJump)(void) = (void (*)(void))app_reset_handler;
    pJump();
 80174b8:	4633      	mov	r3, r6
}
 80174ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pJump();
 80174be:	4718      	bx	r3
}
 80174c0:	bd70      	pop	{r4, r5, r6, pc}
 80174c2:	bf00      	nop
 80174c4:	08018000 	.word	0x08018000
 80174c8:	e000ed00 	.word	0xe000ed00

080174cc <BL_VerifySlot_Wrapper>:
// But our internal function is: BL_Status_t Bootloader_InternalVerify(uint32_t slot_start, uint32_t slot_size)
// So we need this wrapper to bridge them.
int BL_VerifySlot_Wrapper(uint32_t slot_id) {
    // Note: We ignore slot_id for now and verify the active slot constants.
    // In a multi-slot system, you would switch address based on slot_id.
    if (Bootloader_InternalVerify(APP_ACTIVE_START_ADDR, APP_ACTIVE_SIZE) == BL_OK) {
 80174cc:	f44f 21d0 	mov.w	r1, #425984	@ 0x68000
 80174d0:	4803      	ldr	r0, [pc, #12]	@ (80174e0 <BL_VerifySlot_Wrapper+0x14>)
int BL_VerifySlot_Wrapper(uint32_t slot_id) {
 80174d2:	b508      	push	{r3, lr}
    if (Bootloader_InternalVerify(APP_ACTIVE_START_ADDR, APP_ACTIVE_SIZE) == BL_OK) {
 80174d4:	f7ff fea2 	bl	801721c <Bootloader_InternalVerify>
        return 1; // Valid
    }
    return 0; // Invalid
}
 80174d8:	fab0 f080 	clz	r0, r0
 80174dc:	0940      	lsrs	r0, r0, #5
 80174de:	bd08      	pop	{r3, pc}
 80174e0:	08018000 	.word	0x08018000

080174e4 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80174e4:	b500      	push	{lr}
 80174e6:	b095      	sub	sp, #84	@ 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80174e8:	222c      	movs	r2, #44	@ 0x2c
 80174ea:	2100      	movs	r1, #0
 80174ec:	a809      	add	r0, sp, #36	@ 0x24
 80174ee:	f003 fdf1 	bl	801b0d4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80174f2:	2100      	movs	r1, #0
 80174f4:	2214      	movs	r2, #20
 80174f6:	a803      	add	r0, sp, #12
 80174f8:	f003 fdec 	bl	801b0d4 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 80174fc:	4b19      	ldr	r3, [pc, #100]	@ (8017564 <SystemClock_Config+0x80>)
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80174fe:	a808      	add	r0, sp, #32
  __HAL_RCC_PWR_CLK_ENABLE();
 8017500:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8017502:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8017506:	641a      	str	r2, [r3, #64]	@ 0x40
 8017508:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
 801750a:	4a17      	ldr	r2, [pc, #92]	@ (8017568 <SystemClock_Config+0x84>)
  __HAL_RCC_PWR_CLK_ENABLE();
 801750c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8017510:	9301      	str	r3, [sp, #4]
 8017512:	9b01      	ldr	r3, [sp, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
 8017514:	6813      	ldr	r3, [r2, #0]
 8017516:	f423 4340 	bic.w	r3, r3, #49152	@ 0xc000
 801751a:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 801751e:	6013      	str	r3, [r2, #0]
 8017520:	6813      	ldr	r3, [r2, #0]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8017522:	2210      	movs	r2, #16
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
 8017524:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 8017528:	9302      	str	r3, [sp, #8]
 801752a:	9b02      	ldr	r3, [sp, #8]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
 801752c:	230a      	movs	r3, #10
 801752e:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8017530:	2301      	movs	r3, #1
 8017532:	e9cd 320b 	strd	r3, r2, [sp, #44]	@ 0x2c
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8017536:	930d      	str	r3, [sp, #52]	@ 0x34
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8017538:	2300      	movs	r3, #0
 801753a:	930e      	str	r3, [sp, #56]	@ 0x38
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 801753c:	f000 ff0a 	bl	8018354 <HAL_RCC_OscConfig>
 8017540:	4601      	mov	r1, r0
 8017542:	b108      	cbz	r0, 8017548 <SystemClock_Config+0x64>
  __ASM volatile ("cpsid i" : : : "memory");
 8017544:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8017546:	e7fe      	b.n	8017546 <SystemClock_Config+0x62>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8017548:	230f      	movs	r3, #15
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 801754a:	9007      	str	r0, [sp, #28]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 801754c:	e9cd 3003 	strd	r3, r0, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8017550:	e9cd 0005 	strd	r0, r0, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8017554:	a803      	add	r0, sp, #12
 8017556:	f001 f8e9 	bl	801872c <HAL_RCC_ClockConfig>
 801755a:	b108      	cbz	r0, 8017560 <SystemClock_Config+0x7c>
 801755c:	b672      	cpsid	i
  while (1)
 801755e:	e7fe      	b.n	801755e <SystemClock_Config+0x7a>
}
 8017560:	b015      	add	sp, #84	@ 0x54
 8017562:	bd00      	pop	{pc}
 8017564:	40023800 	.word	0x40023800
 8017568:	40007000 	.word	0x40007000

0801756c <main>:
{
 801756c:	b580      	push	{r7, lr}
 801756e:	b088      	sub	sp, #32
  MPU_Region_InitTypeDef MPU_InitStruct = {0};
 8017570:	2210      	movs	r2, #16
 8017572:	2100      	movs	r1, #0
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
 8017574:	2400      	movs	r4, #0
  MPU_Region_InitTypeDef MPU_InitStruct = {0};
 8017576:	a803      	add	r0, sp, #12
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8017578:	2601      	movs	r6, #1
  MPU_Region_InitTypeDef MPU_InitStruct = {0};
 801757a:	f003 fdab 	bl	801b0d4 <memset>
  GPIO_InitStruct.Pin = USER_LED_Pin;
 801757e:	2702      	movs	r7, #2
  HAL_MPU_Disable();
 8017580:	f000 fc02 	bl	8017d88 <HAL_MPU_Disable>
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
 8017584:	f248 731f 	movw	r3, #34591	@ 0x871f
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8017588:	a803      	add	r0, sp, #12
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801758a:	f8ad 600c 	strh.w	r6, [sp, #12]
  MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
 801758e:	e9cd 4304 	strd	r4, r3, [sp, #16]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 8017592:	f240 1301 	movw	r3, #257	@ 0x101
 8017596:	9306      	str	r3, [sp, #24]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8017598:	f000 fc14 	bl	8017dc4 <HAL_MPU_ConfigRegion>
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 801759c:	2004      	movs	r0, #4
 801759e:	f000 fc01 	bl	8017da4 <HAL_MPU_Enable>
  HAL_Init();
 80175a2:	f000 fb6d 	bl	8017c80 <HAL_Init>
  SystemClock_Config();
 80175a6:	f7ff ff9d 	bl	80174e4 <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80175aa:	2214      	movs	r2, #20
 80175ac:	4621      	mov	r1, r4
 80175ae:	a803      	add	r0, sp, #12
 80175b0:	f003 fd90 	bl	801b0d4 <memset>
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80175b4:	4b4e      	ldr	r3, [pc, #312]	@ (80176f0 <main+0x184>)
  HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_RESET);
 80175b6:	2102      	movs	r1, #2
 80175b8:	484e      	ldr	r0, [pc, #312]	@ (80176f4 <main+0x188>)
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80175ba:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80175bc:	4332      	orrs	r2, r6
 80175be:	631a      	str	r2, [r3, #48]	@ 0x30
 80175c0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80175c2:	4032      	ands	r2, r6
 80175c4:	9200      	str	r2, [sp, #0]
 80175c6:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80175c8:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80175ca:	f042 0202 	orr.w	r2, r2, #2
 80175ce:	631a      	str	r2, [r3, #48]	@ 0x30
 80175d0:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80175d2:	f002 0202 	and.w	r2, r2, #2
 80175d6:	9201      	str	r2, [sp, #4]
 80175d8:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOI_CLK_ENABLE();
 80175da:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80175dc:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80175e0:	631a      	str	r2, [r3, #48]	@ 0x30
  HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_RESET);
 80175e2:	4622      	mov	r2, r4
  __HAL_RCC_GPIOI_CLK_ENABLE();
 80175e4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80175e6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80175ea:	9302      	str	r3, [sp, #8]
 80175ec:	9b02      	ldr	r3, [sp, #8]
  HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_RESET);
 80175ee:	f000 fe7f 	bl	80182f0 <HAL_GPIO_WritePin>
  HAL_GPIO_Init(USER_LED_GPIO_Port, &GPIO_InitStruct);
 80175f2:	4840      	ldr	r0, [pc, #256]	@ (80176f4 <main+0x188>)
 80175f4:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80175f6:	e9cd 7603 	strd	r7, r6, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80175fa:	e9cd 4405 	strd	r4, r4, [sp, #20]
  HAL_GPIO_Init(USER_LED_GPIO_Port, &GPIO_InitStruct);
 80175fe:	f000 fd97 	bl	8018130 <HAL_GPIO_Init>
  huart1.Instance = USART1;
 8017602:	4a3d      	ldr	r2, [pc, #244]	@ (80176f8 <main+0x18c>)
 8017604:	4b3d      	ldr	r3, [pc, #244]	@ (80176fc <main+0x190>)
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8017606:	4610      	mov	r0, r2
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8017608:	6254      	str	r4, [r2, #36]	@ 0x24
  huart1.Instance = USART1;
 801760a:	6013      	str	r3, [r2, #0]
  huart1.Init.BaudRate = 115200;
 801760c:	f44f 33e1 	mov.w	r3, #115200	@ 0x1c200
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8017610:	e9c2 3401 	strd	r3, r4, [r2, #4]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8017614:	230c      	movs	r3, #12
  huart1.Init.Parity = UART_PARITY_NONE;
 8017616:	e9c2 4403 	strd	r4, r4, [r2, #12]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 801761a:	e9c2 3405 	strd	r3, r4, [r2, #20]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 801761e:	e9c2 4407 	strd	r4, r4, [r2, #28]
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8017622:	f001 feb9 	bl	8019398 <HAL_UART_Init>
 8017626:	b108      	cbz	r0, 801762c <main+0xc0>
 8017628:	b672      	cpsid	i
  while (1)
 801762a:	e7fe      	b.n	801762a <main+0xbe>
  hrtc.Instance = RTC;
 801762c:	4c34      	ldr	r4, [pc, #208]	@ (8017700 <main+0x194>)
  hrtc.Init.SynchPrediv = 255;
 801762e:	227f      	movs	r2, #127	@ 0x7f
  hrtc.Instance = RTC;
 8017630:	4b34      	ldr	r3, [pc, #208]	@ (8017704 <main+0x198>)
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 8017632:	61a0      	str	r0, [r4, #24]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 8017634:	e9c4 3000 	strd	r3, r0, [r4]
  hrtc.Init.SynchPrediv = 255;
 8017638:	23ff      	movs	r3, #255	@ 0xff
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 801763a:	e9c4 0004 	strd	r0, r0, [r4, #16]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 801763e:	4620      	mov	r0, r4
  hrtc.Init.SynchPrediv = 255;
 8017640:	e9c4 2302 	strd	r2, r3, [r4, #8]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 8017644:	f001 fc15 	bl	8018e72 <HAL_RTC_Init>
 8017648:	4605      	mov	r5, r0
 801764a:	b108      	cbz	r0, 8017650 <main+0xe4>
 801764c:	b672      	cpsid	i
  while (1)
 801764e:	e7fe      	b.n	801764e <main+0xe2>
  tfp_init(&huart1);
 8017650:	4829      	ldr	r0, [pc, #164]	@ (80176f8 <main+0x18c>)
 8017652:	f000 fa3b 	bl	8017acc <tfp_init>
  printf("\r\n========================================\r\n");
 8017656:	482c      	ldr	r0, [pc, #176]	@ (8017708 <main+0x19c>)
 8017658:	f000 fa3e 	bl	8017ad8 <tfp_printf>
	printf("Starting Bootloader Version-(%d,%d)\r\n", MAJOR, MINOR);
 801765c:	463a      	mov	r2, r7
 801765e:	4631      	mov	r1, r6
 8017660:	482a      	ldr	r0, [pc, #168]	@ (801770c <main+0x1a0>)
 8017662:	f000 fa39 	bl	8017ad8 <tfp_printf>
	printf("API Table Location: %p\r\n", &API_Table); // Debug print
 8017666:	492a      	ldr	r1, [pc, #168]	@ (8017710 <main+0x1a4>)
 8017668:	482a      	ldr	r0, [pc, #168]	@ (8017714 <main+0x1a8>)
 801766a:	f000 fa35 	bl	8017ad8 <tfp_printf>
	printf("========================================\r\n");
 801766e:	482a      	ldr	r0, [pc, #168]	@ (8017718 <main+0x1ac>)
 8017670:	f000 fa32 	bl	8017ad8 <tfp_printf>
	HAL_PWR_EnableBkUpAccess();
 8017674:	f000 fe4a 	bl	801830c <HAL_PWR_EnableBkUpAccess>
	if (HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR0) == BKP_FLAG_UPDATE_REQ) {
 8017678:	4629      	mov	r1, r5
 801767a:	4620      	mov	r0, r4
 801767c:	f001 fc48 	bl	8018f10 <HAL_RTCEx_BKUPRead>
 8017680:	4b26      	ldr	r3, [pc, #152]	@ (801771c <main+0x1b0>)
 8017682:	4298      	cmp	r0, r3
 8017684:	d10b      	bne.n	801769e <main+0x132>
		printf("[BL] Update Request Detected. Clearing Flag...\r\n");
 8017686:	4826      	ldr	r0, [pc, #152]	@ (8017720 <main+0x1b4>)
 8017688:	f000 fa26 	bl	8017ad8 <tfp_printf>
		HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR0, 0x00000000);
 801768c:	462a      	mov	r2, r5
 801768e:	4629      	mov	r1, r5
 8017690:	4620      	mov	r0, r4
 8017692:	f001 fc38 	bl	8018f06 <HAL_RTCEx_BKUPWrite>
		HAL_PWREx_DisableBkUpReg();
 8017696:	f000 fe41 	bl	801831c <HAL_PWREx_DisableBkUpReg>
		Bootloader_HandleUpdate();
 801769a:	f7ff feb1 	bl	8017400 <Bootloader_HandleUpdate>
	HAL_PWREx_DisableBkUpReg();
 801769e:	f000 fe3d 	bl	801831c <HAL_PWREx_DisableBkUpReg>
	printf("[BL] Verifying Application integrity...\r\n");
 80176a2:	4820      	ldr	r0, [pc, #128]	@ (8017724 <main+0x1b8>)
 80176a4:	f000 fa18 	bl	8017ad8 <tfp_printf>
	if (Bootloader_InternalVerify(APP_ACTIVE_START_ADDR, APP_ACTIVE_SIZE) == BL_OK) {
 80176a8:	f44f 21d0 	mov.w	r1, #425984	@ 0x68000
 80176ac:	481e      	ldr	r0, [pc, #120]	@ (8017728 <main+0x1bc>)
 80176ae:	f7ff fdb5 	bl	801721c <Bootloader_InternalVerify>
 80176b2:	b978      	cbnz	r0, 80176d4 <main+0x168>
		printf("[BL] Verification Success! Jumping to App.\r\n");
 80176b4:	481d      	ldr	r0, [pc, #116]	@ (801772c <main+0x1c0>)
 80176b6:	f000 fa0f 	bl	8017ad8 <tfp_printf>
		HAL_MPU_Disable();
 80176ba:	f000 fb65 	bl	8017d88 <HAL_MPU_Disable>
		Bootloader_JumpToApp();
 80176be:	f7ff fed7 	bl	8017470 <Bootloader_JumpToApp>
	  HAL_GPIO_TogglePin(GPIOI, USER_LED_Pin);
 80176c2:	2102      	movs	r1, #2
 80176c4:	480b      	ldr	r0, [pc, #44]	@ (80176f4 <main+0x188>)
 80176c6:	f000 fe18 	bl	80182fa <HAL_GPIO_TogglePin>
	  HAL_Delay(500);
 80176ca:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 80176ce:	f000 faf5 	bl	8017cbc <HAL_Delay>
  while (1)
 80176d2:	e7f6      	b.n	80176c2 <main+0x156>
		printf("[BL] CRITICAL: No valid application found or Verification Failed!\r\n");
 80176d4:	4816      	ldr	r0, [pc, #88]	@ (8017730 <main+0x1c4>)
 80176d6:	f000 f9ff 	bl	8017ad8 <tfp_printf>
		printf("[BL] Halting system.\r\n");
 80176da:	4816      	ldr	r0, [pc, #88]	@ (8017734 <main+0x1c8>)
 80176dc:	f000 f9fc 	bl	8017ad8 <tfp_printf>
			HAL_GPIO_TogglePin(GPIOI, USER_LED_Pin);
 80176e0:	2102      	movs	r1, #2
 80176e2:	4804      	ldr	r0, [pc, #16]	@ (80176f4 <main+0x188>)
 80176e4:	f000 fe09 	bl	80182fa <HAL_GPIO_TogglePin>
			HAL_Delay(200); // Fast blink for error
 80176e8:	20c8      	movs	r0, #200	@ 0xc8
 80176ea:	f000 fae7 	bl	8017cbc <HAL_Delay>
		while (1)
 80176ee:	e7f7      	b.n	80176e0 <main+0x174>
 80176f0:	40023800 	.word	0x40023800
 80176f4:	40022000 	.word	0x40022000
 80176f8:	20001884 	.word	0x20001884
 80176fc:	40011000 	.word	0x40011000
 8017700:	2000190c 	.word	0x2000190c
 8017704:	40002800 	.word	0x40002800
 8017708:	0801c014 	.word	0x0801c014
 801770c:	0801c041 	.word	0x0801c041
 8017710:	08017000 	.word	0x08017000
 8017714:	0801c067 	.word	0x0801c067
 8017718:	0801c016 	.word	0x0801c016
 801771c:	cafebabe 	.word	0xcafebabe
 8017720:	0801c080 	.word	0x0801c080
 8017724:	0801c0b1 	.word	0x0801c0b1
 8017728:	08018000 	.word	0x08018000
 801772c:	0801c0db 	.word	0x0801c0db
 8017730:	0801c108 	.word	0x0801c108
 8017734:	0801c14c 	.word	0x0801c14c

08017738 <print_hardfault_reason>:
void print_hardfault_reason(void) {
 8017738:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    volatile uint32_t cfsr  = SCB->CFSR;
 801773a:	4b2f      	ldr	r3, [pc, #188]	@ (80177f8 <print_hardfault_reason+0xc0>)
    printf("\r\n--- Hard Fault Detected ---\r\n");
 801773c:	482f      	ldr	r0, [pc, #188]	@ (80177fc <print_hardfault_reason+0xc4>)
    volatile uint32_t cfsr  = SCB->CFSR;
 801773e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8017740:	9200      	str	r2, [sp, #0]
    volatile uint32_t hfsr  = SCB->HFSR;
 8017742:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8017744:	9201      	str	r2, [sp, #4]
    volatile uint32_t mmfar = SCB->MMFAR;
 8017746:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8017748:	9202      	str	r2, [sp, #8]
    volatile uint32_t bfar  = SCB->BFAR;
 801774a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801774c:	9303      	str	r3, [sp, #12]
    printf("\r\n--- Hard Fault Detected ---\r\n");
 801774e:	f000 f9c3 	bl	8017ad8 <tfp_printf>
    printf("CFSR:  0x%08lX\r\n", cfsr);
 8017752:	9900      	ldr	r1, [sp, #0]
 8017754:	482a      	ldr	r0, [pc, #168]	@ (8017800 <print_hardfault_reason+0xc8>)
 8017756:	f000 f9bf 	bl	8017ad8 <tfp_printf>
    printf("HFSR:  0x%08lX\r\n", hfsr);
 801775a:	9901      	ldr	r1, [sp, #4]
 801775c:	4829      	ldr	r0, [pc, #164]	@ (8017804 <print_hardfault_reason+0xcc>)
 801775e:	f000 f9bb 	bl	8017ad8 <tfp_printf>
    printf("MMFAR: 0x%08lX\r\n", mmfar);
 8017762:	9902      	ldr	r1, [sp, #8]
 8017764:	4828      	ldr	r0, [pc, #160]	@ (8017808 <print_hardfault_reason+0xd0>)
 8017766:	f000 f9b7 	bl	8017ad8 <tfp_printf>
    printf("BFAR:  0x%08lX\r\n", bfar);
 801776a:	9903      	ldr	r1, [sp, #12]
 801776c:	4827      	ldr	r0, [pc, #156]	@ (801780c <print_hardfault_reason+0xd4>)
 801776e:	f000 f9b3 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 24)) printf(" -> Unaligned Access UsageFault\r\n");
 8017772:	9b00      	ldr	r3, [sp, #0]
 8017774:	01da      	lsls	r2, r3, #7
 8017776:	d502      	bpl.n	801777e <print_hardfault_reason+0x46>
 8017778:	4825      	ldr	r0, [pc, #148]	@ (8017810 <print_hardfault_reason+0xd8>)
 801777a:	f000 f9ad 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 25)) printf(" -> Divide by Zero UsageFault\r\n");
 801777e:	9b00      	ldr	r3, [sp, #0]
 8017780:	019b      	lsls	r3, r3, #6
 8017782:	d502      	bpl.n	801778a <print_hardfault_reason+0x52>
 8017784:	4823      	ldr	r0, [pc, #140]	@ (8017814 <print_hardfault_reason+0xdc>)
 8017786:	f000 f9a7 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 18)) printf(" -> Integrity Check Error\r\n");
 801778a:	9b00      	ldr	r3, [sp, #0]
 801778c:	0358      	lsls	r0, r3, #13
 801778e:	d502      	bpl.n	8017796 <print_hardfault_reason+0x5e>
 8017790:	4821      	ldr	r0, [pc, #132]	@ (8017818 <print_hardfault_reason+0xe0>)
 8017792:	f000 f9a1 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 17)) printf(" -> Invalid PC Load\r\n");
 8017796:	9b00      	ldr	r3, [sp, #0]
 8017798:	0399      	lsls	r1, r3, #14
 801779a:	d502      	bpl.n	80177a2 <print_hardfault_reason+0x6a>
 801779c:	481f      	ldr	r0, [pc, #124]	@ (801781c <print_hardfault_reason+0xe4>)
 801779e:	f000 f99b 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 16)) printf(" -> Invalid State\r\n");
 80177a2:	9b00      	ldr	r3, [sp, #0]
 80177a4:	03da      	lsls	r2, r3, #15
 80177a6:	d502      	bpl.n	80177ae <print_hardfault_reason+0x76>
 80177a8:	481d      	ldr	r0, [pc, #116]	@ (8017820 <print_hardfault_reason+0xe8>)
 80177aa:	f000 f995 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 0))  printf(" -> Instruction Access Violation (MPU)\r\n");
 80177ae:	9b00      	ldr	r3, [sp, #0]
 80177b0:	07db      	lsls	r3, r3, #31
 80177b2:	d502      	bpl.n	80177ba <print_hardfault_reason+0x82>
 80177b4:	481b      	ldr	r0, [pc, #108]	@ (8017824 <print_hardfault_reason+0xec>)
 80177b6:	f000 f98f 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 1))  printf(" -> Data Access Violation (MPU)\r\n");
 80177ba:	9b00      	ldr	r3, [sp, #0]
 80177bc:	0798      	lsls	r0, r3, #30
 80177be:	d502      	bpl.n	80177c6 <print_hardfault_reason+0x8e>
 80177c0:	4819      	ldr	r0, [pc, #100]	@ (8017828 <print_hardfault_reason+0xf0>)
 80177c2:	f000 f989 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 8))  printf(" -> Instruction Bus Error\r\n");
 80177c6:	9b00      	ldr	r3, [sp, #0]
 80177c8:	05d9      	lsls	r1, r3, #23
 80177ca:	d502      	bpl.n	80177d2 <print_hardfault_reason+0x9a>
 80177cc:	4817      	ldr	r0, [pc, #92]	@ (801782c <print_hardfault_reason+0xf4>)
 80177ce:	f000 f983 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 9))  printf(" -> Precise Data Bus Error\r\n");
 80177d2:	9b00      	ldr	r3, [sp, #0]
 80177d4:	059a      	lsls	r2, r3, #22
 80177d6:	d502      	bpl.n	80177de <print_hardfault_reason+0xa6>
 80177d8:	4815      	ldr	r0, [pc, #84]	@ (8017830 <print_hardfault_reason+0xf8>)
 80177da:	f000 f97d 	bl	8017ad8 <tfp_printf>
    if (cfsr & (1 << 15)) printf(" -> BFAR Address Valid: 0x%08lX\r\n", bfar);
 80177de:	9b00      	ldr	r3, [sp, #0]
 80177e0:	041b      	lsls	r3, r3, #16
 80177e2:	d506      	bpl.n	80177f2 <print_hardfault_reason+0xba>
 80177e4:	9903      	ldr	r1, [sp, #12]
 80177e6:	4813      	ldr	r0, [pc, #76]	@ (8017834 <print_hardfault_reason+0xfc>)
}
 80177e8:	b005      	add	sp, #20
 80177ea:	f85d eb04 	ldr.w	lr, [sp], #4
    if (cfsr & (1 << 15)) printf(" -> BFAR Address Valid: 0x%08lX\r\n", bfar);
 80177ee:	f000 b973 	b.w	8017ad8 <tfp_printf>
}
 80177f2:	b005      	add	sp, #20
 80177f4:	bd00      	pop	{pc}
 80177f6:	bf00      	nop
 80177f8:	e000ed00 	.word	0xe000ed00
 80177fc:	0801c163 	.word	0x0801c163
 8017800:	0801c183 	.word	0x0801c183
 8017804:	0801c194 	.word	0x0801c194
 8017808:	0801c1a5 	.word	0x0801c1a5
 801780c:	0801c1b6 	.word	0x0801c1b6
 8017810:	0801c1c7 	.word	0x0801c1c7
 8017814:	0801c1e9 	.word	0x0801c1e9
 8017818:	0801c209 	.word	0x0801c209
 801781c:	0801c225 	.word	0x0801c225
 8017820:	0801c23b 	.word	0x0801c23b
 8017824:	0801c24f 	.word	0x0801c24f
 8017828:	0801c278 	.word	0x0801c278
 801782c:	0801c29a 	.word	0x0801c29a
 8017830:	0801c2b6 	.word	0x0801c2b6
 8017834:	0801c2d3 	.word	0x0801c2d3

08017838 <Error_Handler>:
 8017838:	b672      	cpsid	i
  while (1)
 801783a:	e7fe      	b.n	801783a <Error_Handler+0x2>

0801783c <HAL_MspInit>:

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 801783c:	4b0a      	ldr	r3, [pc, #40]	@ (8017868 <HAL_MspInit+0x2c>)
{
 801783e:	b082      	sub	sp, #8
  __HAL_RCC_PWR_CLK_ENABLE();
 8017840:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8017842:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8017846:	641a      	str	r2, [r3, #64]	@ 0x40
 8017848:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801784a:	f002 5280 	and.w	r2, r2, #268435456	@ 0x10000000
 801784e:	9200      	str	r2, [sp, #0]
 8017850:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8017852:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8017854:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8017858:	645a      	str	r2, [r3, #68]	@ 0x44
 801785a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801785c:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8017860:	9301      	str	r3, [sp, #4]
 8017862:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8017864:	b002      	add	sp, #8
 8017866:	4770      	bx	lr
 8017868:	40023800 	.word	0x40023800

0801786c <HAL_RTC_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hrtc: RTC handle pointer
  * @retval None
  */
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 801786c:	b510      	push	{r4, lr}
 801786e:	b0a2      	sub	sp, #136	@ 0x88
 8017870:	4604      	mov	r4, r0
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8017872:	2284      	movs	r2, #132	@ 0x84
 8017874:	2100      	movs	r1, #0
 8017876:	a801      	add	r0, sp, #4
 8017878:	f003 fc2c 	bl	801b0d4 <memset>
  if(hrtc->Instance==RTC)
 801787c:	6822      	ldr	r2, [r4, #0]
 801787e:	4b0a      	ldr	r3, [pc, #40]	@ (80178a8 <HAL_RTC_MspInit+0x3c>)
 8017880:	429a      	cmp	r2, r3
 8017882:	d10f      	bne.n	80178a4 <HAL_RTC_MspInit+0x38>

    /* USER CODE END RTC_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8017884:	2320      	movs	r3, #32
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8017886:	a801      	add	r0, sp, #4
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8017888:	9301      	str	r3, [sp, #4]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 801788a:	f44f 7300 	mov.w	r3, #512	@ 0x200
 801788e:	930d      	str	r3, [sp, #52]	@ 0x34
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8017890:	f001 f80a 	bl	80188a8 <HAL_RCCEx_PeriphCLKConfig>
 8017894:	b108      	cbz	r0, 801789a <HAL_RTC_MspInit+0x2e>
    {
      Error_Handler();
 8017896:	f7ff ffcf 	bl	8017838 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 801789a:	4a04      	ldr	r2, [pc, #16]	@ (80178ac <HAL_RTC_MspInit+0x40>)
 801789c:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 801789e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80178a2:	6713      	str	r3, [r2, #112]	@ 0x70

    /* USER CODE END RTC_MspInit 1 */

  }

}
 80178a4:	b022      	add	sp, #136	@ 0x88
 80178a6:	bd10      	pop	{r4, pc}
 80178a8:	40002800 	.word	0x40002800
 80178ac:	40023800 	.word	0x40023800

080178b0 <HAL_UART_MspInit>:
  * This function configures the hardware resources used in this example
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80178b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80178b2:	b0ab      	sub	sp, #172	@ 0xac
 80178b4:	4604      	mov	r4, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80178b6:	2214      	movs	r2, #20
 80178b8:	2100      	movs	r1, #0
 80178ba:	a804      	add	r0, sp, #16
 80178bc:	f003 fc0a 	bl	801b0d4 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80178c0:	2284      	movs	r2, #132	@ 0x84
 80178c2:	2100      	movs	r1, #0
 80178c4:	a809      	add	r0, sp, #36	@ 0x24
 80178c6:	f003 fc05 	bl	801b0d4 <memset>
  if(huart->Instance==USART1)
 80178ca:	6822      	ldr	r2, [r4, #0]
 80178cc:	4b20      	ldr	r3, [pc, #128]	@ (8017950 <HAL_UART_MspInit+0xa0>)
 80178ce:	429a      	cmp	r2, r3
 80178d0:	d13c      	bne.n	801794c <HAL_UART_MspInit+0x9c>

    /* USER CODE END USART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 80178d2:	2340      	movs	r3, #64	@ 0x40
    PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80178d4:	a809      	add	r0, sp, #36	@ 0x24
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 80178d6:	9309      	str	r3, [sp, #36]	@ 0x24
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80178d8:	f000 ffe6 	bl	80188a8 <HAL_RCCEx_PeriphCLKConfig>
 80178dc:	b108      	cbz	r0, 80178e2 <HAL_UART_MspInit+0x32>
    {
      Error_Handler();
 80178de:	f7ff ffab 	bl	8017838 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 80178e2:	4b1c      	ldr	r3, [pc, #112]	@ (8017954 <HAL_UART_MspInit+0xa4>)
    /**USART1 GPIO Configuration
    PB7     ------> USART1_RX
    PA9     ------> USART1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80178e4:	2702      	movs	r7, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80178e6:	2600      	movs	r6, #0
 80178e8:	2503      	movs	r5, #3
    __HAL_RCC_USART1_CLK_ENABLE();
 80178ea:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 80178ec:	2407      	movs	r4, #7
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80178ee:	a904      	add	r1, sp, #16
 80178f0:	4819      	ldr	r0, [pc, #100]	@ (8017958 <HAL_UART_MspInit+0xa8>)
    __HAL_RCC_USART1_CLK_ENABLE();
 80178f2:	f042 0210 	orr.w	r2, r2, #16
 80178f6:	645a      	str	r2, [r3, #68]	@ 0x44
 80178f8:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80178fa:	f002 0210 	and.w	r2, r2, #16
 80178fe:	9201      	str	r2, [sp, #4]
 8017900:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8017902:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8017904:	f042 0202 	orr.w	r2, r2, #2
 8017908:	631a      	str	r2, [r3, #48]	@ 0x30
 801790a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801790c:	f002 0202 	and.w	r2, r2, #2
 8017910:	9202      	str	r2, [sp, #8]
 8017912:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8017914:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8017916:	f042 0201 	orr.w	r2, r2, #1
 801791a:	631a      	str	r2, [r3, #48]	@ 0x30
 801791c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 801791e:	9408      	str	r4, [sp, #32]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8017920:	f003 0301 	and.w	r3, r3, #1
 8017924:	9303      	str	r3, [sp, #12]
 8017926:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8017928:	2380      	movs	r3, #128	@ 0x80
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801792a:	e9cd 6506 	strd	r6, r5, [sp, #24]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801792e:	e9cd 3704 	strd	r3, r7, [sp, #16]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8017932:	f000 fbfd 	bl	8018130 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9;
 8017936:	f44f 7300 	mov.w	r3, #512	@ 0x200
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801793a:	a904      	add	r1, sp, #16
 801793c:	4807      	ldr	r0, [pc, #28]	@ (801795c <HAL_UART_MspInit+0xac>)
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 801793e:	9408      	str	r4, [sp, #32]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8017940:	e9cd 3704 	strd	r3, r7, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8017944:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8017948:	f000 fbf2 	bl	8018130 <HAL_GPIO_Init>

    /* USER CODE END USART1_MspInit 1 */

  }

}
 801794c:	b02b      	add	sp, #172	@ 0xac
 801794e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017950:	40011000 	.word	0x40011000
 8017954:	40023800 	.word	0x40023800
 8017958:	40020400 	.word	0x40020400
 801795c:	40020000 	.word	0x40020000

08017960 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8017960:	e7fe      	b.n	8017960 <NMI_Handler>

08017962 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8017962:	b508      	push	{r3, lr}
  /* USER CODE BEGIN HardFault_IRQn 0 */
	print_hardfault_reason();
 8017964:	f7ff fee8 	bl	8017738 <print_hardfault_reason>
  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8017968:	e7fe      	b.n	8017968 <HardFault_Handler+0x6>

0801796a <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 801796a:	e7fe      	b.n	801796a <MemManage_Handler>

0801796c <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 801796c:	e7fe      	b.n	801796c <BusFault_Handler>

0801796e <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 801796e:	e7fe      	b.n	801796e <UsageFault_Handler>

08017970 <SVC_Handler>:

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8017970:	4770      	bx	lr

08017972 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
 8017972:	4770      	bx	lr

08017974 <PendSV_Handler>:
}

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
 8017974:	4770      	bx	lr

08017976 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8017976:	f000 b98f 	b.w	8017c98 <HAL_IncTick>

0801797a <_getpid>:
}

int _getpid(void)
{
  return 1;
}
 801797a:	2001      	movs	r0, #1
 801797c:	4770      	bx	lr

0801797e <_kill>:

int _kill(int pid, int sig)
{
 801797e:	b508      	push	{r3, lr}
  (void)pid;
  (void)sig;
  errno = EINVAL;
 8017980:	f003 fc06 	bl	801b190 <__errno>
 8017984:	2316      	movs	r3, #22
 8017986:	6003      	str	r3, [r0, #0]
  return -1;
}
 8017988:	f04f 30ff 	mov.w	r0, #4294967295
 801798c:	bd08      	pop	{r3, pc}

0801798e <_exit>:

void _exit (int status)
{
 801798e:	b508      	push	{r3, lr}
  errno = EINVAL;
 8017990:	f003 fbfe 	bl	801b190 <__errno>
 8017994:	2316      	movs	r3, #22
 8017996:	6003      	str	r3, [r0, #0]
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
 8017998:	e7fe      	b.n	8017998 <_exit+0xa>

0801799a <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 801799a:	b570      	push	{r4, r5, r6, lr}
 801799c:	460e      	mov	r6, r1
 801799e:	4615      	mov	r5, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80179a0:	460c      	mov	r4, r1
 80179a2:	1ba3      	subs	r3, r4, r6
 80179a4:	429d      	cmp	r5, r3
 80179a6:	dc01      	bgt.n	80179ac <_read+0x12>
  {
    *ptr++ = __io_getchar();
  }

  return len;
}
 80179a8:	4628      	mov	r0, r5
 80179aa:	bd70      	pop	{r4, r5, r6, pc}
    *ptr++ = __io_getchar();
 80179ac:	f3af 8000 	nop.w
 80179b0:	f804 0b01 	strb.w	r0, [r4], #1
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80179b4:	e7f5      	b.n	80179a2 <_read+0x8>

080179b6 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 80179b6:	b570      	push	{r4, r5, r6, lr}
 80179b8:	460e      	mov	r6, r1
 80179ba:	4615      	mov	r5, r2
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80179bc:	460c      	mov	r4, r1
 80179be:	1ba3      	subs	r3, r4, r6
 80179c0:	429d      	cmp	r5, r3
 80179c2:	dc01      	bgt.n	80179c8 <_write+0x12>
  {
    __io_putchar(*ptr++);
  }
  return len;
}
 80179c4:	4628      	mov	r0, r5
 80179c6:	bd70      	pop	{r4, r5, r6, pc}
    __io_putchar(*ptr++);
 80179c8:	f814 0b01 	ldrb.w	r0, [r4], #1
 80179cc:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80179d0:	e7f5      	b.n	80179be <_write+0x8>

080179d2 <_close>:

int _close(int file)
{
  (void)file;
  return -1;
}
 80179d2:	f04f 30ff 	mov.w	r0, #4294967295
 80179d6:	4770      	bx	lr

080179d8 <_fstat>:


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
 80179d8:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
  return 0;
}
 80179dc:	2000      	movs	r0, #0
  st->st_mode = S_IFCHR;
 80179de:	604b      	str	r3, [r1, #4]
}
 80179e0:	4770      	bx	lr

080179e2 <_isatty>:

int _isatty(int file)
{
  (void)file;
  return 1;
}
 80179e2:	2001      	movs	r0, #1
 80179e4:	4770      	bx	lr

080179e6 <_lseek>:
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}
 80179e6:	2000      	movs	r0, #0
 80179e8:	4770      	bx	lr
	...

080179ec <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80179ec:	4a0a      	ldr	r2, [pc, #40]	@ (8017a18 <_sbrk+0x2c>)
 80179ee:	6813      	ldr	r3, [r2, #0]
{
 80179f0:	b510      	push	{r4, lr}
  if (NULL == __sbrk_heap_end)
 80179f2:	b90b      	cbnz	r3, 80179f8 <_sbrk+0xc>
  {
    __sbrk_heap_end = &_end;
 80179f4:	4b09      	ldr	r3, [pc, #36]	@ (8017a1c <_sbrk+0x30>)
 80179f6:	6013      	str	r3, [r2, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80179f8:	4909      	ldr	r1, [pc, #36]	@ (8017a20 <_sbrk+0x34>)
 80179fa:	4418      	add	r0, r3
 80179fc:	4c09      	ldr	r4, [pc, #36]	@ (8017a24 <_sbrk+0x38>)
 80179fe:	1b09      	subs	r1, r1, r4
 8017a00:	4288      	cmp	r0, r1
 8017a02:	d907      	bls.n	8017a14 <_sbrk+0x28>
  {
    errno = ENOMEM;
 8017a04:	f003 fbc4 	bl	801b190 <__errno>
 8017a08:	230c      	movs	r3, #12
 8017a0a:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8017a0c:	f04f 33ff 	mov.w	r3, #4294967295

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;

  return (void *)prev_heap_end;
}
 8017a10:	4618      	mov	r0, r3
 8017a12:	bd10      	pop	{r4, pc}
  __sbrk_heap_end += incr;
 8017a14:	6010      	str	r0, [r2, #0]
  return (void *)prev_heap_end;
 8017a16:	e7fb      	b.n	8017a10 <_sbrk+0x24>
 8017a18:	2000192c 	.word	0x2000192c
 8017a1c:	20001aa0 	.word	0x20001aa0
 8017a20:	20050000 	.word	0x20050000
 8017a24:	00000400 	.word	0x00000400

08017a28 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8017a28:	4a03      	ldr	r2, [pc, #12]	@ (8017a38 <SystemInit+0x10>)
 8017a2a:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8017a2e:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8017a32:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8017a36:	4770      	bx	lr
 8017a38:	e000ed00 	.word	0xe000ed00

08017a3c <_tfp_putc>:
void tfp_init(void* handle) {
    g_uart_handle = (UART_HandleTypeDef*)handle;
}

static void _tfp_putc(char c) {
    if (g_uart_handle) {
 8017a3c:	4b06      	ldr	r3, [pc, #24]	@ (8017a58 <_tfp_putc+0x1c>)
static void _tfp_putc(char c) {
 8017a3e:	b507      	push	{r0, r1, r2, lr}
 8017a40:	f88d 0007 	strb.w	r0, [sp, #7]
    if (g_uart_handle) {
 8017a44:	6818      	ldr	r0, [r3, #0]
 8017a46:	b128      	cbz	r0, 8017a54 <_tfp_putc+0x18>
        HAL_UART_Transmit(g_uart_handle, (uint8_t*)&c, 1, 100);
 8017a48:	2364      	movs	r3, #100	@ 0x64
 8017a4a:	2201      	movs	r2, #1
 8017a4c:	f10d 0107 	add.w	r1, sp, #7
 8017a50:	f001 fc23 	bl	801929a <HAL_UART_Transmit>
    }
}
 8017a54:	b003      	add	sp, #12
 8017a56:	bd00      	pop	{pc}
 8017a58:	20001930 	.word	0x20001930

08017a5c <_tfp_print_unsigned>:

static void _tfp_puts(char *s) {
    while (*s) _tfp_putc(*s++);
}

static void _tfp_print_unsigned(uint32_t i, int base) {
 8017a5c:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char hex[] = "0123456789ABCDEF";
 8017a5e:	4a1a      	ldr	r2, [pc, #104]	@ (8017ac8 <_tfp_print_unsigned+0x6c>)
static void _tfp_print_unsigned(uint32_t i, int base) {
 8017a60:	b08f      	sub	sp, #60	@ 0x3c
 8017a62:	4603      	mov	r3, r0
 8017a64:	460e      	mov	r6, r1
    const char hex[] = "0123456789ABCDEF";
 8017a66:	ac01      	add	r4, sp, #4
 8017a68:	f102 0710 	add.w	r7, r2, #16
 8017a6c:	6810      	ldr	r0, [r2, #0]
 8017a6e:	3208      	adds	r2, #8
 8017a70:	f852 1c04 	ldr.w	r1, [r2, #-4]
 8017a74:	4625      	mov	r5, r4
 8017a76:	42ba      	cmp	r2, r7
 8017a78:	c503      	stmia	r5!, {r0, r1}
 8017a7a:	462c      	mov	r4, r5
 8017a7c:	d1f6      	bne.n	8017a6c <_tfp_print_unsigned+0x10>
 8017a7e:	7812      	ldrb	r2, [r2, #0]
 8017a80:	702a      	strb	r2, [r5, #0]
    char buf[32];
    int pos = 0;
    if (i == 0) {
 8017a82:	b92b      	cbnz	r3, 8017a90 <_tfp_print_unsigned+0x34>
        _tfp_putc('0');
 8017a84:	2030      	movs	r0, #48	@ 0x30
    while (i > 0) {
        buf[pos++] = hex[i % base];
        i /= base;
    }
    while (pos > 0) _tfp_putc(buf[--pos]);
}
 8017a86:	b00f      	add	sp, #60	@ 0x3c
 8017a88:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        _tfp_putc('0');
 8017a8c:	f7ff bfd6 	b.w	8017a3c <_tfp_putc>
 8017a90:	aa06      	add	r2, sp, #24
    int pos = 0;
 8017a92:	2400      	movs	r4, #0
 8017a94:	4615      	mov	r5, r2
    while (i > 0) {
 8017a96:	429e      	cmp	r6, r3
        buf[pos++] = hex[i % base];
 8017a98:	f104 0401 	add.w	r4, r4, #1
 8017a9c:	fbb3 f0f6 	udiv	r0, r3, r6
 8017aa0:	fb06 3110 	mls	r1, r6, r0, r3
        i /= base;
 8017aa4:	4603      	mov	r3, r0
        buf[pos++] = hex[i % base];
 8017aa6:	f101 0138 	add.w	r1, r1, #56	@ 0x38
 8017aaa:	4469      	add	r1, sp
 8017aac:	f811 1c34 	ldrb.w	r1, [r1, #-52]
 8017ab0:	f802 1b01 	strb.w	r1, [r2], #1
    while (i > 0) {
 8017ab4:	d9ef      	bls.n	8017a96 <_tfp_print_unsigned+0x3a>
    while (pos > 0) _tfp_putc(buf[--pos]);
 8017ab6:	3c01      	subs	r4, #1
 8017ab8:	5d28      	ldrb	r0, [r5, r4]
 8017aba:	f7ff ffbf 	bl	8017a3c <_tfp_putc>
 8017abe:	2c00      	cmp	r4, #0
 8017ac0:	d1f9      	bne.n	8017ab6 <_tfp_print_unsigned+0x5a>
}
 8017ac2:	b00f      	add	sp, #60	@ 0x3c
 8017ac4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017ac6:	bf00      	nop
 8017ac8:	0801c2f5 	.word	0x0801c2f5

08017acc <tfp_init>:
    g_uart_handle = (UART_HandleTypeDef*)handle;
 8017acc:	4b01      	ldr	r3, [pc, #4]	@ (8017ad4 <tfp_init+0x8>)
 8017ace:	6018      	str	r0, [r3, #0]
}
 8017ad0:	4770      	bx	lr
 8017ad2:	bf00      	nop
 8017ad4:	20001930 	.word	0x20001930

08017ad8 <tfp_printf>:
        i = -i;
    }
    _tfp_print_unsigned((uint32_t)i, 10);
}

void tfp_printf(const char *fmt, ...) {
 8017ad8:	b40f      	push	{r0, r1, r2, r3}
 8017ada:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8017adc:	ab06      	add	r3, sp, #24
 8017ade:	f853 4b04 	ldr.w	r4, [r3], #4
    va_list va;
    va_start(va, fmt);
 8017ae2:	9301      	str	r3, [sp, #4]
    char ch;

    while ((ch = *fmt++) != 0) {
 8017ae4:	7820      	ldrb	r0, [r4, #0]
 8017ae6:	b920      	cbnz	r0, 8017af2 <tfp_printf+0x1a>
            default: _tfp_putc(ch); break;
        }
    }
end:
    va_end(va);
}
 8017ae8:	b003      	add	sp, #12
 8017aea:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8017aee:	b004      	add	sp, #16
 8017af0:	4770      	bx	lr
        if (ch != '%') {
 8017af2:	2825      	cmp	r0, #37	@ 0x25
 8017af4:	d003      	beq.n	8017afe <tfp_printf+0x26>
    while ((ch = *fmt++) != 0) {
 8017af6:	3401      	adds	r4, #1
            _tfp_putc(ch);
 8017af8:	f7ff ffa0 	bl	8017a3c <_tfp_putc>
            continue;
 8017afc:	e7f2      	b.n	8017ae4 <tfp_printf+0xc>
        ch = *fmt++;
 8017afe:	7860      	ldrb	r0, [r4, #1]
        switch (ch) {
 8017b00:	2878      	cmp	r0, #120	@ 0x78
 8017b02:	d808      	bhi.n	8017b16 <tfp_printf+0x3e>
 8017b04:	286f      	cmp	r0, #111	@ 0x6f
 8017b06:	d809      	bhi.n	8017b1c <tfp_printf+0x44>
 8017b08:	2863      	cmp	r0, #99	@ 0x63
 8017b0a:	d03f      	beq.n	8017b8c <tfp_printf+0xb4>
 8017b0c:	d820      	bhi.n	8017b50 <tfp_printf+0x78>
 8017b0e:	2800      	cmp	r0, #0
 8017b10:	d0ea      	beq.n	8017ae8 <tfp_printf+0x10>
 8017b12:	2858      	cmp	r0, #88	@ 0x58
 8017b14:	d031      	beq.n	8017b7a <tfp_printf+0xa2>
            default: _tfp_putc(ch); break;
 8017b16:	f7ff ff91 	bl	8017a3c <_tfp_putc>
 8017b1a:	e035      	b.n	8017b88 <tfp_printf+0xb0>
        switch (ch) {
 8017b1c:	f1a0 0370 	sub.w	r3, r0, #112	@ 0x70
 8017b20:	2b08      	cmp	r3, #8
 8017b22:	d8f8      	bhi.n	8017b16 <tfp_printf+0x3e>
 8017b24:	a201      	add	r2, pc, #4	@ (adr r2, 8017b2c <tfp_printf+0x54>)
 8017b26:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8017b2a:	bf00      	nop
 8017b2c:	08017b6f 	.word	0x08017b6f
 8017b30:	08017b17 	.word	0x08017b17
 8017b34:	08017b17 	.word	0x08017b17
 8017b38:	08017b97 	.word	0x08017b97
 8017b3c:	08017b17 	.word	0x08017b17
 8017b40:	08017baf 	.word	0x08017baf
 8017b44:	08017b17 	.word	0x08017b17
 8017b48:	08017b17 	.word	0x08017b17
 8017b4c:	08017b7b 	.word	0x08017b7b
 8017b50:	2864      	cmp	r0, #100	@ 0x64
 8017b52:	d1e0      	bne.n	8017b16 <tfp_printf+0x3e>
            case 'd': _tfp_print_signed(va_arg(va, int)); break;
 8017b54:	9b01      	ldr	r3, [sp, #4]
 8017b56:	681d      	ldr	r5, [r3, #0]
 8017b58:	1d1a      	adds	r2, r3, #4
    if (i < 0) {
 8017b5a:	2d00      	cmp	r5, #0
            case 'd': _tfp_print_signed(va_arg(va, int)); break;
 8017b5c:	9201      	str	r2, [sp, #4]
    if (i < 0) {
 8017b5e:	da03      	bge.n	8017b68 <tfp_printf+0x90>
        i = -i;
 8017b60:	426d      	negs	r5, r5
        _tfp_putc('-');
 8017b62:	202d      	movs	r0, #45	@ 0x2d
 8017b64:	f7ff ff6a 	bl	8017a3c <_tfp_putc>
    _tfp_print_unsigned((uint32_t)i, 10);
 8017b68:	210a      	movs	r1, #10
 8017b6a:	4628      	mov	r0, r5
 8017b6c:	e00a      	b.n	8017b84 <tfp_printf+0xac>
    while (*s) _tfp_putc(*s++);
 8017b6e:	2030      	movs	r0, #48	@ 0x30
 8017b70:	f7ff ff64 	bl	8017a3c <_tfp_putc>
 8017b74:	2078      	movs	r0, #120	@ 0x78
 8017b76:	f7ff ff61 	bl	8017a3c <_tfp_putc>
                _tfp_print_unsigned((uintptr_t)va_arg(va, void*), 16);
 8017b7a:	9b01      	ldr	r3, [sp, #4]
 8017b7c:	2110      	movs	r1, #16
 8017b7e:	1d1a      	adds	r2, r3, #4
 8017b80:	9201      	str	r2, [sp, #4]
 8017b82:	6818      	ldr	r0, [r3, #0]
 8017b84:	f7ff ff6a 	bl	8017a5c <_tfp_print_unsigned>
        ch = *fmt++;
 8017b88:	3402      	adds	r4, #2
 8017b8a:	e7ab      	b.n	8017ae4 <tfp_printf+0xc>
            case 'c': _tfp_putc((char)va_arg(va, int)); break;
 8017b8c:	9b01      	ldr	r3, [sp, #4]
 8017b8e:	1d1a      	adds	r2, r3, #4
 8017b90:	7818      	ldrb	r0, [r3, #0]
 8017b92:	9201      	str	r2, [sp, #4]
 8017b94:	e7bf      	b.n	8017b16 <tfp_printf+0x3e>
            case 's': _tfp_puts(va_arg(va, char*)); break;
 8017b96:	9b01      	ldr	r3, [sp, #4]
 8017b98:	681d      	ldr	r5, [r3, #0]
 8017b9a:	1d1a      	adds	r2, r3, #4
 8017b9c:	3d01      	subs	r5, #1
 8017b9e:	9201      	str	r2, [sp, #4]
    while (*s) _tfp_putc(*s++);
 8017ba0:	f815 0f01 	ldrb.w	r0, [r5, #1]!
 8017ba4:	2800      	cmp	r0, #0
 8017ba6:	d0ef      	beq.n	8017b88 <tfp_printf+0xb0>
 8017ba8:	f7ff ff48 	bl	8017a3c <_tfp_putc>
 8017bac:	e7f8      	b.n	8017ba0 <tfp_printf+0xc8>
            case 'u': _tfp_print_unsigned(va_arg(va, uint32_t), 10); break;
 8017bae:	9b01      	ldr	r3, [sp, #4]
 8017bb0:	210a      	movs	r1, #10
 8017bb2:	1d1a      	adds	r2, r3, #4
 8017bb4:	9201      	str	r2, [sp, #4]
 8017bb6:	e7e4      	b.n	8017b82 <tfp_printf+0xaa>

08017bb8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8017bb8:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8017bf0 <LoopFillZerobss+0xe>
  
/* Call the clock system initialization function.*/
  bl  SystemInit   
 8017bbc:	f7ff ff34 	bl	8017a28 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8017bc0:	480c      	ldr	r0, [pc, #48]	@ (8017bf4 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8017bc2:	490d      	ldr	r1, [pc, #52]	@ (8017bf8 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8017bc4:	4a0d      	ldr	r2, [pc, #52]	@ (8017bfc <LoopFillZerobss+0x1a>)
  movs r3, #0
 8017bc6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8017bc8:	e002      	b.n	8017bd0 <LoopCopyDataInit>

08017bca <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8017bca:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8017bcc:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8017bce:	3304      	adds	r3, #4

08017bd0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8017bd0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8017bd2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8017bd4:	d3f9      	bcc.n	8017bca <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8017bd6:	4a0a      	ldr	r2, [pc, #40]	@ (8017c00 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8017bd8:	4c0a      	ldr	r4, [pc, #40]	@ (8017c04 <LoopFillZerobss+0x22>)
  movs r3, #0
 8017bda:	2300      	movs	r3, #0
  b LoopFillZerobss
 8017bdc:	e001      	b.n	8017be2 <LoopFillZerobss>

08017bde <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8017bde:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8017be0:	3204      	adds	r2, #4

08017be2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8017be2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8017be4:	d3fb      	bcc.n	8017bde <FillZerobss>
  
/* Call static constructors */
    bl __libc_init_array
 8017be6:	f003 fad9 	bl	801b19c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8017bea:	f7ff fcbf 	bl	801756c <main>
  bx  lr    
 8017bee:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8017bf0:	20050000 	.word	0x20050000
  ldr r0, =_sdata
 8017bf4:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8017bf8:	20000068 	.word	0x20000068
  ldr r2, =_sidata
 8017bfc:	0801c7e8 	.word	0x0801c7e8
  ldr r2, =_sbss
 8017c00:	20000068 	.word	0x20000068
  ldr r4, =_ebss
 8017c04:	20001aa0 	.word	0x20001aa0

08017c08 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8017c08:	e7fe      	b.n	8017c08 <ADC_IRQHandler>

08017c0a <HAL_MspDeInit>:

/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
 8017c0a:	4770      	bx	lr

08017c0c <HAL_DeInit>:
{
 8017c0c:	b510      	push	{r4, lr}
  __HAL_RCC_APB1_FORCE_RESET();
 8017c0e:	4b09      	ldr	r3, [pc, #36]	@ (8017c34 <HAL_DeInit+0x28>)
 8017c10:	f04f 32ff 	mov.w	r2, #4294967295
  __HAL_RCC_APB1_RELEASE_RESET();
 8017c14:	2400      	movs	r4, #0
  __HAL_RCC_APB1_FORCE_RESET();
 8017c16:	621a      	str	r2, [r3, #32]
  __HAL_RCC_APB1_RELEASE_RESET();
 8017c18:	621c      	str	r4, [r3, #32]
  __HAL_RCC_APB2_FORCE_RESET();
 8017c1a:	625a      	str	r2, [r3, #36]	@ 0x24
  __HAL_RCC_APB2_RELEASE_RESET();
 8017c1c:	625c      	str	r4, [r3, #36]	@ 0x24
  __HAL_RCC_AHB1_FORCE_RESET();
 8017c1e:	611a      	str	r2, [r3, #16]
  __HAL_RCC_AHB1_RELEASE_RESET();
 8017c20:	611c      	str	r4, [r3, #16]
  __HAL_RCC_AHB2_FORCE_RESET();
 8017c22:	615a      	str	r2, [r3, #20]
  __HAL_RCC_AHB2_RELEASE_RESET();
 8017c24:	615c      	str	r4, [r3, #20]
  __HAL_RCC_AHB3_FORCE_RESET();
 8017c26:	619a      	str	r2, [r3, #24]
  __HAL_RCC_AHB3_RELEASE_RESET();
 8017c28:	619c      	str	r4, [r3, #24]
  HAL_MspDeInit();
 8017c2a:	f7ff ffee 	bl	8017c0a <HAL_MspDeInit>
}
 8017c2e:	4620      	mov	r0, r4
 8017c30:	bd10      	pop	{r4, pc}
 8017c32:	bf00      	nop
 8017c34:	40023800 	.word	0x40023800

08017c38 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8017c38:	b538      	push	{r3, r4, r5, lr}
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8017c3a:	4b0e      	ldr	r3, [pc, #56]	@ (8017c74 <HAL_InitTick+0x3c>)
{
 8017c3c:	4605      	mov	r5, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8017c3e:	781a      	ldrb	r2, [r3, #0]
 8017c40:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8017c44:	fbb3 f3f2 	udiv	r3, r3, r2
 8017c48:	4a0b      	ldr	r2, [pc, #44]	@ (8017c78 <HAL_InitTick+0x40>)
 8017c4a:	6810      	ldr	r0, [r2, #0]
 8017c4c:	fbb0 f0f3 	udiv	r0, r0, r3
 8017c50:	f000 f886 	bl	8017d60 <HAL_SYSTICK_Config>
 8017c54:	4604      	mov	r4, r0
 8017c56:	b958      	cbnz	r0, 8017c70 <HAL_InitTick+0x38>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8017c58:	2d0f      	cmp	r5, #15
 8017c5a:	d809      	bhi.n	8017c70 <HAL_InitTick+0x38>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8017c5c:	4602      	mov	r2, r0
 8017c5e:	4629      	mov	r1, r5
 8017c60:	f04f 30ff 	mov.w	r0, #4294967295
 8017c64:	f000 f84e 	bl	8017d04 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8017c68:	4b04      	ldr	r3, [pc, #16]	@ (8017c7c <HAL_InitTick+0x44>)
 8017c6a:	4620      	mov	r0, r4
 8017c6c:	601d      	str	r5, [r3, #0]
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8017c6e:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8017c70:	2001      	movs	r0, #1
 8017c72:	e7fc      	b.n	8017c6e <HAL_InitTick+0x36>
 8017c74:	20000004 	.word	0x20000004
 8017c78:	20000000 	.word	0x20000000
 8017c7c:	20000008 	.word	0x20000008

08017c80 <HAL_Init>:
{
 8017c80:	b508      	push	{r3, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8017c82:	2003      	movs	r0, #3
 8017c84:	f000 f82c 	bl	8017ce0 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8017c88:	200f      	movs	r0, #15
 8017c8a:	f7ff ffd5 	bl	8017c38 <HAL_InitTick>
  HAL_MspInit();
 8017c8e:	f7ff fdd5 	bl	801783c <HAL_MspInit>
}
 8017c92:	2000      	movs	r0, #0
 8017c94:	bd08      	pop	{r3, pc}
	...

08017c98 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8017c98:	4a03      	ldr	r2, [pc, #12]	@ (8017ca8 <HAL_IncTick+0x10>)
 8017c9a:	4b04      	ldr	r3, [pc, #16]	@ (8017cac <HAL_IncTick+0x14>)
 8017c9c:	6811      	ldr	r1, [r2, #0]
 8017c9e:	781b      	ldrb	r3, [r3, #0]
 8017ca0:	440b      	add	r3, r1
 8017ca2:	6013      	str	r3, [r2, #0]
}
 8017ca4:	4770      	bx	lr
 8017ca6:	bf00      	nop
 8017ca8:	20001934 	.word	0x20001934
 8017cac:	20000004 	.word	0x20000004

08017cb0 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8017cb0:	4b01      	ldr	r3, [pc, #4]	@ (8017cb8 <HAL_GetTick+0x8>)
 8017cb2:	6818      	ldr	r0, [r3, #0]
}
 8017cb4:	4770      	bx	lr
 8017cb6:	bf00      	nop
 8017cb8:	20001934 	.word	0x20001934

08017cbc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8017cbc:	b538      	push	{r3, r4, r5, lr}
 8017cbe:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8017cc0:	f7ff fff6 	bl	8017cb0 <HAL_GetTick>
 8017cc4:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8017cc6:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 8017cc8:	bf1e      	ittt	ne
 8017cca:	4b04      	ldrne	r3, [pc, #16]	@ (8017cdc <HAL_Delay+0x20>)
 8017ccc:	781b      	ldrbne	r3, [r3, #0]
 8017cce:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8017cd0:	f7ff ffee 	bl	8017cb0 <HAL_GetTick>
 8017cd4:	1b40      	subs	r0, r0, r5
 8017cd6:	42a0      	cmp	r0, r4
 8017cd8:	d3fa      	bcc.n	8017cd0 <HAL_Delay+0x14>
  {
  }
}
 8017cda:	bd38      	pop	{r3, r4, r5, pc}
 8017cdc:	20000004 	.word	0x20000004

08017ce0 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8017ce0:	4907      	ldr	r1, [pc, #28]	@ (8017d00 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8017ce2:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8017ce4:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8017ce6:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8017cea:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8017cee:	0412      	lsls	r2, r2, #16
 8017cf0:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8017cf2:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8017cf4:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8017cf8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 8017cfc:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8017cfe:	4770      	bx	lr
 8017d00:	e000ed00 	.word	0xe000ed00

08017d04 <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8017d04:	4b14      	ldr	r3, [pc, #80]	@ (8017d58 <HAL_NVIC_SetPriority+0x54>)
 8017d06:	68db      	ldr	r3, [r3, #12]
 8017d08:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8017d0c:	b530      	push	{r4, r5, lr}
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8017d0e:	1edd      	subs	r5, r3, #3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8017d10:	f04f 34ff 	mov.w	r4, #4294967295
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8017d14:	2d04      	cmp	r5, #4
 8017d16:	bf92      	itee	ls
 8017d18:	f1c3 0307 	rsbls	r3, r3, #7
 8017d1c:	2304      	movhi	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8017d1e:	2500      	movhi	r5, #0
  if ((int32_t)(IRQn) >= 0)
 8017d20:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8017d22:	fa04 f303 	lsl.w	r3, r4, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8017d26:	fa04 f405 	lsl.w	r4, r4, r5
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8017d2a:	ea21 0103 	bic.w	r1, r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8017d2e:	ea22 0204 	bic.w	r2, r2, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8017d32:	fa01 f105 	lsl.w	r1, r1, r5
 8017d36:	ea41 0102 	orr.w	r1, r1, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8017d3a:	ea4f 1301 	mov.w	r3, r1, lsl #4
  if ((int32_t)(IRQn) >= 0)
 8017d3e:	db06      	blt.n	8017d4e <HAL_NVIC_SetPriority+0x4a>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8017d40:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 8017d44:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 8017d48:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8017d4c:	bd30      	pop	{r4, r5, pc}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8017d4e:	f000 000f 	and.w	r0, r0, #15
 8017d52:	4a02      	ldr	r2, [pc, #8]	@ (8017d5c <HAL_NVIC_SetPriority+0x58>)
 8017d54:	5413      	strb	r3, [r2, r0]
 8017d56:	e7f9      	b.n	8017d4c <HAL_NVIC_SetPriority+0x48>
 8017d58:	e000ed00 	.word	0xe000ed00
 8017d5c:	e000ed14 	.word	0xe000ed14

08017d60 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8017d60:	3801      	subs	r0, #1
 8017d62:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 8017d66:	d20b      	bcs.n	8017d80 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8017d68:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8017d6c:	4a05      	ldr	r2, [pc, #20]	@ (8017d84 <HAL_SYSTICK_Config+0x24>)
 8017d6e:	21f0      	movs	r1, #240	@ 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8017d70:	6158      	str	r0, [r3, #20]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8017d72:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8017d74:	f882 1023 	strb.w	r1, [r2, #35]	@ 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8017d78:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8017d7a:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8017d7c:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8017d7e:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8017d80:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8017d82:	4770      	bx	lr
 8017d84:	e000ed00 	.word	0xe000ed00

08017d88 <HAL_MPU_Disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 8017d88:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8017d8c:	4b04      	ldr	r3, [pc, #16]	@ (8017da0 <HAL_MPU_Disable+0x18>)
 8017d8e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8017d90:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8017d94:	625a      	str	r2, [r3, #36]	@ 0x24
  
  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 8017d96:	2200      	movs	r2, #0
 8017d98:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
}
 8017d9c:	4770      	bx	lr
 8017d9e:	bf00      	nop
 8017da0:	e000ed00 	.word	0xe000ed00

08017da4 <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8017da4:	4b06      	ldr	r3, [pc, #24]	@ (8017dc0 <HAL_MPU_Enable+0x1c>)
 8017da6:	f040 0001 	orr.w	r0, r0, #1
 8017daa:	f8c3 0094 	str.w	r0, [r3, #148]	@ 0x94
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8017dae:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8017db0:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8017db4:	625a      	str	r2, [r3, #36]	@ 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8017db6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8017dba:	f3bf 8f6f 	isb	sy
  
  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 8017dbe:	4770      	bx	lr
 8017dc0:	e000ed00 	.word	0xe000ed00

08017dc4 <HAL_MPU_ConfigRegion>:
  assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
  assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
  assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8017dc4:	7843      	ldrb	r3, [r0, #1]
 8017dc6:	4a14      	ldr	r2, [pc, #80]	@ (8017e18 <HAL_MPU_ConfigRegion+0x54>)
 8017dc8:	f8c2 3098 	str.w	r3, [r2, #152]	@ 0x98

  /* Disable the Region */
  CLEAR_BIT(MPU->RASR, MPU_RASR_ENABLE_Msk);
 8017dcc:	f8d2 30a0 	ldr.w	r3, [r2, #160]	@ 0xa0
 8017dd0:	f023 0301 	bic.w	r3, r3, #1
 8017dd4:	f8c2 30a0 	str.w	r3, [r2, #160]	@ 0xa0

  /* Apply configuration */
  MPU->RBAR = MPU_Init->BaseAddress;
 8017dd8:	6843      	ldr	r3, [r0, #4]
 8017dda:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
              ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8017dde:	7ac3      	ldrb	r3, [r0, #11]
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8017de0:	7b01      	ldrb	r1, [r0, #12]
              ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8017de2:	061b      	lsls	r3, r3, #24
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8017de4:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
              ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
              ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
              ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
              ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
              ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 8017de8:	7801      	ldrb	r1, [r0, #0]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8017dea:	430b      	orrs	r3, r1
              ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8017dec:	7a81      	ldrb	r1, [r0, #10]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8017dee:	ea43 43c1 	orr.w	r3, r3, r1, lsl #19
              ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8017df2:	7b41      	ldrb	r1, [r0, #13]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8017df4:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
              ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8017df8:	7b81      	ldrb	r1, [r0, #14]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8017dfa:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
              ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8017dfe:	7bc1      	ldrb	r1, [r0, #15]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8017e00:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
              ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8017e04:	7a41      	ldrb	r1, [r0, #9]
              ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8017e06:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8017e0a:	7a01      	ldrb	r1, [r0, #8]
 8017e0c:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
  MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8017e10:	f8c2 30a0 	str.w	r3, [r2, #160]	@ 0xa0
}
 8017e14:	4770      	bx	lr
 8017e16:	bf00      	nop
 8017e18:	e000ed00 	.word	0xe000ed00

08017e1c <FLASH_Program_DoubleWord>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  FLASH->CR &= CR_PSIZE_MASK;
 8017e1c:	490a      	ldr	r1, [pc, #40]	@ (8017e48 <FLASH_Program_DoubleWord+0x2c>)
{
 8017e1e:	b510      	push	{r4, lr}
  FLASH->CR &= CR_PSIZE_MASK;
 8017e20:	690c      	ldr	r4, [r1, #16]
 8017e22:	f424 7440 	bic.w	r4, r4, #768	@ 0x300
 8017e26:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8017e28:	690c      	ldr	r4, [r1, #16]
 8017e2a:	f444 7440 	orr.w	r4, r4, #768	@ 0x300
 8017e2e:	610c      	str	r4, [r1, #16]
  FLASH->CR |= FLASH_CR_PG;
 8017e30:	690c      	ldr	r4, [r1, #16]
 8017e32:	f044 0401 	orr.w	r4, r4, #1
 8017e36:	610c      	str	r4, [r1, #16]

  /* Program first word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8017e38:	6002      	str	r2, [r0, #0]
 8017e3a:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8017e3e:	6043      	str	r3, [r0, #4]
  __ASM volatile ("dsb 0xF":::"memory");
 8017e40:	f3bf 8f4f 	dsb	sy

  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
 8017e44:	bd10      	pop	{r4, pc}
 8017e46:	bf00      	nop
 8017e48:	40023c00 	.word	0x40023c00

08017e4c <FLASH_Program_Word>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  FLASH->CR &= CR_PSIZE_MASK;
 8017e4c:	4b08      	ldr	r3, [pc, #32]	@ (8017e70 <FLASH_Program_Word+0x24>)
 8017e4e:	691a      	ldr	r2, [r3, #16]
 8017e50:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8017e54:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 8017e56:	691a      	ldr	r2, [r3, #16]
 8017e58:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8017e5c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8017e5e:	691a      	ldr	r2, [r3, #16]
 8017e60:	f042 0201 	orr.w	r2, r2, #1
 8017e64:	611a      	str	r2, [r3, #16]

  *(__IO uint32_t*)Address = Data;
 8017e66:	6001      	str	r1, [r0, #0]
 8017e68:	f3bf 8f4f 	dsb	sy
  
  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
 8017e6c:	4770      	bx	lr
 8017e6e:	bf00      	nop
 8017e70:	40023c00 	.word	0x40023c00

08017e74 <FLASH_Program_HalfWord>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  FLASH->CR &= CR_PSIZE_MASK;
 8017e74:	4b08      	ldr	r3, [pc, #32]	@ (8017e98 <FLASH_Program_HalfWord+0x24>)
 8017e76:	691a      	ldr	r2, [r3, #16]
 8017e78:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8017e7c:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8017e7e:	691a      	ldr	r2, [r3, #16]
 8017e80:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8017e84:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8017e86:	691a      	ldr	r2, [r3, #16]
 8017e88:	f042 0201 	orr.w	r2, r2, #1
 8017e8c:	611a      	str	r2, [r3, #16]

  *(__IO uint16_t*)Address = Data;
 8017e8e:	8001      	strh	r1, [r0, #0]
 8017e90:	f3bf 8f4f 	dsb	sy

  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
  
}
 8017e94:	4770      	bx	lr
 8017e96:	bf00      	nop
 8017e98:	40023c00 	.word	0x40023c00

08017e9c <FLASH_Program_Byte>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  FLASH->CR &= CR_PSIZE_MASK;
 8017e9c:	4b07      	ldr	r3, [pc, #28]	@ (8017ebc <FLASH_Program_Byte+0x20>)
 8017e9e:	691a      	ldr	r2, [r3, #16]
 8017ea0:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8017ea4:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 8017ea6:	691a      	ldr	r2, [r3, #16]
 8017ea8:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_PG;
 8017eaa:	691a      	ldr	r2, [r3, #16]
 8017eac:	f042 0201 	orr.w	r2, r2, #1
 8017eb0:	611a      	str	r2, [r3, #16]

  *(__IO uint8_t*)Address = Data;
 8017eb2:	7001      	strb	r1, [r0, #0]
 8017eb4:	f3bf 8f4f 	dsb	sy

  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
 8017eb8:	4770      	bx	lr
 8017eba:	bf00      	nop
 8017ebc:	40023c00 	.word	0x40023c00

08017ec0 <FLASH_SetErrorCode>:
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8017ec0:	4a16      	ldr	r2, [pc, #88]	@ (8017f1c <FLASH_SetErrorCode+0x5c>)
 8017ec2:	68d3      	ldr	r3, [r2, #12]
 8017ec4:	079b      	lsls	r3, r3, #30
 8017ec6:	d504      	bpl.n	8017ed2 <FLASH_SetErrorCode+0x12>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8017ec8:	4915      	ldr	r1, [pc, #84]	@ (8017f20 <FLASH_SetErrorCode+0x60>)
 8017eca:	698b      	ldr	r3, [r1, #24]
 8017ecc:	f043 0320 	orr.w	r3, r3, #32
 8017ed0:	618b      	str	r3, [r1, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8017ed2:	68d3      	ldr	r3, [r2, #12]
 8017ed4:	06d8      	lsls	r0, r3, #27
 8017ed6:	d504      	bpl.n	8017ee2 <FLASH_SetErrorCode+0x22>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8017ed8:	4a11      	ldr	r2, [pc, #68]	@ (8017f20 <FLASH_SetErrorCode+0x60>)
 8017eda:	6993      	ldr	r3, [r2, #24]
 8017edc:	f043 0310 	orr.w	r3, r3, #16
 8017ee0:	6193      	str	r3, [r2, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8017ee2:	4a0e      	ldr	r2, [pc, #56]	@ (8017f1c <FLASH_SetErrorCode+0x5c>)
 8017ee4:	68d3      	ldr	r3, [r2, #12]
 8017ee6:	0699      	lsls	r1, r3, #26
 8017ee8:	d504      	bpl.n	8017ef4 <FLASH_SetErrorCode+0x34>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8017eea:	490d      	ldr	r1, [pc, #52]	@ (8017f20 <FLASH_SetErrorCode+0x60>)
 8017eec:	698b      	ldr	r3, [r1, #24]
 8017eee:	f043 0308 	orr.w	r3, r3, #8
 8017ef2:	618b      	str	r3, [r1, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8017ef4:	68d3      	ldr	r3, [r2, #12]
 8017ef6:	065a      	lsls	r2, r3, #25
 8017ef8:	d504      	bpl.n	8017f04 <FLASH_SetErrorCode+0x44>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8017efa:	4a09      	ldr	r2, [pc, #36]	@ (8017f20 <FLASH_SetErrorCode+0x60>)
 8017efc:	6993      	ldr	r3, [r2, #24]
 8017efe:	f043 0304 	orr.w	r3, r3, #4
 8017f02:	6193      	str	r3, [r2, #24]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ERSERR) != RESET)
 8017f04:	4a05      	ldr	r2, [pc, #20]	@ (8017f1c <FLASH_SetErrorCode+0x5c>)
 8017f06:	68d3      	ldr	r3, [r2, #12]
 8017f08:	061b      	lsls	r3, r3, #24
 8017f0a:	d504      	bpl.n	8017f16 <FLASH_SetErrorCode+0x56>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_ERS;
 8017f0c:	4904      	ldr	r1, [pc, #16]	@ (8017f20 <FLASH_SetErrorCode+0x60>)
 8017f0e:	698b      	ldr	r3, [r1, #24]
 8017f10:	f043 0302 	orr.w	r3, r3, #2
 8017f14:	618b      	str	r3, [r1, #24]
   pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
  }  
#endif /* FLASH_OPTCR2_PCROP */
  
  /* Clear error programming flags */
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ALL_ERRORS);
 8017f16:	23f2      	movs	r3, #242	@ 0xf2
 8017f18:	60d3      	str	r3, [r2, #12]
}
 8017f1a:	4770      	bx	lr
 8017f1c:	40023c00 	.word	0x40023c00
 8017f20:	20001938 	.word	0x20001938

08017f24 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8017f24:	4b06      	ldr	r3, [pc, #24]	@ (8017f40 <HAL_FLASH_Unlock+0x1c>)
 8017f26:	691a      	ldr	r2, [r3, #16]
 8017f28:	2a00      	cmp	r2, #0
 8017f2a:	da07      	bge.n	8017f3c <HAL_FLASH_Unlock+0x18>
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8017f2c:	4a05      	ldr	r2, [pc, #20]	@ (8017f44 <HAL_FLASH_Unlock+0x20>)
 8017f2e:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8017f30:	f102 3288 	add.w	r2, r2, #2290649224	@ 0x88888888
 8017f34:	605a      	str	r2, [r3, #4]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8017f36:	6918      	ldr	r0, [r3, #16]
 8017f38:	0fc0      	lsrs	r0, r0, #31
 8017f3a:	4770      	bx	lr
  HAL_StatusTypeDef status = HAL_OK;
 8017f3c:	2000      	movs	r0, #0
}
 8017f3e:	4770      	bx	lr
 8017f40:	40023c00 	.word	0x40023c00
 8017f44:	45670123 	.word	0x45670123

08017f48 <HAL_FLASH_Lock>:
  FLASH->CR |= FLASH_CR_LOCK;
 8017f48:	4a03      	ldr	r2, [pc, #12]	@ (8017f58 <HAL_FLASH_Lock+0x10>)
}
 8017f4a:	2000      	movs	r0, #0
  FLASH->CR |= FLASH_CR_LOCK;
 8017f4c:	6913      	ldr	r3, [r2, #16]
 8017f4e:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8017f52:	6113      	str	r3, [r2, #16]
}
 8017f54:	4770      	bx	lr
 8017f56:	bf00      	nop
 8017f58:	40023c00 	.word	0x40023c00

08017f5c <FLASH_WaitForLastOperation>:
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8017f5c:	4b13      	ldr	r3, [pc, #76]	@ (8017fac <FLASH_WaitForLastOperation+0x50>)
 8017f5e:	2200      	movs	r2, #0
{ 
 8017f60:	b570      	push	{r4, r5, r6, lr}
 8017f62:	4605      	mov	r5, r0
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8017f64:	619a      	str	r2, [r3, #24]
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8017f66:	4c12      	ldr	r4, [pc, #72]	@ (8017fb0 <FLASH_WaitForLastOperation+0x54>)
  tickstart = HAL_GetTick();
 8017f68:	f7ff fea2 	bl	8017cb0 <HAL_GetTick>
 8017f6c:	4606      	mov	r6, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8017f6e:	68e3      	ldr	r3, [r4, #12]
 8017f70:	03da      	lsls	r2, r3, #15
 8017f72:	d407      	bmi.n	8017f84 <FLASH_WaitForLastOperation+0x28>
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_ALL_ERRORS) != RESET)
 8017f74:	68e3      	ldr	r3, [r4, #12]
 8017f76:	f013 0ff2 	tst.w	r3, #242	@ 0xf2
 8017f7a:	d00e      	beq.n	8017f9a <FLASH_WaitForLastOperation+0x3e>
    FLASH_SetErrorCode();
 8017f7c:	f7ff ffa0 	bl	8017ec0 <FLASH_SetErrorCode>
    return HAL_ERROR;
 8017f80:	2001      	movs	r0, #1
 8017f82:	e003      	b.n	8017f8c <FLASH_WaitForLastOperation+0x30>
    if(Timeout != HAL_MAX_DELAY)
 8017f84:	1c69      	adds	r1, r5, #1
 8017f86:	d0f2      	beq.n	8017f6e <FLASH_WaitForLastOperation+0x12>
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8017f88:	b90d      	cbnz	r5, 8017f8e <FLASH_WaitForLastOperation+0x32>
        return HAL_TIMEOUT;
 8017f8a:	2003      	movs	r0, #3
}  
 8017f8c:	bd70      	pop	{r4, r5, r6, pc}
      if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
 8017f8e:	f7ff fe8f 	bl	8017cb0 <HAL_GetTick>
 8017f92:	1b80      	subs	r0, r0, r6
 8017f94:	42a8      	cmp	r0, r5
 8017f96:	d9ea      	bls.n	8017f6e <FLASH_WaitForLastOperation+0x12>
 8017f98:	e7f7      	b.n	8017f8a <FLASH_WaitForLastOperation+0x2e>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 8017f9a:	68e3      	ldr	r3, [r4, #12]
 8017f9c:	07db      	lsls	r3, r3, #31
 8017f9e:	d401      	bmi.n	8017fa4 <FLASH_WaitForLastOperation+0x48>
  return HAL_OK;
 8017fa0:	2000      	movs	r0, #0
 8017fa2:	e7f3      	b.n	8017f8c <FLASH_WaitForLastOperation+0x30>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8017fa4:	2301      	movs	r3, #1
 8017fa6:	60e3      	str	r3, [r4, #12]
 8017fa8:	e7fa      	b.n	8017fa0 <FLASH_WaitForLastOperation+0x44>
 8017faa:	bf00      	nop
 8017fac:	20001938 	.word	0x20001938
 8017fb0:	40023c00 	.word	0x40023c00

08017fb4 <HAL_FLASH_Program>:
{
 8017fb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 8017fb8:	4e1b      	ldr	r6, [pc, #108]	@ (8018028 <HAL_FLASH_Program+0x74>)
{
 8017fba:	4698      	mov	r8, r3
 8017fbc:	4607      	mov	r7, r0
 8017fbe:	460c      	mov	r4, r1
  __HAL_LOCK(&pFlash);
 8017fc0:	7d33      	ldrb	r3, [r6, #20]
{
 8017fc2:	4615      	mov	r5, r2
  __HAL_LOCK(&pFlash);
 8017fc4:	2b01      	cmp	r3, #1
 8017fc6:	d02d      	beq.n	8018024 <HAL_FLASH_Program+0x70>
 8017fc8:	2301      	movs	r3, #1
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8017fca:	f24c 3050 	movw	r0, #50000	@ 0xc350
  __HAL_LOCK(&pFlash);
 8017fce:	7533      	strb	r3, [r6, #20]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8017fd0:	f7ff ffc4 	bl	8017f5c <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8017fd4:	b990      	cbnz	r0, 8017ffc <HAL_FLASH_Program+0x48>
    switch(TypeProgram)
 8017fd6:	2f03      	cmp	r7, #3
 8017fd8:	d807      	bhi.n	8017fea <HAL_FLASH_Program+0x36>
 8017fda:	e8df f007 	tbb	[pc, r7]
 8017fde:	1302      	.short	0x1302
 8017fe0:	1d18      	.short	0x1d18
        FLASH_Program_Byte(Address, (uint8_t) Data);
 8017fe2:	b2e9      	uxtb	r1, r5
 8017fe4:	4620      	mov	r0, r4
 8017fe6:	f7ff ff59 	bl	8017e9c <FLASH_Program_Byte>
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8017fea:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8017fee:	f7ff ffb5 	bl	8017f5c <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);
 8017ff2:	4a0e      	ldr	r2, [pc, #56]	@ (801802c <HAL_FLASH_Program+0x78>)
 8017ff4:	6913      	ldr	r3, [r2, #16]
 8017ff6:	f023 0301 	bic.w	r3, r3, #1
 8017ffa:	6113      	str	r3, [r2, #16]
  __HAL_UNLOCK(&pFlash);
 8017ffc:	2300      	movs	r3, #0
 8017ffe:	7533      	strb	r3, [r6, #20]
}
 8018000:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        FLASH_Program_HalfWord(Address, (uint16_t) Data);
 8018004:	b2a9      	uxth	r1, r5
 8018006:	4620      	mov	r0, r4
 8018008:	f7ff ff34 	bl	8017e74 <FLASH_Program_HalfWord>
        break;
 801800c:	e7ed      	b.n	8017fea <HAL_FLASH_Program+0x36>
        FLASH_Program_Word(Address, (uint32_t) Data);
 801800e:	4629      	mov	r1, r5
 8018010:	4620      	mov	r0, r4
 8018012:	f7ff ff1b 	bl	8017e4c <FLASH_Program_Word>
        break;
 8018016:	e7e8      	b.n	8017fea <HAL_FLASH_Program+0x36>
        FLASH_Program_DoubleWord(Address, Data);
 8018018:	462a      	mov	r2, r5
 801801a:	4643      	mov	r3, r8
 801801c:	4620      	mov	r0, r4
 801801e:	f7ff fefd 	bl	8017e1c <FLASH_Program_DoubleWord>
        break;
 8018022:	e7e2      	b.n	8017fea <HAL_FLASH_Program+0x36>
  __HAL_LOCK(&pFlash);
 8018024:	2002      	movs	r0, #2
 8018026:	e7eb      	b.n	8018000 <HAL_FLASH_Program+0x4c>
 8018028:	20001938 	.word	0x20001938
 801802c:	40023c00 	.word	0x40023c00

08018030 <FLASH_MassErase>:
{
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));

  /* if the previous operation is completed, proceed to erase all sectors */
  FLASH->CR &= CR_PSIZE_MASK;
 8018030:	4b08      	ldr	r3, [pc, #32]	@ (8018054 <FLASH_MassErase+0x24>)
 8018032:	691a      	ldr	r2, [r3, #16]
 8018034:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8018038:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_MER;
 801803a:	691a      	ldr	r2, [r3, #16]
 801803c:	f042 0204 	orr.w	r2, r2, #4
 8018040:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange <<8);
 8018042:	691a      	ldr	r2, [r3, #16]
 8018044:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8018048:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 801804c:	611a      	str	r2, [r3, #16]
 801804e:	f3bf 8f4f 	dsb	sy
  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
 8018052:	4770      	bx	lr
 8018054:	40023c00 	.word	0x40023c00

08018058 <FLASH_Erase_Sector>:
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
  }

  /* If the previous operation is completed, proceed to erase the sector */
  FLASH->CR &= CR_PSIZE_MASK;
 8018058:	4b0e      	ldr	r3, [pc, #56]	@ (8018094 <FLASH_Erase_Sector+0x3c>)
 801805a:	2902      	cmp	r1, #2
 801805c:	691a      	ldr	r2, [r3, #16]
 801805e:	bf94      	ite	ls
 8018060:	0209      	lslls	r1, r1, #8
{
 8018062:	f44f 7140 	movhi.w	r1, #768	@ 0x300
  FLASH->CR &= CR_PSIZE_MASK;
 8018066:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 801806a:	611a      	str	r2, [r3, #16]
  FLASH->CR |= tmp_psize;
 801806c:	691a      	ldr	r2, [r3, #16]
 801806e:	430a      	orrs	r2, r1
 8018070:	611a      	str	r2, [r3, #16]
  FLASH->CR &= SECTOR_MASK;
 8018072:	691a      	ldr	r2, [r3, #16]
 8018074:	f022 02f8 	bic.w	r2, r2, #248	@ 0xf8
 8018078:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 801807a:	691a      	ldr	r2, [r3, #16]
 801807c:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 8018080:	f042 0202 	orr.w	r2, r2, #2
 8018084:	611a      	str	r2, [r3, #16]
  FLASH->CR |= FLASH_CR_STRT;
 8018086:	691a      	ldr	r2, [r3, #16]
 8018088:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 801808c:	611a      	str	r2, [r3, #16]
 801808e:	f3bf 8f4f 	dsb	sy
  
  /* Data synchronous Barrier (DSB) Just after the write operation
     This will force the CPU to respect the sequence of instruction (no optimization).*/
  __DSB();
}
 8018092:	4770      	bx	lr
 8018094:	40023c00 	.word	0x40023c00

08018098 <HAL_FLASHEx_Erase>:
{
 8018098:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(&pFlash);
 801809c:	4f22      	ldr	r7, [pc, #136]	@ (8018128 <HAL_FLASHEx_Erase+0x90>)
{
 801809e:	4605      	mov	r5, r0
 80180a0:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 80180a2:	7d3b      	ldrb	r3, [r7, #20]
 80180a4:	2b01      	cmp	r3, #1
 80180a6:	d03d      	beq.n	8018124 <HAL_FLASHEx_Erase+0x8c>
 80180a8:	2301      	movs	r3, #1
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80180aa:	f24c 3050 	movw	r0, #50000	@ 0xc350
  __HAL_LOCK(&pFlash);
 80180ae:	753b      	strb	r3, [r7, #20]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80180b0:	f7ff ff54 	bl	8017f5c <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 80180b4:	4604      	mov	r4, r0
 80180b6:	b998      	cbnz	r0, 80180e0 <HAL_FLASHEx_Erase+0x48>
    *SectorError = 0xFFFFFFFFU;
 80180b8:	f04f 33ff 	mov.w	r3, #4294967295
 80180bc:	f8c8 3000 	str.w	r3, [r8]
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 80180c0:	682b      	ldr	r3, [r5, #0]
 80180c2:	2b01      	cmp	r3, #1
 80180c4:	d111      	bne.n	80180ea <HAL_FLASHEx_Erase+0x52>
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange);      
 80180c6:	7b28      	ldrb	r0, [r5, #12]
 80180c8:	f7ff ffb2 	bl	8018030 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80180cc:	f24c 3050 	movw	r0, #50000	@ 0xc350
 80180d0:	f7ff ff44 	bl	8017f5c <FLASH_WaitForLastOperation>
      FLASH->CR &= (~FLASH_MER_BIT);
 80180d4:	4a15      	ldr	r2, [pc, #84]	@ (801812c <HAL_FLASHEx_Erase+0x94>)
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80180d6:	4604      	mov	r4, r0
      FLASH->CR &= (~FLASH_MER_BIT);
 80180d8:	6913      	ldr	r3, [r2, #16]
 80180da:	f023 0304 	bic.w	r3, r3, #4
 80180de:	6113      	str	r3, [r2, #16]
  __HAL_UNLOCK(&pFlash);
 80180e0:	2300      	movs	r3, #0
 80180e2:	753b      	strb	r3, [r7, #20]
}
 80180e4:	4620      	mov	r0, r4
 80180e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 80180ea:	686e      	ldr	r6, [r5, #4]
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB)); 
 80180ec:	f8df 903c 	ldr.w	r9, [pc, #60]	@ 801812c <HAL_FLASHEx_Erase+0x94>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 80180f0:	e9d5 2301 	ldrd	r2, r3, [r5, #4]
 80180f4:	4413      	add	r3, r2
 80180f6:	42b3      	cmp	r3, r6
 80180f8:	d9f2      	bls.n	80180e0 <HAL_FLASHEx_Erase+0x48>
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 80180fa:	7b29      	ldrb	r1, [r5, #12]
 80180fc:	4630      	mov	r0, r6
 80180fe:	f7ff ffab 	bl	8018058 <FLASH_Erase_Sector>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8018102:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8018106:	f7ff ff29 	bl	8017f5c <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB)); 
 801810a:	f8d9 3010 	ldr.w	r3, [r9, #16]
 801810e:	f023 037a 	bic.w	r3, r3, #122	@ 0x7a
 8018112:	f8c9 3010 	str.w	r3, [r9, #16]
        if(status != HAL_OK) 
 8018116:	b118      	cbz	r0, 8018120 <HAL_FLASHEx_Erase+0x88>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8018118:	4604      	mov	r4, r0
          *SectorError = index;
 801811a:	f8c8 6000 	str.w	r6, [r8]
          break;
 801811e:	e7df      	b.n	80180e0 <HAL_FLASHEx_Erase+0x48>
      for(index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8018120:	3601      	adds	r6, #1
 8018122:	e7e5      	b.n	80180f0 <HAL_FLASHEx_Erase+0x58>
  __HAL_LOCK(&pFlash);
 8018124:	2402      	movs	r4, #2
 8018126:	e7dd      	b.n	80180e4 <HAL_FLASHEx_Erase+0x4c>
 8018128:	20001938 	.word	0x20001938
 801812c:	40023c00 	.word	0x40023c00

08018130 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8018130:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for (position = 0; position < GPIO_NUMBER; position++)
 8018134:	2200      	movs	r2, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8018136:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 80182ec <HAL_GPIO_Init+0x1bc>
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 801813a:	4c6a      	ldr	r4, [pc, #424]	@ (80182e4 <HAL_GPIO_Init+0x1b4>)
    ioposition = ((uint32_t)0x01) << position;
 801813c:	2301      	movs	r3, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 801813e:	680e      	ldr	r6, [r1, #0]
    ioposition = ((uint32_t)0x01) << position;
 8018140:	fa03 f502 	lsl.w	r5, r3, r2
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8018144:	ea05 0306 	and.w	r3, r5, r6
    if (iocurrent == ioposition)
 8018148:	43b5      	bics	r5, r6
 801814a:	f040 80b1 	bne.w	80182b0 <HAL_GPIO_Init+0x180>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 801814e:	684e      	ldr	r6, [r1, #4]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8018150:	2703      	movs	r7, #3
 8018152:	ea4f 0c42 	mov.w	ip, r2, lsl #1
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8018156:	f006 0503 	and.w	r5, r6, #3
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 801815a:	fa07 f90c 	lsl.w	r9, r7, ip
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 801815e:	1e6f      	subs	r7, r5, #1
 8018160:	2f01      	cmp	r7, #1
 8018162:	d834      	bhi.n	80181ce <HAL_GPIO_Init+0x9e>
        temp = GPIOx->OSPEEDR;
 8018164:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8018166:	ea27 0e09 	bic.w	lr, r7, r9
        temp |= (GPIO_Init->Speed << (position * 2));
 801816a:	68cf      	ldr	r7, [r1, #12]
 801816c:	fa07 f70c 	lsl.w	r7, r7, ip
 8018170:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OSPEEDR = temp;
 8018174:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8018176:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8018178:	ea27 0e03 	bic.w	lr, r7, r3
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 801817c:	f3c6 1700 	ubfx	r7, r6, #4, #1
 8018180:	4097      	lsls	r7, r2
 8018182:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8018186:	6047      	str	r7, [r0, #4]
        temp = GPIOx->PUPDR;
 8018188:	68c7      	ldr	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 801818a:	2d02      	cmp	r5, #2
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 801818c:	ea27 0e09 	bic.w	lr, r7, r9
        temp |= ((GPIO_Init->Pull) << (position * 2));
 8018190:	688f      	ldr	r7, [r1, #8]
 8018192:	fa07 f70c 	lsl.w	r7, r7, ip
 8018196:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->PUPDR = temp;
 801819a:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 801819c:	d119      	bne.n	80181d2 <HAL_GPIO_Init+0xa2>
        temp = GPIOx->AFR[position >> 3];
 801819e:	ea4f 0ed2 	mov.w	lr, r2, lsr #3
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80181a2:	f002 0a07 	and.w	sl, r2, #7
 80181a6:	f04f 0b0f 	mov.w	fp, #15
 80181aa:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
 80181ae:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
        temp = GPIOx->AFR[position >> 3];
 80181b2:	f8de 7020 	ldr.w	r7, [lr, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80181b6:	fa0b fb0a 	lsl.w	fp, fp, sl
 80181ba:	ea27 0b0b 	bic.w	fp, r7, fp
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 80181be:	690f      	ldr	r7, [r1, #16]
 80181c0:	fa07 f70a 	lsl.w	r7, r7, sl
 80181c4:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->AFR[position >> 3] = temp;
 80181c8:	f8ce 7020 	str.w	r7, [lr, #32]
 80181cc:	e001      	b.n	80181d2 <HAL_GPIO_Init+0xa2>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80181ce:	2d03      	cmp	r5, #3
 80181d0:	d1da      	bne.n	8018188 <HAL_GPIO_Init+0x58>
      temp = GPIOx->MODER;
 80181d2:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80181d4:	fa05 f50c 	lsl.w	r5, r5, ip
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80181d8:	f416 3f40 	tst.w	r6, #196608	@ 0x30000
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 80181dc:	ea27 0709 	bic.w	r7, r7, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 80181e0:	ea45 0507 	orr.w	r5, r5, r7
      GPIOx->MODER = temp;
 80181e4:	6005      	str	r5, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 80181e6:	d063      	beq.n	80182b0 <HAL_GPIO_Init+0x180>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80181e8:	f8d8 5044 	ldr.w	r5, [r8, #68]	@ 0x44
 80181ec:	f022 0703 	bic.w	r7, r2, #3
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 80181f0:	f002 0c03 	and.w	ip, r2, #3
 80181f4:	f04f 0e0f 	mov.w	lr, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80181f8:	f445 4580 	orr.w	r5, r5, #16384	@ 0x4000
 80181fc:	f107 4780 	add.w	r7, r7, #1073741824	@ 0x40000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8018200:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8018204:	f8c8 5044 	str.w	r5, [r8, #68]	@ 0x44
 8018208:	f507 379c 	add.w	r7, r7, #79872	@ 0x13800
 801820c:	f8d8 5044 	ldr.w	r5, [r8, #68]	@ 0x44
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8018210:	fa0e fe0c 	lsl.w	lr, lr, ip
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8018214:	f405 4580 	and.w	r5, r5, #16384	@ 0x4000
 8018218:	9501      	str	r5, [sp, #4]
 801821a:	9d01      	ldr	r5, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2];
 801821c:	68bd      	ldr	r5, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 801821e:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8018222:	4d31      	ldr	r5, [pc, #196]	@ (80182e8 <HAL_GPIO_Init+0x1b8>)
 8018224:	42a8      	cmp	r0, r5
 8018226:	d04a      	beq.n	80182be <HAL_GPIO_Init+0x18e>
 8018228:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 801822c:	42a8      	cmp	r0, r5
 801822e:	d048      	beq.n	80182c2 <HAL_GPIO_Init+0x192>
 8018230:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8018234:	42a8      	cmp	r0, r5
 8018236:	d046      	beq.n	80182c6 <HAL_GPIO_Init+0x196>
 8018238:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 801823c:	42a8      	cmp	r0, r5
 801823e:	d044      	beq.n	80182ca <HAL_GPIO_Init+0x19a>
 8018240:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8018244:	42a8      	cmp	r0, r5
 8018246:	d042      	beq.n	80182ce <HAL_GPIO_Init+0x19e>
 8018248:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 801824c:	42a8      	cmp	r0, r5
 801824e:	d040      	beq.n	80182d2 <HAL_GPIO_Init+0x1a2>
 8018250:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8018254:	42a8      	cmp	r0, r5
 8018256:	d03e      	beq.n	80182d6 <HAL_GPIO_Init+0x1a6>
 8018258:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 801825c:	42a8      	cmp	r0, r5
 801825e:	d03c      	beq.n	80182da <HAL_GPIO_Init+0x1aa>
 8018260:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8018264:	42a8      	cmp	r0, r5
 8018266:	d03a      	beq.n	80182de <HAL_GPIO_Init+0x1ae>
 8018268:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 801826c:	42a8      	cmp	r0, r5
 801826e:	bf14      	ite	ne
 8018270:	250a      	movne	r5, #10
 8018272:	2509      	moveq	r5, #9
 8018274:	fa05 f50c 	lsl.w	r5, r5, ip
 8018278:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 801827c:	60bd      	str	r5, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 801827e:	02f7      	lsls	r7, r6, #11
        temp = EXTI->RTSR;
 8018280:	68a5      	ldr	r5, [r4, #8]
        temp &= ~((uint32_t)iocurrent);
 8018282:	bf54      	ite	pl
 8018284:	439d      	bicpl	r5, r3
        {
          temp |= iocurrent;
 8018286:	431d      	orrmi	r5, r3
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 8018288:	02b7      	lsls	r7, r6, #10
        EXTI->RTSR = temp;
 801828a:	60a5      	str	r5, [r4, #8]
        temp = EXTI->FTSR;
 801828c:	68e5      	ldr	r5, [r4, #12]
        temp &= ~((uint32_t)iocurrent);
 801828e:	bf54      	ite	pl
 8018290:	439d      	bicpl	r5, r3
        {
          temp |= iocurrent;
 8018292:	431d      	orrmi	r5, r3
        }
        EXTI->FTSR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 8018294:	03b7      	lsls	r7, r6, #14
        EXTI->FTSR = temp;
 8018296:	60e5      	str	r5, [r4, #12]
        temp = EXTI->EMR;
 8018298:	6865      	ldr	r5, [r4, #4]
        temp &= ~((uint32_t)iocurrent);
 801829a:	bf54      	ite	pl
 801829c:	439d      	bicpl	r5, r3
        {
          temp |= iocurrent;
 801829e:	431d      	orrmi	r5, r3
        EXTI->EMR = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 80182a0:	03f6      	lsls	r6, r6, #15
        EXTI->EMR = temp;
 80182a2:	6065      	str	r5, [r4, #4]
        temp = EXTI->IMR;
 80182a4:	6825      	ldr	r5, [r4, #0]
        temp &= ~((uint32_t)iocurrent);
 80182a6:	bf54      	ite	pl
 80182a8:	ea25 0303 	bicpl.w	r3, r5, r3
        {
          temp |= iocurrent;
 80182ac:	432b      	orrmi	r3, r5
        }
        EXTI->IMR = temp;
 80182ae:	6023      	str	r3, [r4, #0]
  for (position = 0; position < GPIO_NUMBER; position++)
 80182b0:	3201      	adds	r2, #1
 80182b2:	2a10      	cmp	r2, #16
 80182b4:	f47f af42 	bne.w	801813c <HAL_GPIO_Init+0xc>
      }
    }
  }
}
 80182b8:	b003      	add	sp, #12
 80182ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 80182be:	2500      	movs	r5, #0
 80182c0:	e7d8      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182c2:	2501      	movs	r5, #1
 80182c4:	e7d6      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182c6:	2502      	movs	r5, #2
 80182c8:	e7d4      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182ca:	2503      	movs	r5, #3
 80182cc:	e7d2      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182ce:	2504      	movs	r5, #4
 80182d0:	e7d0      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182d2:	2505      	movs	r5, #5
 80182d4:	e7ce      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182d6:	2506      	movs	r5, #6
 80182d8:	e7cc      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182da:	2507      	movs	r5, #7
 80182dc:	e7ca      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182de:	2508      	movs	r5, #8
 80182e0:	e7c8      	b.n	8018274 <HAL_GPIO_Init+0x144>
 80182e2:	bf00      	nop
 80182e4:	40013c00 	.word	0x40013c00
 80182e8:	40020000 	.word	0x40020000
 80182ec:	40023800 	.word	0x40023800

080182f0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80182f0:	b10a      	cbz	r2, 80182f6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 80182f2:	6181      	str	r1, [r0, #24]
  }
}
 80182f4:	4770      	bx	lr
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 80182f6:	0409      	lsls	r1, r1, #16
 80182f8:	e7fb      	b.n	80182f2 <HAL_GPIO_WritePin+0x2>

080182fa <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 80182fa:	6943      	ldr	r3, [r0, #20]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 80182fc:	ea01 0203 	and.w	r2, r1, r3
 8018300:	ea21 0103 	bic.w	r1, r1, r3
 8018304:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8018308:	6181      	str	r1, [r0, #24]
}
 801830a:	4770      	bx	lr

0801830c <HAL_PWR_EnableBkUpAccess>:
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 801830c:	4a02      	ldr	r2, [pc, #8]	@ (8018318 <HAL_PWR_EnableBkUpAccess+0xc>)
 801830e:	6813      	ldr	r3, [r2, #0]
 8018310:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8018314:	6013      	str	r3, [r2, #0]
}
 8018316:	4770      	bx	lr
 8018318:	40007000 	.word	0x40007000

0801831c <HAL_PWREx_DisableBkUpReg>:
/**
  * @brief Disables the Backup Regulator.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
{
 801831c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0;
  
  /* Disable Backup regulator */
  PWR->CSR1 &= (uint32_t)~((uint32_t)PWR_CSR1_BRE);
 801831e:	4c0c      	ldr	r4, [pc, #48]	@ (8018350 <HAL_PWREx_DisableBkUpReg+0x34>)
 8018320:	6863      	ldr	r3, [r4, #4]
 8018322:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8018326:	6063      	str	r3, [r4, #4]
  
  /* Workaround for the following hardware bug: */
  /* Id 19: PWR : No STANDBY wake-up when Back-up RAM enabled (ref. Errata Sheet p23) */
  PWR->CSR1 |= PWR_CSR1_EIWUP;
 8018328:	6863      	ldr	r3, [r4, #4]
 801832a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 801832e:	6063      	str	r3, [r4, #4]

  /* Get tick */
  tickstart = HAL_GetTick();
 8018330:	f7ff fcbe 	bl	8017cb0 <HAL_GetTick>
 8018334:	4605      	mov	r5, r0

  /* Wait till Backup regulator ready flag is set */  
  while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
 8018336:	6860      	ldr	r0, [r4, #4]
 8018338:	f010 0008 	ands.w	r0, r0, #8
 801833c:	d100      	bne.n	8018340 <HAL_PWREx_DisableBkUpReg+0x24>
    {
      return HAL_TIMEOUT;
    } 
  }
  return HAL_OK;
}
 801833e:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
 8018340:	f7ff fcb6 	bl	8017cb0 <HAL_GetTick>
 8018344:	1b40      	subs	r0, r0, r5
 8018346:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 801834a:	d9f4      	bls.n	8018336 <HAL_PWREx_DisableBkUpReg+0x1a>
      return HAL_TIMEOUT;
 801834c:	2003      	movs	r0, #3
 801834e:	e7f6      	b.n	801833e <HAL_PWREx_DisableBkUpReg+0x22>
 8018350:	40007000 	.word	0x40007000

08018354 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(const RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8018354:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8018358:	4604      	mov	r4, r0
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 801835a:	2800      	cmp	r0, #0
 801835c:	d028      	beq.n	80183b0 <HAL_RCC_OscConfig+0x5c>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 801835e:	6803      	ldr	r3, [r0, #0]
 8018360:	07de      	lsls	r6, r3, #31
 8018362:	d410      	bmi.n	8018386 <HAL_RCC_OscConfig+0x32>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8018364:	6823      	ldr	r3, [r4, #0]
 8018366:	079d      	lsls	r5, r3, #30
 8018368:	d461      	bmi.n	801842e <HAL_RCC_OscConfig+0xda>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 801836a:	6823      	ldr	r3, [r4, #0]
 801836c:	0719      	lsls	r1, r3, #28
 801836e:	f100 80a6 	bmi.w	80184be <HAL_RCC_OscConfig+0x16a>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8018372:	6823      	ldr	r3, [r4, #0]
 8018374:	075a      	lsls	r2, r3, #29
 8018376:	f100 80c7 	bmi.w	8018508 <HAL_RCC_OscConfig+0x1b4>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 801837a:	69a2      	ldr	r2, [r4, #24]
 801837c:	2a00      	cmp	r2, #0
 801837e:	f040 8133 	bne.w	80185e8 <HAL_RCC_OscConfig+0x294>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 8018382:	2000      	movs	r0, #0
 8018384:	e02c      	b.n	80183e0 <HAL_RCC_OscConfig+0x8c>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 8018386:	4b96      	ldr	r3, [pc, #600]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 8018388:	689a      	ldr	r2, [r3, #8]
 801838a:	f002 020c 	and.w	r2, r2, #12
 801838e:	2a04      	cmp	r2, #4
 8018390:	d007      	beq.n	80183a2 <HAL_RCC_OscConfig+0x4e>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8018392:	689a      	ldr	r2, [r3, #8]
 8018394:	f002 020c 	and.w	r2, r2, #12
 8018398:	2a08      	cmp	r2, #8
 801839a:	d10b      	bne.n	80183b4 <HAL_RCC_OscConfig+0x60>
 801839c:	685b      	ldr	r3, [r3, #4]
 801839e:	0259      	lsls	r1, r3, #9
 80183a0:	d508      	bpl.n	80183b4 <HAL_RCC_OscConfig+0x60>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80183a2:	4b8f      	ldr	r3, [pc, #572]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 80183a4:	681b      	ldr	r3, [r3, #0]
 80183a6:	039a      	lsls	r2, r3, #14
 80183a8:	d5dc      	bpl.n	8018364 <HAL_RCC_OscConfig+0x10>
 80183aa:	6863      	ldr	r3, [r4, #4]
 80183ac:	2b00      	cmp	r3, #0
 80183ae:	d1d9      	bne.n	8018364 <HAL_RCC_OscConfig+0x10>
    return HAL_ERROR;
 80183b0:	2001      	movs	r0, #1
 80183b2:	e015      	b.n	80183e0 <HAL_RCC_OscConfig+0x8c>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80183b4:	6863      	ldr	r3, [r4, #4]
 80183b6:	4d8a      	ldr	r5, [pc, #552]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 80183b8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80183bc:	d113      	bne.n	80183e6 <HAL_RCC_OscConfig+0x92>
 80183be:	682b      	ldr	r3, [r5, #0]
 80183c0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80183c4:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80183c6:	f7ff fc73 	bl	8017cb0 <HAL_GetTick>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80183ca:	4d85      	ldr	r5, [pc, #532]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
        tickstart = HAL_GetTick();
 80183cc:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80183ce:	682b      	ldr	r3, [r5, #0]
 80183d0:	039b      	lsls	r3, r3, #14
 80183d2:	d4c7      	bmi.n	8018364 <HAL_RCC_OscConfig+0x10>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80183d4:	f7ff fc6c 	bl	8017cb0 <HAL_GetTick>
 80183d8:	1b80      	subs	r0, r0, r6
 80183da:	2864      	cmp	r0, #100	@ 0x64
 80183dc:	d9f7      	bls.n	80183ce <HAL_RCC_OscConfig+0x7a>
            return HAL_TIMEOUT;
 80183de:	2003      	movs	r0, #3
}
 80183e0:	b002      	add	sp, #8
 80183e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80183e6:	b99b      	cbnz	r3, 8018410 <HAL_RCC_OscConfig+0xbc>
 80183e8:	682b      	ldr	r3, [r5, #0]
 80183ea:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80183ee:	602b      	str	r3, [r5, #0]
 80183f0:	682b      	ldr	r3, [r5, #0]
 80183f2:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 80183f6:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80183f8:	f7ff fc5a 	bl	8017cb0 <HAL_GetTick>
 80183fc:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80183fe:	682b      	ldr	r3, [r5, #0]
 8018400:	039f      	lsls	r7, r3, #14
 8018402:	d5af      	bpl.n	8018364 <HAL_RCC_OscConfig+0x10>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8018404:	f7ff fc54 	bl	8017cb0 <HAL_GetTick>
 8018408:	1b80      	subs	r0, r0, r6
 801840a:	2864      	cmp	r0, #100	@ 0x64
 801840c:	d9f7      	bls.n	80183fe <HAL_RCC_OscConfig+0xaa>
 801840e:	e7e6      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8018410:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8018414:	682b      	ldr	r3, [r5, #0]
 8018416:	d103      	bne.n	8018420 <HAL_RCC_OscConfig+0xcc>
 8018418:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 801841c:	602b      	str	r3, [r5, #0]
 801841e:	e7ce      	b.n	80183be <HAL_RCC_OscConfig+0x6a>
 8018420:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8018424:	602b      	str	r3, [r5, #0]
 8018426:	682b      	ldr	r3, [r5, #0]
 8018428:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 801842c:	e7ca      	b.n	80183c4 <HAL_RCC_OscConfig+0x70>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 801842e:	4b6c      	ldr	r3, [pc, #432]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 8018430:	689a      	ldr	r2, [r3, #8]
 8018432:	f012 0f0c 	tst.w	r2, #12
 8018436:	d007      	beq.n	8018448 <HAL_RCC_OscConfig+0xf4>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8018438:	689a      	ldr	r2, [r3, #8]
 801843a:	f002 020c 	and.w	r2, r2, #12
 801843e:	2a08      	cmp	r2, #8
 8018440:	d111      	bne.n	8018466 <HAL_RCC_OscConfig+0x112>
 8018442:	685b      	ldr	r3, [r3, #4]
 8018444:	025d      	lsls	r5, r3, #9
 8018446:	d40e      	bmi.n	8018466 <HAL_RCC_OscConfig+0x112>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8018448:	4a65      	ldr	r2, [pc, #404]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 801844a:	6813      	ldr	r3, [r2, #0]
 801844c:	0799      	lsls	r1, r3, #30
 801844e:	d502      	bpl.n	8018456 <HAL_RCC_OscConfig+0x102>
 8018450:	68e3      	ldr	r3, [r4, #12]
 8018452:	2b01      	cmp	r3, #1
 8018454:	d1ac      	bne.n	80183b0 <HAL_RCC_OscConfig+0x5c>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8018456:	6813      	ldr	r3, [r2, #0]
 8018458:	6921      	ldr	r1, [r4, #16]
 801845a:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 801845e:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8018462:	6013      	str	r3, [r2, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8018464:	e781      	b.n	801836a <HAL_RCC_OscConfig+0x16>
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8018466:	68e3      	ldr	r3, [r4, #12]
 8018468:	4d5d      	ldr	r5, [pc, #372]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 801846a:	b1bb      	cbz	r3, 801849c <HAL_RCC_OscConfig+0x148>
        __HAL_RCC_HSI_ENABLE();
 801846c:	682b      	ldr	r3, [r5, #0]
 801846e:	f043 0301 	orr.w	r3, r3, #1
 8018472:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8018474:	f7ff fc1c 	bl	8017cb0 <HAL_GetTick>
 8018478:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 801847a:	682b      	ldr	r3, [r5, #0]
 801847c:	079b      	lsls	r3, r3, #30
 801847e:	d507      	bpl.n	8018490 <HAL_RCC_OscConfig+0x13c>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8018480:	682b      	ldr	r3, [r5, #0]
 8018482:	6922      	ldr	r2, [r4, #16]
 8018484:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8018488:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 801848c:	602b      	str	r3, [r5, #0]
 801848e:	e76c      	b.n	801836a <HAL_RCC_OscConfig+0x16>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8018490:	f7ff fc0e 	bl	8017cb0 <HAL_GetTick>
 8018494:	1b80      	subs	r0, r0, r6
 8018496:	2802      	cmp	r0, #2
 8018498:	d9ef      	bls.n	801847a <HAL_RCC_OscConfig+0x126>
 801849a:	e7a0      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
        __HAL_RCC_HSI_DISABLE();
 801849c:	682b      	ldr	r3, [r5, #0]
 801849e:	f023 0301 	bic.w	r3, r3, #1
 80184a2:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80184a4:	f7ff fc04 	bl	8017cb0 <HAL_GetTick>
 80184a8:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80184aa:	682b      	ldr	r3, [r5, #0]
 80184ac:	079f      	lsls	r7, r3, #30
 80184ae:	f57f af5c 	bpl.w	801836a <HAL_RCC_OscConfig+0x16>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80184b2:	f7ff fbfd 	bl	8017cb0 <HAL_GetTick>
 80184b6:	1b80      	subs	r0, r0, r6
 80184b8:	2802      	cmp	r0, #2
 80184ba:	d9f6      	bls.n	80184aa <HAL_RCC_OscConfig+0x156>
 80184bc:	e78f      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 80184be:	6963      	ldr	r3, [r4, #20]
 80184c0:	4d47      	ldr	r5, [pc, #284]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 80184c2:	b183      	cbz	r3, 80184e6 <HAL_RCC_OscConfig+0x192>
      __HAL_RCC_LSI_ENABLE();
 80184c4:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 80184c6:	f043 0301 	orr.w	r3, r3, #1
 80184ca:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
 80184cc:	f7ff fbf0 	bl	8017cb0 <HAL_GetTick>
 80184d0:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80184d2:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 80184d4:	079b      	lsls	r3, r3, #30
 80184d6:	f53f af4c 	bmi.w	8018372 <HAL_RCC_OscConfig+0x1e>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80184da:	f7ff fbe9 	bl	8017cb0 <HAL_GetTick>
 80184de:	1b80      	subs	r0, r0, r6
 80184e0:	2802      	cmp	r0, #2
 80184e2:	d9f6      	bls.n	80184d2 <HAL_RCC_OscConfig+0x17e>
 80184e4:	e77b      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
      __HAL_RCC_LSI_DISABLE();
 80184e6:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 80184e8:	f023 0301 	bic.w	r3, r3, #1
 80184ec:	676b      	str	r3, [r5, #116]	@ 0x74
      tickstart = HAL_GetTick();
 80184ee:	f7ff fbdf 	bl	8017cb0 <HAL_GetTick>
 80184f2:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80184f4:	6f6b      	ldr	r3, [r5, #116]	@ 0x74
 80184f6:	079f      	lsls	r7, r3, #30
 80184f8:	f57f af3b 	bpl.w	8018372 <HAL_RCC_OscConfig+0x1e>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80184fc:	f7ff fbd8 	bl	8017cb0 <HAL_GetTick>
 8018500:	1b80      	subs	r0, r0, r6
 8018502:	2802      	cmp	r0, #2
 8018504:	d9f6      	bls.n	80184f4 <HAL_RCC_OscConfig+0x1a0>
 8018506:	e76a      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8018508:	4b35      	ldr	r3, [pc, #212]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 801850a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801850c:	00d5      	lsls	r5, r2, #3
 801850e:	d427      	bmi.n	8018560 <HAL_RCC_OscConfig+0x20c>
      __HAL_RCC_PWR_CLK_ENABLE();
 8018510:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
      pwrclkchanged = SET;
 8018512:	2601      	movs	r6, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 8018514:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8018518:	641a      	str	r2, [r3, #64]	@ 0x40
 801851a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801851c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8018520:	9301      	str	r3, [sp, #4]
 8018522:	9b01      	ldr	r3, [sp, #4]
    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8018524:	4d2f      	ldr	r5, [pc, #188]	@ (80185e4 <HAL_RCC_OscConfig+0x290>)
 8018526:	682b      	ldr	r3, [r5, #0]
 8018528:	05d8      	lsls	r0, r3, #23
 801852a:	d51b      	bpl.n	8018564 <HAL_RCC_OscConfig+0x210>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 801852c:	68a3      	ldr	r3, [r4, #8]
 801852e:	4d2c      	ldr	r5, [pc, #176]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 8018530:	2b01      	cmp	r3, #1
 8018532:	d127      	bne.n	8018584 <HAL_RCC_OscConfig+0x230>
 8018534:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 8018536:	f043 0301 	orr.w	r3, r3, #1
 801853a:	672b      	str	r3, [r5, #112]	@ 0x70
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 801853c:	f241 3788 	movw	r7, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 8018540:	f7ff fbb6 	bl	8017cb0 <HAL_GetTick>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8018544:	4d26      	ldr	r5, [pc, #152]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
      tickstart = HAL_GetTick();
 8018546:	4680      	mov	r8, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8018548:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 801854a:	079a      	lsls	r2, r3, #30
 801854c:	d540      	bpl.n	80185d0 <HAL_RCC_OscConfig+0x27c>
    if (pwrclkchanged == SET)
 801854e:	2e00      	cmp	r6, #0
 8018550:	f43f af13 	beq.w	801837a <HAL_RCC_OscConfig+0x26>
      __HAL_RCC_PWR_CLK_DISABLE();
 8018554:	4a22      	ldr	r2, [pc, #136]	@ (80185e0 <HAL_RCC_OscConfig+0x28c>)
 8018556:	6c13      	ldr	r3, [r2, #64]	@ 0x40
 8018558:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 801855c:	6413      	str	r3, [r2, #64]	@ 0x40
 801855e:	e70c      	b.n	801837a <HAL_RCC_OscConfig+0x26>
  FlagStatus pwrclkchanged = RESET;
 8018560:	2600      	movs	r6, #0
 8018562:	e7df      	b.n	8018524 <HAL_RCC_OscConfig+0x1d0>
      PWR->CR1 |= PWR_CR1_DBP;
 8018564:	682b      	ldr	r3, [r5, #0]
 8018566:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 801856a:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 801856c:	f7ff fba0 	bl	8017cb0 <HAL_GetTick>
 8018570:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8018572:	682b      	ldr	r3, [r5, #0]
 8018574:	05d9      	lsls	r1, r3, #23
 8018576:	d4d9      	bmi.n	801852c <HAL_RCC_OscConfig+0x1d8>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8018578:	f7ff fb9a 	bl	8017cb0 <HAL_GetTick>
 801857c:	1bc0      	subs	r0, r0, r7
 801857e:	2864      	cmp	r0, #100	@ 0x64
 8018580:	d9f7      	bls.n	8018572 <HAL_RCC_OscConfig+0x21e>
 8018582:	e72c      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8018584:	b9b3      	cbnz	r3, 80185b4 <HAL_RCC_OscConfig+0x260>
 8018586:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8018588:	f241 3788 	movw	r7, #5000	@ 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 801858c:	f023 0301 	bic.w	r3, r3, #1
 8018590:	672b      	str	r3, [r5, #112]	@ 0x70
 8018592:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 8018594:	f023 0304 	bic.w	r3, r3, #4
 8018598:	672b      	str	r3, [r5, #112]	@ 0x70
      tickstart = HAL_GetTick();
 801859a:	f7ff fb89 	bl	8017cb0 <HAL_GetTick>
 801859e:	4680      	mov	r8, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80185a0:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 80185a2:	079b      	lsls	r3, r3, #30
 80185a4:	d5d3      	bpl.n	801854e <HAL_RCC_OscConfig+0x1fa>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80185a6:	f7ff fb83 	bl	8017cb0 <HAL_GetTick>
 80185aa:	eba0 0008 	sub.w	r0, r0, r8
 80185ae:	42b8      	cmp	r0, r7
 80185b0:	d9f6      	bls.n	80185a0 <HAL_RCC_OscConfig+0x24c>
 80185b2:	e714      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80185b4:	2b05      	cmp	r3, #5
 80185b6:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 80185b8:	d103      	bne.n	80185c2 <HAL_RCC_OscConfig+0x26e>
 80185ba:	f043 0304 	orr.w	r3, r3, #4
 80185be:	672b      	str	r3, [r5, #112]	@ 0x70
 80185c0:	e7b8      	b.n	8018534 <HAL_RCC_OscConfig+0x1e0>
 80185c2:	f023 0301 	bic.w	r3, r3, #1
 80185c6:	672b      	str	r3, [r5, #112]	@ 0x70
 80185c8:	6f2b      	ldr	r3, [r5, #112]	@ 0x70
 80185ca:	f023 0304 	bic.w	r3, r3, #4
 80185ce:	e7b4      	b.n	801853a <HAL_RCC_OscConfig+0x1e6>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80185d0:	f7ff fb6e 	bl	8017cb0 <HAL_GetTick>
 80185d4:	eba0 0008 	sub.w	r0, r0, r8
 80185d8:	42b8      	cmp	r0, r7
 80185da:	d9b5      	bls.n	8018548 <HAL_RCC_OscConfig+0x1f4>
 80185dc:	e6ff      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
 80185de:	bf00      	nop
 80185e0:	40023800 	.word	0x40023800
 80185e4:	40007000 	.word	0x40007000
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80185e8:	4d38      	ldr	r5, [pc, #224]	@ (80186cc <HAL_RCC_OscConfig+0x378>)
 80185ea:	68ab      	ldr	r3, [r5, #8]
 80185ec:	f003 030c 	and.w	r3, r3, #12
 80185f0:	2b08      	cmp	r3, #8
 80185f2:	d041      	beq.n	8018678 <HAL_RCC_OscConfig+0x324>
        __HAL_RCC_PLL_DISABLE();
 80185f4:	682b      	ldr	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80185f6:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 80185f8:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 80185fc:	602b      	str	r3, [r5, #0]
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80185fe:	d12e      	bne.n	801865e <HAL_RCC_OscConfig+0x30a>
        tickstart = HAL_GetTick();
 8018600:	f7ff fb56 	bl	8017cb0 <HAL_GetTick>
 8018604:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8018606:	682b      	ldr	r3, [r5, #0]
 8018608:	0199      	lsls	r1, r3, #6
 801860a:	d422      	bmi.n	8018652 <HAL_RCC_OscConfig+0x2fe>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 801860c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 801860e:	085b      	lsrs	r3, r3, #1
 8018610:	1e5a      	subs	r2, r3, #1
 8018612:	e9d4 3107 	ldrd	r3, r1, [r4, #28]
 8018616:	430b      	orrs	r3, r1
 8018618:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 801861c:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 801861e:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8018622:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8018624:	4c29      	ldr	r4, [pc, #164]	@ (80186cc <HAL_RCC_OscConfig+0x378>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8018626:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 801862a:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 801862e:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8018630:	682b      	ldr	r3, [r5, #0]
 8018632:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8018636:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8018638:	f7ff fb3a 	bl	8017cb0 <HAL_GetTick>
 801863c:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 801863e:	6823      	ldr	r3, [r4, #0]
 8018640:	019a      	lsls	r2, r3, #6
 8018642:	f53f ae9e 	bmi.w	8018382 <HAL_RCC_OscConfig+0x2e>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8018646:	f7ff fb33 	bl	8017cb0 <HAL_GetTick>
 801864a:	1b40      	subs	r0, r0, r5
 801864c:	2802      	cmp	r0, #2
 801864e:	d9f6      	bls.n	801863e <HAL_RCC_OscConfig+0x2ea>
 8018650:	e6c5      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8018652:	f7ff fb2d 	bl	8017cb0 <HAL_GetTick>
 8018656:	1b80      	subs	r0, r0, r6
 8018658:	2802      	cmp	r0, #2
 801865a:	d9d4      	bls.n	8018606 <HAL_RCC_OscConfig+0x2b2>
 801865c:	e6bf      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
        tickstart = HAL_GetTick();
 801865e:	f7ff fb27 	bl	8017cb0 <HAL_GetTick>
 8018662:	4604      	mov	r4, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8018664:	682b      	ldr	r3, [r5, #0]
 8018666:	019b      	lsls	r3, r3, #6
 8018668:	f57f ae8b 	bpl.w	8018382 <HAL_RCC_OscConfig+0x2e>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 801866c:	f7ff fb20 	bl	8017cb0 <HAL_GetTick>
 8018670:	1b00      	subs	r0, r0, r4
 8018672:	2802      	cmp	r0, #2
 8018674:	d9f6      	bls.n	8018664 <HAL_RCC_OscConfig+0x310>
 8018676:	e6b2      	b.n	80183de <HAL_RCC_OscConfig+0x8a>
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8018678:	2a01      	cmp	r2, #1
      pll_config = RCC->PLLCFGR;
 801867a:	686b      	ldr	r3, [r5, #4]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 801867c:	f43f ae98 	beq.w	80183b0 <HAL_RCC_OscConfig+0x5c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8018680:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8018684:	69e1      	ldr	r1, [r4, #28]
 8018686:	428a      	cmp	r2, r1
 8018688:	f47f ae92 	bne.w	80183b0 <HAL_RCC_OscConfig+0x5c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 801868c:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8018690:	6a21      	ldr	r1, [r4, #32]
 8018692:	428a      	cmp	r2, r1
 8018694:	f47f ae8c 	bne.w	80183b0 <HAL_RCC_OscConfig+0x5c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8018698:	f647 72c0 	movw	r2, #32704	@ 0x7fc0
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 801869c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 801869e:	401a      	ands	r2, r3
 80186a0:	ebb2 1f81 	cmp.w	r2, r1, lsl #6
 80186a4:	f47f ae84 	bne.w	80183b0 <HAL_RCC_OscConfig+0x5c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 80186a8:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 80186aa:	f403 3140 	and.w	r1, r3, #196608	@ 0x30000
 80186ae:	0852      	lsrs	r2, r2, #1
 80186b0:	3a01      	subs	r2, #1
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80186b2:	ebb1 4f02 	cmp.w	r1, r2, lsl #16
 80186b6:	f47f ae7b 	bne.w	80183b0 <HAL_RCC_OscConfig+0x5c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 80186ba:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 80186bc:	f003 6370 	and.w	r3, r3, #251658240	@ 0xf000000
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
 80186c0:	ebb3 6f02 	cmp.w	r3, r2, lsl #24
 80186c4:	bf14      	ite	ne
 80186c6:	2001      	movne	r0, #1
 80186c8:	2000      	moveq	r0, #0
 80186ca:	e689      	b.n	80183e0 <HAL_RCC_OscConfig+0x8c>
 80186cc:	40023800 	.word	0x40023800

080186d0 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  uint32_t sysclockfreq = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80186d0:	4913      	ldr	r1, [pc, #76]	@ (8018720 <HAL_RCC_GetSysClockFreq+0x50>)
{
 80186d2:	b508      	push	{r3, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80186d4:	688b      	ldr	r3, [r1, #8]
 80186d6:	f003 030c 	and.w	r3, r3, #12
 80186da:	2b04      	cmp	r3, #4
 80186dc:	d01b      	beq.n	8018716 <HAL_RCC_GetSysClockFreq+0x46>
 80186de:	2b08      	cmp	r3, #8
 80186e0:	d11b      	bne.n	801871a <HAL_RCC_GetSysClockFreq+0x4a>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80186e2:	684a      	ldr	r2, [r1, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 80186e4:	684b      	ldr	r3, [r1, #4]
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80186e6:	6849      	ldr	r1, [r1, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80186e8:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 80186ec:	f413 0380 	ands.w	r3, r3, #4194304	@ 0x400000
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80186f0:	f3c1 1188 	ubfx	r1, r1, #6, #9
 80186f4:	bf1a      	itte	ne
 80186f6:	480b      	ldrne	r0, [pc, #44]	@ (8018724 <HAL_RCC_GetSysClockFreq+0x54>)
 80186f8:	2300      	movne	r3, #0
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80186fa:	480b      	ldreq	r0, [pc, #44]	@ (8018728 <HAL_RCC_GetSysClockFreq+0x58>)
 80186fc:	fba1 0100 	umull	r0, r1, r1, r0
 8018700:	f7fe fcde 	bl	80170c0 <__aeabi_uldivmod>
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
 8018704:	4b06      	ldr	r3, [pc, #24]	@ (8018720 <HAL_RCC_GetSysClockFreq+0x50>)
 8018706:	685b      	ldr	r3, [r3, #4]
 8018708:	f3c3 4301 	ubfx	r3, r3, #16, #2
 801870c:	3301      	adds	r3, #1
 801870e:	005b      	lsls	r3, r3, #1

      sysclockfreq = pllvco / pllp;
 8018710:	fbb0 f0f3 	udiv	r0, r0, r3
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8018714:	bd08      	pop	{r3, pc}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8018716:	4803      	ldr	r0, [pc, #12]	@ (8018724 <HAL_RCC_GetSysClockFreq+0x54>)
 8018718:	e7fc      	b.n	8018714 <HAL_RCC_GetSysClockFreq+0x44>
      sysclockfreq = HSI_VALUE;
 801871a:	4803      	ldr	r0, [pc, #12]	@ (8018728 <HAL_RCC_GetSysClockFreq+0x58>)
  return sysclockfreq;
 801871c:	e7fa      	b.n	8018714 <HAL_RCC_GetSysClockFreq+0x44>
 801871e:	bf00      	nop
 8018720:	40023800 	.word	0x40023800
 8018724:	017d7840 	.word	0x017d7840
 8018728:	00f42400 	.word	0x00f42400

0801872c <HAL_RCC_ClockConfig>:
{
 801872c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8018730:	4604      	mov	r4, r0
 8018732:	460d      	mov	r5, r1
  if (RCC_ClkInitStruct == NULL)
 8018734:	b910      	cbnz	r0, 801873c <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8018736:	2001      	movs	r0, #1
}
 8018738:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 801873c:	4a45      	ldr	r2, [pc, #276]	@ (8018854 <HAL_RCC_ClockConfig+0x128>)
 801873e:	6813      	ldr	r3, [r2, #0]
 8018740:	f003 030f 	and.w	r3, r3, #15
 8018744:	428b      	cmp	r3, r1
 8018746:	d328      	bcc.n	801879a <HAL_RCC_ClockConfig+0x6e>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8018748:	6821      	ldr	r1, [r4, #0]
 801874a:	078f      	lsls	r7, r1, #30
 801874c:	d430      	bmi.n	80187b0 <HAL_RCC_ClockConfig+0x84>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 801874e:	07c8      	lsls	r0, r1, #31
 8018750:	d443      	bmi.n	80187da <HAL_RCC_ClockConfig+0xae>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8018752:	4a40      	ldr	r2, [pc, #256]	@ (8018854 <HAL_RCC_ClockConfig+0x128>)
 8018754:	6813      	ldr	r3, [r2, #0]
 8018756:	f003 030f 	and.w	r3, r3, #15
 801875a:	42ab      	cmp	r3, r5
 801875c:	d866      	bhi.n	801882c <HAL_RCC_ClockConfig+0x100>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 801875e:	6822      	ldr	r2, [r4, #0]
 8018760:	0751      	lsls	r1, r2, #29
 8018762:	d46f      	bmi.n	8018844 <HAL_RCC_ClockConfig+0x118>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8018764:	0713      	lsls	r3, r2, #28
 8018766:	d507      	bpl.n	8018778 <HAL_RCC_ClockConfig+0x4c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8018768:	4a3b      	ldr	r2, [pc, #236]	@ (8018858 <HAL_RCC_ClockConfig+0x12c>)
 801876a:	6921      	ldr	r1, [r4, #16]
 801876c:	6893      	ldr	r3, [r2, #8]
 801876e:	f423 4360 	bic.w	r3, r3, #57344	@ 0xe000
 8018772:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8018776:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8018778:	f7ff ffaa 	bl	80186d0 <HAL_RCC_GetSysClockFreq>
 801877c:	4b36      	ldr	r3, [pc, #216]	@ (8018858 <HAL_RCC_ClockConfig+0x12c>)
 801877e:	4a37      	ldr	r2, [pc, #220]	@ (801885c <HAL_RCC_ClockConfig+0x130>)
 8018780:	689b      	ldr	r3, [r3, #8]
 8018782:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8018786:	5cd3      	ldrb	r3, [r2, r3]
 8018788:	40d8      	lsrs	r0, r3
 801878a:	4b35      	ldr	r3, [pc, #212]	@ (8018860 <HAL_RCC_ClockConfig+0x134>)
 801878c:	6018      	str	r0, [r3, #0]
  HAL_InitTick(uwTickPrio);
 801878e:	4b35      	ldr	r3, [pc, #212]	@ (8018864 <HAL_RCC_ClockConfig+0x138>)
 8018790:	6818      	ldr	r0, [r3, #0]
 8018792:	f7ff fa51 	bl	8017c38 <HAL_InitTick>
  return HAL_OK;
 8018796:	2000      	movs	r0, #0
 8018798:	e7ce      	b.n	8018738 <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 801879a:	6813      	ldr	r3, [r2, #0]
 801879c:	f023 030f 	bic.w	r3, r3, #15
 80187a0:	430b      	orrs	r3, r1
 80187a2:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80187a4:	6813      	ldr	r3, [r2, #0]
 80187a6:	f003 030f 	and.w	r3, r3, #15
 80187aa:	428b      	cmp	r3, r1
 80187ac:	d1c3      	bne.n	8018736 <HAL_RCC_ClockConfig+0xa>
 80187ae:	e7cb      	b.n	8018748 <HAL_RCC_ClockConfig+0x1c>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80187b0:	f011 0f04 	tst.w	r1, #4
 80187b4:	4b28      	ldr	r3, [pc, #160]	@ (8018858 <HAL_RCC_ClockConfig+0x12c>)
 80187b6:	d003      	beq.n	80187c0 <HAL_RCC_ClockConfig+0x94>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80187b8:	689a      	ldr	r2, [r3, #8]
 80187ba:	f442 52e0 	orr.w	r2, r2, #7168	@ 0x1c00
 80187be:	609a      	str	r2, [r3, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80187c0:	070e      	lsls	r6, r1, #28
 80187c2:	d503      	bpl.n	80187cc <HAL_RCC_ClockConfig+0xa0>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80187c4:	689a      	ldr	r2, [r3, #8]
 80187c6:	f442 4260 	orr.w	r2, r2, #57344	@ 0xe000
 80187ca:	609a      	str	r2, [r3, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80187cc:	689a      	ldr	r2, [r3, #8]
 80187ce:	68a0      	ldr	r0, [r4, #8]
 80187d0:	f022 02f0 	bic.w	r2, r2, #240	@ 0xf0
 80187d4:	4302      	orrs	r2, r0
 80187d6:	609a      	str	r2, [r3, #8]
 80187d8:	e7b9      	b.n	801874e <HAL_RCC_ClockConfig+0x22>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80187da:	6861      	ldr	r1, [r4, #4]
 80187dc:	4b1e      	ldr	r3, [pc, #120]	@ (8018858 <HAL_RCC_ClockConfig+0x12c>)
 80187de:	2901      	cmp	r1, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80187e0:	681a      	ldr	r2, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80187e2:	d11b      	bne.n	801881c <HAL_RCC_ClockConfig+0xf0>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80187e4:	f412 3f00 	tst.w	r2, #131072	@ 0x20000
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80187e8:	d0a5      	beq.n	8018736 <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80187ea:	689a      	ldr	r2, [r3, #8]
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80187ec:	f241 3888 	movw	r8, #5000	@ 0x1388
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80187f0:	4f19      	ldr	r7, [pc, #100]	@ (8018858 <HAL_RCC_ClockConfig+0x12c>)
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80187f2:	f022 0203 	bic.w	r2, r2, #3
 80187f6:	430a      	orrs	r2, r1
 80187f8:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();
 80187fa:	f7ff fa59 	bl	8017cb0 <HAL_GetTick>
 80187fe:	4606      	mov	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8018800:	68bb      	ldr	r3, [r7, #8]
 8018802:	6862      	ldr	r2, [r4, #4]
 8018804:	f003 030c 	and.w	r3, r3, #12
 8018808:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 801880c:	d0a1      	beq.n	8018752 <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 801880e:	f7ff fa4f 	bl	8017cb0 <HAL_GetTick>
 8018812:	1b80      	subs	r0, r0, r6
 8018814:	4540      	cmp	r0, r8
 8018816:	d9f3      	bls.n	8018800 <HAL_RCC_ClockConfig+0xd4>
        return HAL_TIMEOUT;
 8018818:	2003      	movs	r0, #3
 801881a:	e78d      	b.n	8018738 <HAL_RCC_ClockConfig+0xc>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 801881c:	2902      	cmp	r1, #2
 801881e:	d102      	bne.n	8018826 <HAL_RCC_ClockConfig+0xfa>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8018820:	f012 7f00 	tst.w	r2, #33554432	@ 0x2000000
 8018824:	e7e0      	b.n	80187e8 <HAL_RCC_ClockConfig+0xbc>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8018826:	f012 0f02 	tst.w	r2, #2
 801882a:	e7dd      	b.n	80187e8 <HAL_RCC_ClockConfig+0xbc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 801882c:	6813      	ldr	r3, [r2, #0]
 801882e:	f023 030f 	bic.w	r3, r3, #15
 8018832:	432b      	orrs	r3, r5
 8018834:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8018836:	6813      	ldr	r3, [r2, #0]
 8018838:	f003 030f 	and.w	r3, r3, #15
 801883c:	42ab      	cmp	r3, r5
 801883e:	f47f af7a 	bne.w	8018736 <HAL_RCC_ClockConfig+0xa>
 8018842:	e78c      	b.n	801875e <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8018844:	4904      	ldr	r1, [pc, #16]	@ (8018858 <HAL_RCC_ClockConfig+0x12c>)
 8018846:	68e0      	ldr	r0, [r4, #12]
 8018848:	688b      	ldr	r3, [r1, #8]
 801884a:	f423 53e0 	bic.w	r3, r3, #7168	@ 0x1c00
 801884e:	4303      	orrs	r3, r0
 8018850:	608b      	str	r3, [r1, #8]
 8018852:	e787      	b.n	8018764 <HAL_RCC_ClockConfig+0x38>
 8018854:	40023c00 	.word	0x40023c00
 8018858:	40023800 	.word	0x40023800
 801885c:	0801c3bf 	.word	0x0801c3bf
 8018860:	20000000 	.word	0x20000000
 8018864:	20000008 	.word	0x20000008

08018868 <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8018868:	4b04      	ldr	r3, [pc, #16]	@ (801887c <HAL_RCC_GetPCLK1Freq+0x14>)
 801886a:	4a05      	ldr	r2, [pc, #20]	@ (8018880 <HAL_RCC_GetPCLK1Freq+0x18>)
 801886c:	689b      	ldr	r3, [r3, #8]
 801886e:	f3c3 2382 	ubfx	r3, r3, #10, #3
 8018872:	5cd3      	ldrb	r3, [r2, r3]
 8018874:	4a03      	ldr	r2, [pc, #12]	@ (8018884 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8018876:	6810      	ldr	r0, [r2, #0]
}
 8018878:	40d8      	lsrs	r0, r3
 801887a:	4770      	bx	lr
 801887c:	40023800 	.word	0x40023800
 8018880:	0801c3b7 	.word	0x0801c3b7
 8018884:	20000000 	.word	0x20000000

08018888 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8018888:	4b04      	ldr	r3, [pc, #16]	@ (801889c <HAL_RCC_GetPCLK2Freq+0x14>)
 801888a:	4a05      	ldr	r2, [pc, #20]	@ (80188a0 <HAL_RCC_GetPCLK2Freq+0x18>)
 801888c:	689b      	ldr	r3, [r3, #8]
 801888e:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8018892:	5cd3      	ldrb	r3, [r2, r3]
 8018894:	4a03      	ldr	r2, [pc, #12]	@ (80188a4 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8018896:	6810      	ldr	r0, [r2, #0]
}
 8018898:	40d8      	lsrs	r0, r3
 801889a:	4770      	bx	lr
 801889c:	40023800 	.word	0x40023800
 80188a0:	0801c3b7 	.word	0x0801c3b7
 80188a4:	20000000 	.word	0x20000000

080188a8 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80188a8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80188ac:	6805      	ldr	r5, [r0, #0]
{
 80188ae:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80188b0:	f015 0701 	ands.w	r7, r5, #1
 80188b4:	d00b      	beq.n	80188ce <HAL_RCCEx_PeriphCLKConfig+0x26>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80188b6:	4bae      	ldr	r3, [pc, #696]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 80188b8:	689a      	ldr	r2, [r3, #8]
 80188ba:	f422 0200 	bic.w	r2, r2, #8388608	@ 0x800000
 80188be:	609a      	str	r2, [r3, #8]
 80188c0:	6b47      	ldr	r7, [r0, #52]	@ 0x34
 80188c2:	689a      	ldr	r2, [r3, #8]
 80188c4:	433a      	orrs	r2, r7

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 80188c6:	fab7 f787 	clz	r7, r7
 80188ca:	097f      	lsrs	r7, r7, #5
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80188cc:	609a      	str	r2, [r3, #8]
      plli2sused = 1;
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 80188ce:	f415 2600 	ands.w	r6, r5, #524288	@ 0x80000
 80188d2:	d012      	beq.n	80188fa <HAL_RCCEx_PeriphCLKConfig+0x52>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80188d4:	4aa6      	ldr	r2, [pc, #664]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 80188d6:	6be6      	ldr	r6, [r4, #60]	@ 0x3c
 80188d8:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 80188dc:	f5b6 1f80 	cmp.w	r6, #1048576	@ 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80188e0:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
    {
      plli2sused = 1;
 80188e4:	bf08      	it	eq
 80188e6:	2701      	moveq	r7, #1
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80188e8:	ea43 0306 	orr.w	r3, r3, r6
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 80188ec:	bf16      	itet	ne
 80188ee:	fab6 f686 	clzne	r6, r6
  uint32_t pllsaiused = 0;
 80188f2:	2600      	moveq	r6, #0
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 80188f4:	0976      	lsrne	r6, r6, #5
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80188f6:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
      pllsaiused = 1;
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 80188fa:	02eb      	lsls	r3, r5, #11
 80188fc:	d511      	bpl.n	8018922 <HAL_RCCEx_PeriphCLKConfig+0x7a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 80188fe:	499c      	ldr	r1, [pc, #624]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018900:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8018902:	f8d1 308c 	ldr.w	r3, [r1, #140]	@ 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8018906:	f5b2 0f80 	cmp.w	r2, #4194304	@ 0x400000
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 801890a:	f423 0340 	bic.w	r3, r3, #12582912	@ 0xc00000
 801890e:	ea43 0302 	orr.w	r3, r3, r2
 8018912:	f8c1 308c 	str.w	r3, [r1, #140]	@ 0x8c
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8018916:	f000 818a 	beq.w	8018c2e <HAL_RCCEx_PeriphCLKConfig+0x386>
    {
      plli2sused = 1;
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
 801891a:	2a00      	cmp	r2, #0
 801891c:	bf08      	it	eq
 801891e:	f046 0601 	orreq.w	r6, r6, #1
  {
      plli2sused = 1;
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8018922:	06a8      	lsls	r0, r5, #26
 8018924:	d537      	bpl.n	8018996 <HAL_RCCEx_PeriphCLKConfig+0xee>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8018926:	4b92      	ldr	r3, [pc, #584]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8018928:	f8df 8248 	ldr.w	r8, [pc, #584]	@ 8018b74 <HAL_RCCEx_PeriphCLKConfig+0x2cc>
    __HAL_RCC_PWR_CLK_ENABLE();
 801892c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801892e:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8018932:	641a      	str	r2, [r3, #64]	@ 0x40
 8018934:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8018936:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 801893a:	9301      	str	r3, [sp, #4]
 801893c:	9b01      	ldr	r3, [sp, #4]
    PWR->CR1 |= PWR_CR1_DBP;
 801893e:	f8d8 3000 	ldr.w	r3, [r8]
 8018942:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8018946:	f8c8 3000 	str.w	r3, [r8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 801894a:	f7ff f9b1 	bl	8017cb0 <HAL_GetTick>
 801894e:	4681      	mov	r9, r0

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8018950:	f8d8 3000 	ldr.w	r3, [r8]
 8018954:	05d9      	lsls	r1, r3, #23
 8018956:	f140 816c 	bpl.w	8018c32 <HAL_RCCEx_PeriphCLKConfig+0x38a>
        return HAL_TIMEOUT;
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 801895a:	f8df 8214 	ldr.w	r8, [pc, #532]	@ 8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>
 801895e:	f8d8 3070 	ldr.w	r3, [r8, #112]	@ 0x70

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8018962:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 8018966:	f040 816f 	bne.w	8018c48 <HAL_RCCEx_PeriphCLKConfig+0x3a0>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 801896a:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 801896c:	f403 7240 	and.w	r2, r3, #768	@ 0x300
 8018970:	f5b2 7f40 	cmp.w	r2, #768	@ 0x300
 8018974:	4a7e      	ldr	r2, [pc, #504]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018976:	f040 8195 	bne.w	8018ca4 <HAL_RCCEx_PeriphCLKConfig+0x3fc>
 801897a:	6891      	ldr	r1, [r2, #8]
 801897c:	f023 4070 	bic.w	r0, r3, #4026531840	@ 0xf0000000
 8018980:	f421 11f8 	bic.w	r1, r1, #2031616	@ 0x1f0000
 8018984:	f420 7040 	bic.w	r0, r0, #768	@ 0x300
 8018988:	4301      	orrs	r1, r0
 801898a:	6091      	str	r1, [r2, #8]
 801898c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8018990:	6f11      	ldr	r1, [r2, #112]	@ 0x70
 8018992:	430b      	orrs	r3, r1
 8018994:	6713      	str	r3, [r2, #112]	@ 0x70
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8018996:	f3c5 6500 	ubfx	r5, r5, #24, #1
 801899a:	432f      	orrs	r7, r5
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 801899c:	6825      	ldr	r5, [r4, #0]
 801899e:	06e8      	lsls	r0, r5, #27
 80189a0:	d50c      	bpl.n	80189bc <HAL_RCCEx_PeriphCLKConfig+0x114>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80189a2:	4a73      	ldr	r2, [pc, #460]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 80189a4:	f8d2 108c 	ldr.w	r1, [r2, #140]	@ 0x8c
 80189a8:	f021 7180 	bic.w	r1, r1, #16777216	@ 0x1000000
 80189ac:	f8c2 108c 	str.w	r1, [r2, #140]	@ 0x8c
 80189b0:	f8d2 108c 	ldr.w	r1, [r2, #140]	@ 0x8c
 80189b4:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 80189b6:	4301      	orrs	r1, r0
 80189b8:	f8c2 108c 	str.w	r1, [r2, #140]	@ 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80189bc:	0469      	lsls	r1, r5, #17
 80189be:	d508      	bpl.n	80189d2 <HAL_RCCEx_PeriphCLKConfig+0x12a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80189c0:	496b      	ldr	r1, [pc, #428]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 80189c2:	6e60      	ldr	r0, [r4, #100]	@ 0x64
 80189c4:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 80189c8:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
 80189cc:	4302      	orrs	r2, r0
 80189ce:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80189d2:	042a      	lsls	r2, r5, #16
 80189d4:	d508      	bpl.n	80189e8 <HAL_RCCEx_PeriphCLKConfig+0x140>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80189d6:	4966      	ldr	r1, [pc, #408]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 80189d8:	6ea0      	ldr	r0, [r4, #104]	@ 0x68
 80189da:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 80189de:	f422 2240 	bic.w	r2, r2, #786432	@ 0xc0000
 80189e2:	4302      	orrs	r2, r0
 80189e4:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80189e8:	03eb      	lsls	r3, r5, #15
 80189ea:	d508      	bpl.n	80189fe <HAL_RCCEx_PeriphCLKConfig+0x156>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80189ec:	4960      	ldr	r1, [pc, #384]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 80189ee:	6ee0      	ldr	r0, [r4, #108]	@ 0x6c
 80189f0:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 80189f4:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 80189f8:	4302      	orrs	r2, r0
 80189fa:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 80189fe:	03a8      	lsls	r0, r5, #14
 8018a00:	d508      	bpl.n	8018a14 <HAL_RCCEx_PeriphCLKConfig+0x16c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8018a02:	495b      	ldr	r1, [pc, #364]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018a04:	6f20      	ldr	r0, [r4, #112]	@ 0x70
 8018a06:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018a0a:	f422 0240 	bic.w	r2, r2, #12582912	@ 0xc00000
 8018a0e:	4302      	orrs	r2, r0
 8018a10:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8018a14:	0669      	lsls	r1, r5, #25
 8018a16:	d508      	bpl.n	8018a2a <HAL_RCCEx_PeriphCLKConfig+0x182>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8018a18:	4955      	ldr	r1, [pc, #340]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018a1a:	6c60      	ldr	r0, [r4, #68]	@ 0x44
 8018a1c:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018a20:	f022 0203 	bic.w	r2, r2, #3
 8018a24:	4302      	orrs	r2, r0
 8018a26:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8018a2a:	062a      	lsls	r2, r5, #24
 8018a2c:	d508      	bpl.n	8018a40 <HAL_RCCEx_PeriphCLKConfig+0x198>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8018a2e:	4950      	ldr	r1, [pc, #320]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018a30:	6ca0      	ldr	r0, [r4, #72]	@ 0x48
 8018a32:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018a36:	f022 020c 	bic.w	r2, r2, #12
 8018a3a:	4302      	orrs	r2, r0
 8018a3c:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8018a40:	05eb      	lsls	r3, r5, #23
 8018a42:	d508      	bpl.n	8018a56 <HAL_RCCEx_PeriphCLKConfig+0x1ae>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8018a44:	494a      	ldr	r1, [pc, #296]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018a46:	6ce0      	ldr	r0, [r4, #76]	@ 0x4c
 8018a48:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018a4c:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 8018a50:	4302      	orrs	r2, r0
 8018a52:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8018a56:	05a8      	lsls	r0, r5, #22
 8018a58:	d508      	bpl.n	8018a6c <HAL_RCCEx_PeriphCLKConfig+0x1c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8018a5a:	4945      	ldr	r1, [pc, #276]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018a5c:	6d20      	ldr	r0, [r4, #80]	@ 0x50
 8018a5e:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018a62:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 8018a66:	4302      	orrs	r2, r0
 8018a68:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8018a6c:	0569      	lsls	r1, r5, #21
 8018a6e:	d508      	bpl.n	8018a82 <HAL_RCCEx_PeriphCLKConfig+0x1da>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8018a70:	493f      	ldr	r1, [pc, #252]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018a72:	6d60      	ldr	r0, [r4, #84]	@ 0x54
 8018a74:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018a78:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8018a7c:	4302      	orrs	r2, r0
 8018a7e:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8018a82:	052a      	lsls	r2, r5, #20
 8018a84:	d508      	bpl.n	8018a98 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8018a86:	493a      	ldr	r1, [pc, #232]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018a88:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8018a8a:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018a8e:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
 8018a92:	4302      	orrs	r2, r0
 8018a94:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8018a98:	04eb      	lsls	r3, r5, #19
 8018a9a:	d508      	bpl.n	8018aae <HAL_RCCEx_PeriphCLKConfig+0x206>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8018a9c:	4934      	ldr	r1, [pc, #208]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018a9e:	6de0      	ldr	r0, [r4, #92]	@ 0x5c
 8018aa0:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018aa4:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 8018aa8:	4302      	orrs	r2, r0
 8018aaa:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8018aae:	04a8      	lsls	r0, r5, #18
 8018ab0:	d508      	bpl.n	8018ac4 <HAL_RCCEx_PeriphCLKConfig+0x21c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8018ab2:	492f      	ldr	r1, [pc, #188]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018ab4:	6e20      	ldr	r0, [r4, #96]	@ 0x60
 8018ab6:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018aba:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 8018abe:	4302      	orrs	r2, r0
 8018ac0:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8018ac4:	0269      	lsls	r1, r5, #9
 8018ac6:	d508      	bpl.n	8018ada <HAL_RCCEx_PeriphCLKConfig+0x232>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8018ac8:	4929      	ldr	r1, [pc, #164]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018aca:	6fa0      	ldr	r0, [r4, #120]	@ 0x78
 8018acc:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018ad0:	f022 6280 	bic.w	r2, r2, #67108864	@ 0x4000000
 8018ad4:	4302      	orrs	r2, r0
 8018ad6:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8018ada:	02aa      	lsls	r2, r5, #10
 8018adc:	d50d      	bpl.n	8018afa <HAL_RCCEx_PeriphCLKConfig+0x252>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8018ade:	4824      	ldr	r0, [pc, #144]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018ae0:	6fe1      	ldr	r1, [r4, #124]	@ 0x7c
 8018ae2:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
 8018ae6:	f1b1 6f00 	cmp.w	r1, #134217728	@ 0x8000000
 8018aea:	bf08      	it	eq
 8018aec:	f046 0601 	orreq.w	r6, r6, #1
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8018af0:	f022 6200 	bic.w	r2, r2, #134217728	@ 0x8000000
 8018af4:	430a      	orrs	r2, r1
 8018af6:	f8c0 2090 	str.w	r2, [r0, #144]	@ 0x90
    pllsaiused = 1;
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8018afa:	036b      	lsls	r3, r5, #13
 8018afc:	d508      	bpl.n	8018b10 <HAL_RCCEx_PeriphCLKConfig+0x268>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8018afe:	491c      	ldr	r1, [pc, #112]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018b00:	6f60      	ldr	r0, [r4, #116]	@ 0x74
 8018b02:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018b06:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 8018b0a:	4302      	orrs	r2, r0
 8018b0c:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8018b10:	0228      	lsls	r0, r5, #8
 8018b12:	d509      	bpl.n	8018b28 <HAL_RCCEx_PeriphCLKConfig+0x280>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8018b14:	4916      	ldr	r1, [pc, #88]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018b16:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 8018b1a:	f8d1 2090 	ldr.w	r2, [r1, #144]	@ 0x90
 8018b1e:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 8018b22:	4302      	orrs	r2, r0
 8018b24:	f8c1 2090 	str.w	r2, [r1, #144]	@ 0x90
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8018b28:	2f00      	cmp	r7, #0
 8018b2a:	f040 80bf 	bne.w	8018cac <HAL_RCCEx_PeriphCLKConfig+0x404>
 8018b2e:	01a9      	lsls	r1, r5, #6
 8018b30:	f100 80bc 	bmi.w	8018cac <HAL_RCCEx_PeriphCLKConfig+0x404>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8018b34:	f3c5 05c0 	ubfx	r5, r5, #3, #1
 8018b38:	4335      	orrs	r5, r6
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 8018b3a:	2d01      	cmp	r5, #1
 8018b3c:	d175      	bne.n	8018c2a <HAL_RCCEx_PeriphCLKConfig+0x382>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
 8018b3e:	4d0c      	ldr	r5, [pc, #48]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018b40:	682b      	ldr	r3, [r5, #0]
 8018b42:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8018b46:	602b      	str	r3, [r5, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8018b48:	f7ff f8b2 	bl	8017cb0 <HAL_GetTick>
 8018b4c:	4606      	mov	r6, r0

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8018b4e:	682b      	ldr	r3, [r5, #0]
 8018b50:	009f      	lsls	r7, r3, #2
 8018b52:	f100 8131 	bmi.w	8018db8 <HAL_RCCEx_PeriphCLKConfig+0x510>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 8018b56:	6821      	ldr	r1, [r4, #0]
 8018b58:	030e      	lsls	r6, r1, #12
 8018b5a:	d501      	bpl.n	8018b60 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
 8018b5c:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8018b5e:	b11b      	cbz	r3, 8018b68 <HAL_RCCEx_PeriphCLKConfig+0x2c0>
 8018b60:	02cd      	lsls	r5, r1, #11
 8018b62:	d522      	bpl.n	8018baa <HAL_RCCEx_PeriphCLKConfig+0x302>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 8018b64:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8018b66:	bb03      	cbnz	r3, 8018baa <HAL_RCCEx_PeriphCLKConfig+0x302>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8018b68:	4a01      	ldr	r2, [pc, #4]	@ (8018b70 <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8018b6a:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
 8018b6e:	e003      	b.n	8018b78 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
 8018b70:	40023800 	.word	0x40023800
 8018b74:	40007000 	.word	0x40007000
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8018b78:	f8d2 0088 	ldr.w	r0, [r2, #136]	@ 0x88
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8018b7c:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8018b80:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
 8018b84:	4303      	orrs	r3, r0
 8018b86:	6960      	ldr	r0, [r4, #20]
 8018b88:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8018b8c:	69a0      	ldr	r0, [r4, #24]
 8018b8e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8018b92:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8018b96:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
 8018b9a:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8018b9c:	f423 53f8 	bic.w	r3, r3, #7936	@ 0x1f00
 8018ba0:	3801      	subs	r0, #1
 8018ba2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8018ba6:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8018baa:	0288      	lsls	r0, r1, #10
 8018bac:	d515      	bpl.n	8018bda <HAL_RCCEx_PeriphCLKConfig+0x332>
 8018bae:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 8018bb0:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8018bb4:	d111      	bne.n	8018bda <HAL_RCCEx_PeriphCLKConfig+0x332>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8018bb6:	4a87      	ldr	r2, [pc, #540]	@ (8018dd4 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8018bb8:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8018bbc:	f8d2 0088 	ldr.w	r0, [r2, #136]	@ 0x88

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 8018bc0:	f003 6370 	and.w	r3, r3, #251658240	@ 0xf000000
 8018bc4:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
 8018bc8:	4303      	orrs	r3, r0
 8018bca:	6960      	ldr	r0, [r4, #20]
 8018bcc:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8018bd0:	6a20      	ldr	r0, [r4, #32]
 8018bd2:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8018bd6:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8018bda:	070a      	lsls	r2, r1, #28
 8018bdc:	d519      	bpl.n	8018c12 <HAL_RCCEx_PeriphCLKConfig+0x36a>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8018bde:	4a7d      	ldr	r2, [pc, #500]	@ (8018dd4 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8018be0:	f8d2 1088 	ldr.w	r1, [r2, #136]	@ 0x88
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 8018be4:	f8d2 3088 	ldr.w	r3, [r2, #136]	@ 0x88

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 8018be8:	f001 6170 	and.w	r1, r1, #251658240	@ 0xf000000
 8018bec:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8018bf0:	430b      	orrs	r3, r1
 8018bf2:	6961      	ldr	r1, [r4, #20]
 8018bf4:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8018bf8:	69e1      	ldr	r1, [r4, #28]
 8018bfa:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8018bfe:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 8018c02:	f8d2 308c 	ldr.w	r3, [r2, #140]	@ 0x8c
 8018c06:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8018c08:	f423 3340 	bic.w	r3, r3, #196608	@ 0x30000
 8018c0c:	430b      	orrs	r3, r1
 8018c0e:	f8c2 308c 	str.w	r3, [r2, #140]	@ 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 8018c12:	4c70      	ldr	r4, [pc, #448]	@ (8018dd4 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8018c14:	6823      	ldr	r3, [r4, #0]
 8018c16:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8018c1a:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8018c1c:	f7ff f848 	bl	8017cb0 <HAL_GetTick>
 8018c20:	4605      	mov	r5, r0

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8018c22:	6823      	ldr	r3, [r4, #0]
 8018c24:	009b      	lsls	r3, r3, #2
 8018c26:	f140 80ce 	bpl.w	8018dc6 <HAL_RCCEx_PeriphCLKConfig+0x51e>
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8018c2a:	2000      	movs	r0, #0
 8018c2c:	e009      	b.n	8018c42 <HAL_RCCEx_PeriphCLKConfig+0x39a>
      plli2sused = 1;
 8018c2e:	2701      	movs	r7, #1
 8018c30:	e677      	b.n	8018922 <HAL_RCCEx_PeriphCLKConfig+0x7a>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8018c32:	f7ff f83d 	bl	8017cb0 <HAL_GetTick>
 8018c36:	eba0 0009 	sub.w	r0, r0, r9
 8018c3a:	2864      	cmp	r0, #100	@ 0x64
 8018c3c:	f67f ae88 	bls.w	8018950 <HAL_RCCEx_PeriphCLKConfig+0xa8>
        return HAL_TIMEOUT;
 8018c40:	2003      	movs	r0, #3
}
 8018c42:	b002      	add	sp, #8
 8018c44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8018c48:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8018c4a:	f402 7240 	and.w	r2, r2, #768	@ 0x300
 8018c4e:	4293      	cmp	r3, r2
 8018c50:	f43f ae8b 	beq.w	801896a <HAL_RCCEx_PeriphCLKConfig+0xc2>
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8018c54:	f8d8 3070 	ldr.w	r3, [r8, #112]	@ 0x70
      __HAL_RCC_BACKUPRESET_FORCE();
 8018c58:	f8d8 2070 	ldr.w	r2, [r8, #112]	@ 0x70
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8018c5c:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8018c60:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8018c64:	f8c8 2070 	str.w	r2, [r8, #112]	@ 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 8018c68:	f8d8 2070 	ldr.w	r2, [r8, #112]	@ 0x70
 8018c6c:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8018c70:	f8c8 2070 	str.w	r2, [r8, #112]	@ 0x70
      RCC->BDCR = tmpreg0;
 8018c74:	f8c8 3070 	str.w	r3, [r8, #112]	@ 0x70
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8018c78:	f8d8 3070 	ldr.w	r3, [r8, #112]	@ 0x70
 8018c7c:	07da      	lsls	r2, r3, #31
 8018c7e:	f57f ae74 	bpl.w	801896a <HAL_RCCEx_PeriphCLKConfig+0xc2>
        tickstart = HAL_GetTick();
 8018c82:	f7ff f815 	bl	8017cb0 <HAL_GetTick>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8018c86:	f241 3a88 	movw	sl, #5000	@ 0x1388
        tickstart = HAL_GetTick();
 8018c8a:	4681      	mov	r9, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8018c8c:	f8d8 3070 	ldr.w	r3, [r8, #112]	@ 0x70
 8018c90:	079b      	lsls	r3, r3, #30
 8018c92:	f53f ae6a 	bmi.w	801896a <HAL_RCCEx_PeriphCLKConfig+0xc2>
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8018c96:	f7ff f80b 	bl	8017cb0 <HAL_GetTick>
 8018c9a:	eba0 0009 	sub.w	r0, r0, r9
 8018c9e:	4550      	cmp	r0, sl
 8018ca0:	d9f4      	bls.n	8018c8c <HAL_RCCEx_PeriphCLKConfig+0x3e4>
 8018ca2:	e7cd      	b.n	8018c40 <HAL_RCCEx_PeriphCLKConfig+0x398>
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8018ca4:	6891      	ldr	r1, [r2, #8]
 8018ca6:	f421 11f8 	bic.w	r1, r1, #2031616	@ 0x1f0000
 8018caa:	e66e      	b.n	801898a <HAL_RCCEx_PeriphCLKConfig+0xe2>
    __HAL_RCC_PLLI2S_DISABLE();
 8018cac:	4f49      	ldr	r7, [pc, #292]	@ (8018dd4 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8018cae:	683b      	ldr	r3, [r7, #0]
 8018cb0:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 8018cb4:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8018cb6:	f7fe fffb 	bl	8017cb0 <HAL_GetTick>
 8018cba:	4680      	mov	r8, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8018cbc:	683b      	ldr	r3, [r7, #0]
 8018cbe:	011a      	lsls	r2, r3, #4
 8018cc0:	d473      	bmi.n	8018daa <HAL_RCCEx_PeriphCLKConfig+0x502>
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8018cc2:	6822      	ldr	r2, [r4, #0]
 8018cc4:	07d3      	lsls	r3, r2, #31
 8018cc6:	d512      	bpl.n	8018cee <HAL_RCCEx_PeriphCLKConfig+0x446>
 8018cc8:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8018cca:	b983      	cbnz	r3, 8018cee <HAL_RCCEx_PeriphCLKConfig+0x446>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8018ccc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8018cd0:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8018cd4:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8018cd8:	f001 6170 	and.w	r1, r1, #251658240	@ 0xf000000
 8018cdc:	430b      	orrs	r3, r1
 8018cde:	6861      	ldr	r1, [r4, #4]
 8018ce0:	ea43 1381 	orr.w	r3, r3, r1, lsl #6
 8018ce4:	68a1      	ldr	r1, [r4, #8]
 8018ce6:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
 8018cea:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8018cee:	0317      	lsls	r7, r2, #12
 8018cf0:	d503      	bpl.n	8018cfa <HAL_RCCEx_PeriphCLKConfig+0x452>
 8018cf2:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8018cf4:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8018cf8:	d005      	beq.n	8018d06 <HAL_RCCEx_PeriphCLKConfig+0x45e>
 8018cfa:	02d0      	lsls	r0, r2, #11
 8018cfc:	d51e      	bpl.n	8018d3c <HAL_RCCEx_PeriphCLKConfig+0x494>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 8018cfe:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8018d00:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8018d04:	d11a      	bne.n	8018d3c <HAL_RCCEx_PeriphCLKConfig+0x494>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8018d06:	4933      	ldr	r1, [pc, #204]	@ (8018dd4 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8018d08:	f8d1 3084 	ldr.w	r3, [r1, #132]	@ 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8018d0c:	f8d1 0084 	ldr.w	r0, [r1, #132]	@ 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8018d10:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8018d14:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
 8018d18:	4303      	orrs	r3, r0
 8018d1a:	6860      	ldr	r0, [r4, #4]
 8018d1c:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8018d20:	68e0      	ldr	r0, [r4, #12]
 8018d22:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8018d26:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 8018d2a:	f8d1 008c 	ldr.w	r0, [r1, #140]	@ 0x8c
 8018d2e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8018d30:	f020 001f 	bic.w	r0, r0, #31
 8018d34:	3b01      	subs	r3, #1
 8018d36:	4303      	orrs	r3, r0
 8018d38:	f8c1 308c 	str.w	r3, [r1, #140]	@ 0x8c
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8018d3c:	01d1      	lsls	r1, r2, #7
 8018d3e:	d511      	bpl.n	8018d64 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8018d40:	4924      	ldr	r1, [pc, #144]	@ (8018dd4 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8018d42:	f8d1 3084 	ldr.w	r3, [r1, #132]	@ 0x84
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8018d46:	f8d1 0084 	ldr.w	r0, [r1, #132]	@ 0x84
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 8018d4a:	f003 6370 	and.w	r3, r3, #251658240	@ 0xf000000
 8018d4e:	f000 40e0 	and.w	r0, r0, #1879048192	@ 0x70000000
 8018d52:	4303      	orrs	r3, r0
 8018d54:	6860      	ldr	r0, [r4, #4]
 8018d56:	ea43 1380 	orr.w	r3, r3, r0, lsl #6
 8018d5a:	6920      	ldr	r0, [r4, #16]
 8018d5c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8018d60:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 8018d64:	0192      	lsls	r2, r2, #6
 8018d66:	d50d      	bpl.n	8018d84 <HAL_RCCEx_PeriphCLKConfig+0x4dc>
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 8018d68:	6923      	ldr	r3, [r4, #16]
 8018d6a:	6862      	ldr	r2, [r4, #4]
 8018d6c:	041b      	lsls	r3, r3, #16
 8018d6e:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
 8018d72:	68e2      	ldr	r2, [r4, #12]
 8018d74:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8018d78:	68a2      	ldr	r2, [r4, #8]
 8018d7a:	ea43 7302 	orr.w	r3, r3, r2, lsl #28
 8018d7e:	4a15      	ldr	r2, [pc, #84]	@ (8018dd4 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8018d80:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
    __HAL_RCC_PLLI2S_ENABLE();
 8018d84:	4f13      	ldr	r7, [pc, #76]	@ (8018dd4 <HAL_RCCEx_PeriphCLKConfig+0x52c>)
 8018d86:	683b      	ldr	r3, [r7, #0]
 8018d88:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8018d8c:	603b      	str	r3, [r7, #0]
    tickstart = HAL_GetTick();
 8018d8e:	f7fe ff8f 	bl	8017cb0 <HAL_GetTick>
 8018d92:	4680      	mov	r8, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8018d94:	683b      	ldr	r3, [r7, #0]
 8018d96:	011b      	lsls	r3, r3, #4
 8018d98:	f53f aecc 	bmi.w	8018b34 <HAL_RCCEx_PeriphCLKConfig+0x28c>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8018d9c:	f7fe ff88 	bl	8017cb0 <HAL_GetTick>
 8018da0:	eba0 0008 	sub.w	r0, r0, r8
 8018da4:	2864      	cmp	r0, #100	@ 0x64
 8018da6:	d9f5      	bls.n	8018d94 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
 8018da8:	e74a      	b.n	8018c40 <HAL_RCCEx_PeriphCLKConfig+0x398>
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8018daa:	f7fe ff81 	bl	8017cb0 <HAL_GetTick>
 8018dae:	eba0 0008 	sub.w	r0, r0, r8
 8018db2:	2864      	cmp	r0, #100	@ 0x64
 8018db4:	d982      	bls.n	8018cbc <HAL_RCCEx_PeriphCLKConfig+0x414>
 8018db6:	e743      	b.n	8018c40 <HAL_RCCEx_PeriphCLKConfig+0x398>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8018db8:	f7fe ff7a 	bl	8017cb0 <HAL_GetTick>
 8018dbc:	1b80      	subs	r0, r0, r6
 8018dbe:	2864      	cmp	r0, #100	@ 0x64
 8018dc0:	f67f aec5 	bls.w	8018b4e <HAL_RCCEx_PeriphCLKConfig+0x2a6>
 8018dc4:	e73c      	b.n	8018c40 <HAL_RCCEx_PeriphCLKConfig+0x398>
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8018dc6:	f7fe ff73 	bl	8017cb0 <HAL_GetTick>
 8018dca:	1b40      	subs	r0, r0, r5
 8018dcc:	2864      	cmp	r0, #100	@ 0x64
 8018dce:	f67f af28 	bls.w	8018c22 <HAL_RCCEx_PeriphCLKConfig+0x37a>
 8018dd2:	e735      	b.n	8018c40 <HAL_RCCEx_PeriphCLKConfig+0x398>
 8018dd4:	40023800 	.word	0x40023800

08018dd8 <HAL_RTC_WaitForSynchro>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 8018dd8:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U;

  /* Clear RSF flag, keep reserved bits at reset values (setting other flags has no effect) */
  hrtc->Instance->ISR = ((uint32_t)(RTC_RSF_MASK & RTC_ISR_RESERVED_MASK));
 8018dda:	4a0a      	ldr	r2, [pc, #40]	@ (8018e04 <HAL_RTC_WaitForSynchro+0x2c>)
{
 8018ddc:	4604      	mov	r4, r0
  hrtc->Instance->ISR = ((uint32_t)(RTC_RSF_MASK & RTC_ISR_RESERVED_MASK));
 8018dde:	6803      	ldr	r3, [r0, #0]
 8018de0:	60da      	str	r2, [r3, #12]

  /* Get tick */
  tickstart = HAL_GetTick();
 8018de2:	f7fe ff65 	bl	8017cb0 <HAL_GetTick>
 8018de6:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 8018de8:	6823      	ldr	r3, [r4, #0]
 8018dea:	68db      	ldr	r3, [r3, #12]
 8018dec:	069b      	lsls	r3, r3, #26
 8018dee:	d501      	bpl.n	8018df4 <HAL_RTC_WaitForSynchro+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 8018df0:	2000      	movs	r0, #0
}
 8018df2:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8018df4:	f7fe ff5c 	bl	8017cb0 <HAL_GetTick>
 8018df8:	1b40      	subs	r0, r0, r5
 8018dfa:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8018dfe:	d9f3      	bls.n	8018de8 <HAL_RTC_WaitForSynchro+0x10>
      return HAL_TIMEOUT;
 8018e00:	2003      	movs	r0, #3
 8018e02:	e7f6      	b.n	8018df2 <HAL_RTC_WaitForSynchro+0x1a>
 8018e04:	0001ff5f 	.word	0x0001ff5f

08018e08 <RTC_EnterInitMode>:
{
  uint32_t tickstart = 0U;
  HAL_StatusTypeDef status = HAL_OK;

  /* Check that Initialization mode is not already set */
  if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
 8018e08:	6803      	ldr	r3, [r0, #0]
{
 8018e0a:	b570      	push	{r4, r5, r6, lr}
  if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
 8018e0c:	68dc      	ldr	r4, [r3, #12]
{
 8018e0e:	4605      	mov	r5, r0
  if (READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U)
 8018e10:	f014 0440 	ands.w	r4, r4, #64	@ 0x40
 8018e14:	d117      	bne.n	8018e46 <RTC_EnterInitMode+0x3e>
  {
    /* Set INIT bit to enter Initialization mode */
    SET_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 8018e16:	68da      	ldr	r2, [r3, #12]
 8018e18:	f042 0280 	orr.w	r2, r2, #128	@ 0x80
 8018e1c:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8018e1e:	f7fe ff47 	bl	8017cb0 <HAL_GetTick>
 8018e22:	4606      	mov	r6, r0

    /* Wait till RTC is in INIT state and if timeout is reached exit */
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_ERROR))
 8018e24:	682b      	ldr	r3, [r5, #0]
 8018e26:	68db      	ldr	r3, [r3, #12]
 8018e28:	065b      	lsls	r3, r3, #25
 8018e2a:	d400      	bmi.n	8018e2e <RTC_EnterInitMode+0x26>
 8018e2c:	b10c      	cbz	r4, 8018e32 <RTC_EnterInitMode+0x2a>
      }
    }
  }

  return status;
}
 8018e2e:	4620      	mov	r0, r4
 8018e30:	bd70      	pop	{r4, r5, r6, pc}
      if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8018e32:	f7fe ff3d 	bl	8017cb0 <HAL_GetTick>
 8018e36:	1b80      	subs	r0, r0, r6
 8018e38:	f5b0 7f7a 	cmp.w	r0, #1000	@ 0x3e8
 8018e3c:	d9f2      	bls.n	8018e24 <RTC_EnterInitMode+0x1c>
        hrtc->State = HAL_RTC_STATE_ERROR;
 8018e3e:	2304      	movs	r3, #4
        status = HAL_ERROR;
 8018e40:	2401      	movs	r4, #1
        hrtc->State = HAL_RTC_STATE_ERROR;
 8018e42:	776b      	strb	r3, [r5, #29]
        status = HAL_ERROR;
 8018e44:	e7ee      	b.n	8018e24 <RTC_EnterInitMode+0x1c>
  HAL_StatusTypeDef status = HAL_OK;
 8018e46:	2400      	movs	r4, #0
 8018e48:	e7f1      	b.n	8018e2e <RTC_EnterInitMode+0x26>

08018e4a <RTC_ExitInitMode>:
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Clear INIT bit to exit Initialization mode */
  CLEAR_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 8018e4a:	6803      	ldr	r3, [r0, #0]
 8018e4c:	68da      	ldr	r2, [r3, #12]
 8018e4e:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
{
 8018e52:	b510      	push	{r4, lr}
  CLEAR_BIT(hrtc->Instance->ISR, RTC_ISR_INIT);
 8018e54:	60da      	str	r2, [r3, #12]
{
 8018e56:	4604      	mov	r4, r0

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(hrtc->Instance->CR, RTC_CR_BYPSHAD) == 0U)
 8018e58:	689b      	ldr	r3, [r3, #8]
 8018e5a:	069b      	lsls	r3, r3, #26
 8018e5c:	d501      	bpl.n	8018e62 <RTC_ExitInitMode+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 8018e5e:	2000      	movs	r0, #0
      status = HAL_ERROR;
    }
  }

  return status;
}
 8018e60:	bd10      	pop	{r4, pc}
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8018e62:	f7ff ffb9 	bl	8018dd8 <HAL_RTC_WaitForSynchro>
 8018e66:	2800      	cmp	r0, #0
 8018e68:	d0f9      	beq.n	8018e5e <RTC_ExitInitMode+0x14>
      hrtc->State = HAL_RTC_STATE_ERROR;
 8018e6a:	2304      	movs	r3, #4
      status = HAL_ERROR;
 8018e6c:	2001      	movs	r0, #1
      hrtc->State = HAL_RTC_STATE_ERROR;
 8018e6e:	7763      	strb	r3, [r4, #29]
      status = HAL_ERROR;
 8018e70:	e7f6      	b.n	8018e60 <RTC_ExitInitMode+0x16>

08018e72 <HAL_RTC_Init>:
{
 8018e72:	b510      	push	{r4, lr}
  if (hrtc == NULL)
 8018e74:	4604      	mov	r4, r0
 8018e76:	b908      	cbnz	r0, 8018e7c <HAL_RTC_Init+0xa>
    return HAL_ERROR;
 8018e78:	2001      	movs	r0, #1
}
 8018e7a:	bd10      	pop	{r4, pc}
  if (hrtc->State == HAL_RTC_STATE_RESET)
 8018e7c:	7f43      	ldrb	r3, [r0, #29]
 8018e7e:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8018e82:	b913      	cbnz	r3, 8018e8a <HAL_RTC_Init+0x18>
    hrtc->Lock = HAL_UNLOCKED;
 8018e84:	7702      	strb	r2, [r0, #28]
    HAL_RTC_MspInit(hrtc);
 8018e86:	f7fe fcf1 	bl	801786c <HAL_RTC_MspInit>
  hrtc->State = HAL_RTC_STATE_BUSY;
 8018e8a:	2302      	movs	r3, #2
 8018e8c:	7763      	strb	r3, [r4, #29]
  if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 8018e8e:	6823      	ldr	r3, [r4, #0]
 8018e90:	68da      	ldr	r2, [r3, #12]
 8018e92:	06d2      	lsls	r2, r2, #27
 8018e94:	d503      	bpl.n	8018e9e <HAL_RTC_Init+0x2c>
    hrtc->State = HAL_RTC_STATE_READY;
 8018e96:	2301      	movs	r3, #1
 8018e98:	2000      	movs	r0, #0
 8018e9a:	7763      	strb	r3, [r4, #29]
 8018e9c:	e7ed      	b.n	8018e7a <HAL_RTC_Init+0x8>
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8018e9e:	22ca      	movs	r2, #202	@ 0xca
    status = RTC_EnterInitMode(hrtc);
 8018ea0:	4620      	mov	r0, r4
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8018ea2:	625a      	str	r2, [r3, #36]	@ 0x24
 8018ea4:	2253      	movs	r2, #83	@ 0x53
 8018ea6:	625a      	str	r2, [r3, #36]	@ 0x24
    status = RTC_EnterInitMode(hrtc);
 8018ea8:	f7ff ffae 	bl	8018e08 <RTC_EnterInitMode>
    if (status == HAL_OK)
 8018eac:	b130      	cbz	r0, 8018ebc <HAL_RTC_Init+0x4a>
{
 8018eae:	2001      	movs	r0, #1
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8018eb0:	6823      	ldr	r3, [r4, #0]
 8018eb2:	22ff      	movs	r2, #255	@ 0xff
 8018eb4:	625a      	str	r2, [r3, #36]	@ 0x24
  if (status == HAL_OK)
 8018eb6:	2800      	cmp	r0, #0
 8018eb8:	d0ed      	beq.n	8018e96 <HAL_RTC_Init+0x24>
 8018eba:	e7dd      	b.n	8018e78 <HAL_RTC_Init+0x6>
      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8018ebc:	6823      	ldr	r3, [r4, #0]
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8018ebe:	6920      	ldr	r0, [r4, #16]
      hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8018ec0:	689a      	ldr	r2, [r3, #8]
 8018ec2:	f422 02e0 	bic.w	r2, r2, #7340032	@ 0x700000
 8018ec6:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8018eca:	609a      	str	r2, [r3, #8]
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8018ecc:	6862      	ldr	r2, [r4, #4]
 8018ece:	6899      	ldr	r1, [r3, #8]
 8018ed0:	4302      	orrs	r2, r0
 8018ed2:	6960      	ldr	r0, [r4, #20]
 8018ed4:	4302      	orrs	r2, r0
      status = RTC_ExitInitMode(hrtc);
 8018ed6:	4620      	mov	r0, r4
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8018ed8:	430a      	orrs	r2, r1
      hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 8018eda:	68a1      	ldr	r1, [r4, #8]
      hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8018edc:	609a      	str	r2, [r3, #8]
      hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8018ede:	68e2      	ldr	r2, [r4, #12]
 8018ee0:	611a      	str	r2, [r3, #16]
      hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 8018ee2:	691a      	ldr	r2, [r3, #16]
 8018ee4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8018ee8:	611a      	str	r2, [r3, #16]
      status = RTC_ExitInitMode(hrtc);
 8018eea:	f7ff ffae 	bl	8018e4a <RTC_ExitInitMode>
    if (status == HAL_OK)
 8018eee:	2800      	cmp	r0, #0
 8018ef0:	d1dd      	bne.n	8018eae <HAL_RTC_Init+0x3c>
      hrtc->Instance->OR &= (uint32_t)~RTC_OUTPUT_TYPE_PUSHPULL;
 8018ef2:	6823      	ldr	r3, [r4, #0]
      hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType);
 8018ef4:	69a1      	ldr	r1, [r4, #24]
      hrtc->Instance->OR &= (uint32_t)~RTC_OUTPUT_TYPE_PUSHPULL;
 8018ef6:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8018ef8:	f022 0208 	bic.w	r2, r2, #8
 8018efc:	64da      	str	r2, [r3, #76]	@ 0x4c
      hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType);
 8018efe:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8018f00:	430a      	orrs	r2, r1
 8018f02:	64da      	str	r2, [r3, #76]	@ 0x4c
 8018f04:	e7d4      	b.n	8018eb0 <HAL_RTC_Init+0x3e>

08018f06 <HAL_RTCEx_BKUPWrite>:
  uint32_t tmp = 0U;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) &(hrtc->Instance->BKP0R);
 8018f06:	6803      	ldr	r3, [r0, #0]
 8018f08:	3350      	adds	r3, #80	@ 0x50
  tmp += (BackupRegister * 4U);

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8018f0a:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
}
 8018f0e:	4770      	bx	lr

08018f10 <HAL_RTCEx_BKUPRead>:
  uint32_t tmp = 0U;

  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) &(hrtc->Instance->BKP0R);
 8018f10:	6803      	ldr	r3, [r0, #0]
 8018f12:	3350      	adds	r3, #80	@ 0x50
  tmp += (BackupRegister * 4U);

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8018f14:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
}
 8018f18:	4770      	bx	lr

08018f1a <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8018f1a:	6802      	ldr	r2, [r0, #0]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8018f1c:	e852 3f00 	ldrex	r3, [r2]
 8018f20:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8018f24:	e842 3100 	strex	r1, r3, [r2]
   return(result);
 8018f28:	6802      	ldr	r2, [r0, #0]
 8018f2a:	2900      	cmp	r1, #0
 8018f2c:	d1f5      	bne.n	8018f1a <UART_EndRxTransfer>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8018f2e:	f102 0308 	add.w	r3, r2, #8
 8018f32:	e853 3f00 	ldrex	r3, [r3]
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8018f36:	f023 0301 	bic.w	r3, r3, #1
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8018f3a:	f102 0c08 	add.w	ip, r2, #8
 8018f3e:	e84c 3100 	strex	r1, r3, [ip]
 8018f42:	2900      	cmp	r1, #0
 8018f44:	d1f3      	bne.n	8018f2e <UART_EndRxTransfer+0x14>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8018f46:	6e03      	ldr	r3, [r0, #96]	@ 0x60
 8018f48:	2b01      	cmp	r3, #1
 8018f4a:	d107      	bne.n	8018f5c <UART_EndRxTransfer+0x42>
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8018f4c:	e852 3f00 	ldrex	r3, [r2]
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8018f50:	f023 0310 	bic.w	r3, r3, #16
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8018f54:	e842 3100 	strex	r1, r3, [r2]
 8018f58:	2900      	cmp	r1, #0
 8018f5a:	d1f7      	bne.n	8018f4c <UART_EndRxTransfer+0x32>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8018f5c:	2320      	movs	r3, #32
 8018f5e:	f8c0 3080 	str.w	r3, [r0, #128]	@ 0x80
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8018f62:	2300      	movs	r3, #0
 8018f64:	6603      	str	r3, [r0, #96]	@ 0x60

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8018f66:	6683      	str	r3, [r0, #104]	@ 0x68
}
 8018f68:	4770      	bx	lr
	...

08018f6c <UART_SetConfig>:
{
 8018f6c:	b538      	push	{r3, r4, r5, lr}
 8018f6e:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8018f70:	69c0      	ldr	r0, [r0, #28]
 8018f72:	6921      	ldr	r1, [r4, #16]
 8018f74:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8018f76:	6823      	ldr	r3, [r4, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8018f78:	430a      	orrs	r2, r1
 8018f7a:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8018f7c:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8018f7e:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8018f80:	496e      	ldr	r1, [pc, #440]	@ (801913c <UART_SetConfig+0x1d0>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8018f82:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8018f84:	4029      	ands	r1, r5
  tmpreg |= huart->Init.OneBitSampling;
 8018f86:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8018f88:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8018f8a:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8018f8c:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8018f8e:	685a      	ldr	r2, [r3, #4]
 8018f90:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 8018f94:	430a      	orrs	r2, r1
 8018f96:	605a      	str	r2, [r3, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8018f98:	69a2      	ldr	r2, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8018f9a:	6899      	ldr	r1, [r3, #8]
  tmpreg |= huart->Init.OneBitSampling;
 8018f9c:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8018f9e:	f421 6130 	bic.w	r1, r1, #2816	@ 0xb00
 8018fa2:	430a      	orrs	r2, r1
 8018fa4:	609a      	str	r2, [r3, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 8018fa6:	4a66      	ldr	r2, [pc, #408]	@ (8019140 <UART_SetConfig+0x1d4>)
 8018fa8:	4293      	cmp	r3, r2
 8018faa:	d113      	bne.n	8018fd4 <UART_SetConfig+0x68>
 8018fac:	4b65      	ldr	r3, [pc, #404]	@ (8019144 <UART_SetConfig+0x1d8>)
 8018fae:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8018fb2:	f003 0303 	and.w	r3, r3, #3
 8018fb6:	2b02      	cmp	r3, #2
 8018fb8:	f000 80a5 	beq.w	8019106 <UART_SetConfig+0x19a>
 8018fbc:	2b03      	cmp	r3, #3
 8018fbe:	f000 809c 	beq.w	80190fa <UART_SetConfig+0x18e>
 8018fc2:	2b01      	cmp	r3, #1
 8018fc4:	d067      	beq.n	8019096 <UART_SetConfig+0x12a>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8018fc6:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8018fca:	f000 8090 	beq.w	80190ee <UART_SetConfig+0x182>
        pclk = HAL_RCC_GetPCLK2Freq();
 8018fce:	f7ff fc5b 	bl	8018888 <HAL_RCC_GetPCLK2Freq>
        break;
 8018fd2:	e012      	b.n	8018ffa <UART_SetConfig+0x8e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8018fd4:	4a5c      	ldr	r2, [pc, #368]	@ (8019148 <UART_SetConfig+0x1dc>)
 8018fd6:	4293      	cmp	r3, r2
 8018fd8:	d126      	bne.n	8019028 <UART_SetConfig+0xbc>
 8018fda:	4b5a      	ldr	r3, [pc, #360]	@ (8019144 <UART_SetConfig+0x1d8>)
 8018fdc:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8018fe0:	f003 030c 	and.w	r3, r3, #12
 8018fe4:	2b08      	cmp	r3, #8
 8018fe6:	f000 808e 	beq.w	8019106 <UART_SetConfig+0x19a>
 8018fea:	d816      	bhi.n	801901a <UART_SetConfig+0xae>
 8018fec:	2b00      	cmp	r3, #0
 8018fee:	d152      	bne.n	8019096 <UART_SetConfig+0x12a>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8018ff0:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 8018ff4:	d076      	beq.n	80190e4 <UART_SetConfig+0x178>
        pclk = HAL_RCC_GetPCLK1Freq();
 8018ff6:	f7ff fc37 	bl	8018868 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 8018ffa:	2800      	cmp	r0, #0
 8018ffc:	d075      	beq.n	80190ea <UART_SetConfig+0x17e>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 8018ffe:	6863      	ldr	r3, [r4, #4]
 8019000:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 8019004:	fbb0 f0f3 	udiv	r0, r0, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8019008:	f64f 73ef 	movw	r3, #65519	@ 0xffef
 801900c:	f1a0 0210 	sub.w	r2, r0, #16
 8019010:	429a      	cmp	r2, r3
 8019012:	d804      	bhi.n	801901e <UART_SetConfig+0xb2>
        huart->Instance->BRR = (uint16_t)usartdiv;
 8019014:	6823      	ldr	r3, [r4, #0]
 8019016:	60d8      	str	r0, [r3, #12]
 8019018:	e067      	b.n	80190ea <UART_SetConfig+0x17e>
  UART_GETCLOCKSOURCE(huart, clocksource);
 801901a:	2b0c      	cmp	r3, #12
 801901c:	d06d      	beq.n	80190fa <UART_SetConfig+0x18e>
        ret = HAL_ERROR;
 801901e:	2001      	movs	r0, #1
  huart->RxISR = NULL;
 8019020:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 8019022:	e9c4 331a 	strd	r3, r3, [r4, #104]	@ 0x68
}
 8019026:	bd38      	pop	{r3, r4, r5, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 8019028:	4a48      	ldr	r2, [pc, #288]	@ (801914c <UART_SetConfig+0x1e0>)
 801902a:	4293      	cmp	r3, r2
 801902c:	d109      	bne.n	8019042 <UART_SetConfig+0xd6>
 801902e:	4b45      	ldr	r3, [pc, #276]	@ (8019144 <UART_SetConfig+0x1d8>)
 8019030:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8019034:	f003 0330 	and.w	r3, r3, #48	@ 0x30
 8019038:	2b20      	cmp	r3, #32
 801903a:	d064      	beq.n	8019106 <UART_SetConfig+0x19a>
 801903c:	d9d6      	bls.n	8018fec <UART_SetConfig+0x80>
 801903e:	2b30      	cmp	r3, #48	@ 0x30
 8019040:	e7ec      	b.n	801901c <UART_SetConfig+0xb0>
 8019042:	4a43      	ldr	r2, [pc, #268]	@ (8019150 <UART_SetConfig+0x1e4>)
 8019044:	4293      	cmp	r3, r2
 8019046:	d109      	bne.n	801905c <UART_SetConfig+0xf0>
 8019048:	4b3e      	ldr	r3, [pc, #248]	@ (8019144 <UART_SetConfig+0x1d8>)
 801904a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801904e:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 8019052:	2b80      	cmp	r3, #128	@ 0x80
 8019054:	d057      	beq.n	8019106 <UART_SetConfig+0x19a>
 8019056:	d9c9      	bls.n	8018fec <UART_SetConfig+0x80>
 8019058:	2bc0      	cmp	r3, #192	@ 0xc0
 801905a:	e7df      	b.n	801901c <UART_SetConfig+0xb0>
 801905c:	4a3d      	ldr	r2, [pc, #244]	@ (8019154 <UART_SetConfig+0x1e8>)
 801905e:	4293      	cmp	r3, r2
 8019060:	d10b      	bne.n	801907a <UART_SetConfig+0x10e>
 8019062:	4b38      	ldr	r3, [pc, #224]	@ (8019144 <UART_SetConfig+0x1d8>)
 8019064:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8019068:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 801906c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8019070:	d049      	beq.n	8019106 <UART_SetConfig+0x19a>
 8019072:	d9bb      	bls.n	8018fec <UART_SetConfig+0x80>
 8019074:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8019078:	e7d0      	b.n	801901c <UART_SetConfig+0xb0>
 801907a:	4a37      	ldr	r2, [pc, #220]	@ (8019158 <UART_SetConfig+0x1ec>)
 801907c:	4293      	cmp	r3, r2
 801907e:	d113      	bne.n	80190a8 <UART_SetConfig+0x13c>
 8019080:	4b30      	ldr	r3, [pc, #192]	@ (8019144 <UART_SetConfig+0x1d8>)
 8019082:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8019086:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 801908a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 801908e:	d03a      	beq.n	8019106 <UART_SetConfig+0x19a>
 8019090:	d807      	bhi.n	80190a2 <UART_SetConfig+0x136>
 8019092:	2b00      	cmp	r3, #0
 8019094:	d097      	beq.n	8018fc6 <UART_SetConfig+0x5a>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8019096:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 801909a:	d12b      	bne.n	80190f4 <UART_SetConfig+0x188>
        pclk = HAL_RCC_GetSysClockFreq();
 801909c:	f7ff fb18 	bl	80186d0 <HAL_RCC_GetSysClockFreq>
        break;
 80190a0:	e022      	b.n	80190e8 <UART_SetConfig+0x17c>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80190a2:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 80190a6:	e7b9      	b.n	801901c <UART_SetConfig+0xb0>
 80190a8:	4a2c      	ldr	r2, [pc, #176]	@ (801915c <UART_SetConfig+0x1f0>)
 80190aa:	4293      	cmp	r3, r2
 80190ac:	d10b      	bne.n	80190c6 <UART_SetConfig+0x15a>
 80190ae:	4b25      	ldr	r3, [pc, #148]	@ (8019144 <UART_SetConfig+0x1d8>)
 80190b0:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80190b4:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
 80190b8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80190bc:	d023      	beq.n	8019106 <UART_SetConfig+0x19a>
 80190be:	d995      	bls.n	8018fec <UART_SetConfig+0x80>
 80190c0:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 80190c4:	e7aa      	b.n	801901c <UART_SetConfig+0xb0>
 80190c6:	4a26      	ldr	r2, [pc, #152]	@ (8019160 <UART_SetConfig+0x1f4>)
 80190c8:	4293      	cmp	r3, r2
 80190ca:	d1a8      	bne.n	801901e <UART_SetConfig+0xb2>
 80190cc:	4b1d      	ldr	r3, [pc, #116]	@ (8019144 <UART_SetConfig+0x1d8>)
 80190ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 80190d2:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 80190d6:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80190da:	d014      	beq.n	8019106 <UART_SetConfig+0x19a>
 80190dc:	d986      	bls.n	8018fec <UART_SetConfig+0x80>
 80190de:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 80190e2:	e79b      	b.n	801901c <UART_SetConfig+0xb0>
        pclk = HAL_RCC_GetPCLK1Freq();
 80190e4:	f7ff fbc0 	bl	8018868 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 80190e8:	b990      	cbnz	r0, 8019110 <UART_SetConfig+0x1a4>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80190ea:	2000      	movs	r0, #0
 80190ec:	e798      	b.n	8019020 <UART_SetConfig+0xb4>
        pclk = HAL_RCC_GetPCLK2Freq();
 80190ee:	f7ff fbcb 	bl	8018888 <HAL_RCC_GetPCLK2Freq>
        break;
 80190f2:	e7f9      	b.n	80190e8 <UART_SetConfig+0x17c>
        pclk = HAL_RCC_GetSysClockFreq();
 80190f4:	f7ff faec 	bl	80186d0 <HAL_RCC_GetSysClockFreq>
        break;
 80190f8:	e77f      	b.n	8018ffa <UART_SetConfig+0x8e>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80190fa:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
 80190fe:	d007      	beq.n	8019110 <UART_SetConfig+0x1a4>
        pclk = (uint32_t) LSE_VALUE;
 8019100:	f44f 4000 	mov.w	r0, #32768	@ 0x8000
 8019104:	e77b      	b.n	8018ffe <UART_SetConfig+0x92>
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8019106:	f5b0 4f00 	cmp.w	r0, #32768	@ 0x8000
        pclk = (uint32_t) HSI_VALUE;
 801910a:	4816      	ldr	r0, [pc, #88]	@ (8019164 <UART_SetConfig+0x1f8>)
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 801910c:	f47f af77 	bne.w	8018ffe <UART_SetConfig+0x92>
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 8019110:	6862      	ldr	r2, [r4, #4]
 8019112:	0853      	lsrs	r3, r2, #1
 8019114:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 8019118:	fbb3 f3f2 	udiv	r3, r3, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 801911c:	f64f 72ef 	movw	r2, #65519	@ 0xffef
 8019120:	f1a3 0110 	sub.w	r1, r3, #16
 8019124:	4291      	cmp	r1, r2
 8019126:	f63f af7a 	bhi.w	801901e <UART_SetConfig+0xb2>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 801912a:	f023 020f 	bic.w	r2, r3, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 801912e:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 8019132:	6821      	ldr	r1, [r4, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8019134:	4313      	orrs	r3, r2
        huart->Instance->BRR = brrtemp;
 8019136:	b29b      	uxth	r3, r3
 8019138:	60cb      	str	r3, [r1, #12]
 801913a:	e7d6      	b.n	80190ea <UART_SetConfig+0x17e>
 801913c:	efff69f3 	.word	0xefff69f3
 8019140:	40011000 	.word	0x40011000
 8019144:	40023800 	.word	0x40023800
 8019148:	40004400 	.word	0x40004400
 801914c:	40004800 	.word	0x40004800
 8019150:	40004c00 	.word	0x40004c00
 8019154:	40005000 	.word	0x40005000
 8019158:	40011400 	.word	0x40011400
 801915c:	40007800 	.word	0x40007800
 8019160:	40007c00 	.word	0x40007c00
 8019164:	00f42400 	.word	0x00f42400

08019168 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8019168:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 801916a:	071a      	lsls	r2, r3, #28
{
 801916c:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 801916e:	d506      	bpl.n	801917e <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8019170:	6801      	ldr	r1, [r0, #0]
 8019172:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 8019174:	684a      	ldr	r2, [r1, #4]
 8019176:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 801917a:	4322      	orrs	r2, r4
 801917c:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 801917e:	07dc      	lsls	r4, r3, #31
 8019180:	d506      	bpl.n	8019190 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8019182:	6801      	ldr	r1, [r0, #0]
 8019184:	6a84      	ldr	r4, [r0, #40]	@ 0x28
 8019186:	684a      	ldr	r2, [r1, #4]
 8019188:	f422 3200 	bic.w	r2, r2, #131072	@ 0x20000
 801918c:	4322      	orrs	r2, r4
 801918e:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8019190:	0799      	lsls	r1, r3, #30
 8019192:	d506      	bpl.n	80191a2 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8019194:	6801      	ldr	r1, [r0, #0]
 8019196:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 8019198:	684a      	ldr	r2, [r1, #4]
 801919a:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 801919e:	4322      	orrs	r2, r4
 80191a0:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80191a2:	075a      	lsls	r2, r3, #29
 80191a4:	d506      	bpl.n	80191b4 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80191a6:	6801      	ldr	r1, [r0, #0]
 80191a8:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 80191aa:	684a      	ldr	r2, [r1, #4]
 80191ac:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 80191b0:	4322      	orrs	r2, r4
 80191b2:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80191b4:	06dc      	lsls	r4, r3, #27
 80191b6:	d506      	bpl.n	80191c6 <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80191b8:	6801      	ldr	r1, [r0, #0]
 80191ba:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 80191bc:	688a      	ldr	r2, [r1, #8]
 80191be:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 80191c2:	4322      	orrs	r2, r4
 80191c4:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80191c6:	0699      	lsls	r1, r3, #26
 80191c8:	d506      	bpl.n	80191d8 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80191ca:	6801      	ldr	r1, [r0, #0]
 80191cc:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 80191ce:	688a      	ldr	r2, [r1, #8]
 80191d0:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 80191d4:	4322      	orrs	r2, r4
 80191d6:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80191d8:	065a      	lsls	r2, r3, #25
 80191da:	d510      	bpl.n	80191fe <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80191dc:	6801      	ldr	r1, [r0, #0]
 80191de:	6c04      	ldr	r4, [r0, #64]	@ 0x40
 80191e0:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80191e2:	f5b4 1f80 	cmp.w	r4, #1048576	@ 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80191e6:	f422 1280 	bic.w	r2, r2, #1048576	@ 0x100000
 80191ea:	ea42 0204 	orr.w	r2, r2, r4
 80191ee:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80191f0:	d105      	bne.n	80191fe <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80191f2:	684a      	ldr	r2, [r1, #4]
 80191f4:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 80191f6:	f422 02c0 	bic.w	r2, r2, #6291456	@ 0x600000
 80191fa:	4322      	orrs	r2, r4
 80191fc:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80191fe:	061b      	lsls	r3, r3, #24
 8019200:	d506      	bpl.n	8019210 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8019202:	6802      	ldr	r2, [r0, #0]
 8019204:	6c81      	ldr	r1, [r0, #72]	@ 0x48
 8019206:	6853      	ldr	r3, [r2, #4]
 8019208:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 801920c:	430b      	orrs	r3, r1
 801920e:	6053      	str	r3, [r2, #4]
}
 8019210:	bd10      	pop	{r4, pc}

08019212 <UART_WaitOnFlagUntilTimeout>:
{
 8019212:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8019216:	9f08      	ldr	r7, [sp, #32]
 8019218:	4604      	mov	r4, r0
 801921a:	460e      	mov	r6, r1
 801921c:	4690      	mov	r8, r2
 801921e:	4699      	mov	r9, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8019220:	6822      	ldr	r2, [r4, #0]
 8019222:	69d3      	ldr	r3, [r2, #28]
 8019224:	ea36 0303 	bics.w	r3, r6, r3
 8019228:	bf0c      	ite	eq
 801922a:	2301      	moveq	r3, #1
 801922c:	2300      	movne	r3, #0
 801922e:	4543      	cmp	r3, r8
 8019230:	d001      	beq.n	8019236 <UART_WaitOnFlagUntilTimeout+0x24>
  return HAL_OK;
 8019232:	2000      	movs	r0, #0
 8019234:	e01f      	b.n	8019276 <UART_WaitOnFlagUntilTimeout+0x64>
    if (Timeout != HAL_MAX_DELAY)
 8019236:	1c79      	adds	r1, r7, #1
 8019238:	d0f3      	beq.n	8019222 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 801923a:	f7fe fd39 	bl	8017cb0 <HAL_GetTick>
 801923e:	eba0 0009 	sub.w	r0, r0, r9
 8019242:	42b8      	cmp	r0, r7
 8019244:	d827      	bhi.n	8019296 <UART_WaitOnFlagUntilTimeout+0x84>
 8019246:	b337      	cbz	r7, 8019296 <UART_WaitOnFlagUntilTimeout+0x84>
      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 8019248:	6820      	ldr	r0, [r4, #0]
 801924a:	6803      	ldr	r3, [r0, #0]
 801924c:	075a      	lsls	r2, r3, #29
 801924e:	d5e7      	bpl.n	8019220 <UART_WaitOnFlagUntilTimeout+0xe>
 8019250:	2e80      	cmp	r6, #128	@ 0x80
 8019252:	d0e5      	beq.n	8019220 <UART_WaitOnFlagUntilTimeout+0xe>
 8019254:	2e40      	cmp	r6, #64	@ 0x40
 8019256:	d0e3      	beq.n	8019220 <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 8019258:	69c5      	ldr	r5, [r0, #28]
 801925a:	f015 0508 	ands.w	r5, r5, #8
 801925e:	d00c      	beq.n	801927a <UART_WaitOnFlagUntilTimeout+0x68>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 8019260:	2508      	movs	r5, #8
 8019262:	6205      	str	r5, [r0, #32]
          UART_EndRxTransfer(huart);
 8019264:	4620      	mov	r0, r4
 8019266:	f7ff fe58 	bl	8018f1a <UART_EndRxTransfer>
          __HAL_UNLOCK(huart);
 801926a:	2300      	movs	r3, #0
          return HAL_ERROR;
 801926c:	2001      	movs	r0, #1
          huart->ErrorCode = HAL_UART_ERROR_ORE;
 801926e:	f8c4 5084 	str.w	r5, [r4, #132]	@ 0x84
          __HAL_UNLOCK(huart);
 8019272:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
}
 8019276:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 801927a:	69c3      	ldr	r3, [r0, #28]
 801927c:	051b      	lsls	r3, r3, #20
 801927e:	d5cf      	bpl.n	8019220 <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8019280:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8019284:	6203      	str	r3, [r0, #32]
          UART_EndRxTransfer(huart);
 8019286:	4620      	mov	r0, r4
 8019288:	f7ff fe47 	bl	8018f1a <UART_EndRxTransfer>
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 801928c:	2320      	movs	r3, #32
          __HAL_UNLOCK(huart);
 801928e:	f884 5078 	strb.w	r5, [r4, #120]	@ 0x78
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8019292:	f8c4 3084 	str.w	r3, [r4, #132]	@ 0x84
        return HAL_TIMEOUT;
 8019296:	2003      	movs	r0, #3
 8019298:	e7ed      	b.n	8019276 <UART_WaitOnFlagUntilTimeout+0x64>

0801929a <HAL_UART_Transmit>:
{
 801929a:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 801929e:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 80192a0:	6fc3      	ldr	r3, [r0, #124]	@ 0x7c
{
 80192a2:	4604      	mov	r4, r0
 80192a4:	460e      	mov	r6, r1
  if (huart->gState == HAL_UART_STATE_READY)
 80192a6:	2b20      	cmp	r3, #32
{
 80192a8:	4617      	mov	r7, r2
  if (huart->gState == HAL_UART_STATE_READY)
 80192aa:	d142      	bne.n	8019332 <HAL_UART_Transmit+0x98>
    if ((pData == NULL) || (Size == 0U))
 80192ac:	2900      	cmp	r1, #0
 80192ae:	d042      	beq.n	8019336 <HAL_UART_Transmit+0x9c>
 80192b0:	2a00      	cmp	r2, #0
 80192b2:	d040      	beq.n	8019336 <HAL_UART_Transmit+0x9c>
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80192b4:	2321      	movs	r3, #33	@ 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80192b6:	2500      	movs	r5, #0
 80192b8:	f8c0 5084 	str.w	r5, [r0, #132]	@ 0x84
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80192bc:	67c3      	str	r3, [r0, #124]	@ 0x7c
    tickstart = HAL_GetTick();
 80192be:	f7fe fcf7 	bl	8017cb0 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80192c2:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 80192c4:	4681      	mov	r9, r0
    huart->TxXferSize  = Size;
 80192c6:	f8a4 7050 	strh.w	r7, [r4, #80]	@ 0x50
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80192ca:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
    huart->TxXferCount = Size;
 80192ce:	f8a4 7052 	strh.w	r7, [r4, #82]	@ 0x52
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80192d2:	d103      	bne.n	80192dc <HAL_UART_Transmit+0x42>
 80192d4:	6923      	ldr	r3, [r4, #16]
 80192d6:	b90b      	cbnz	r3, 80192dc <HAL_UART_Transmit+0x42>
      pdata16bits = (const uint16_t *) pData;
 80192d8:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 80192da:	461e      	mov	r6, r3
    while (huart->TxXferCount > 0U)
 80192dc:	f8b4 2052 	ldrh.w	r2, [r4, #82]	@ 0x52
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80192e0:	464b      	mov	r3, r9
 80192e2:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 80192e6:	b292      	uxth	r2, r2
 80192e8:	b93a      	cbnz	r2, 80192fa <HAL_UART_Transmit+0x60>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80192ea:	2140      	movs	r1, #64	@ 0x40
 80192ec:	4620      	mov	r0, r4
 80192ee:	f7ff ff90 	bl	8019212 <UART_WaitOnFlagUntilTimeout>
 80192f2:	2320      	movs	r3, #32
 80192f4:	b940      	cbnz	r0, 8019308 <HAL_UART_Transmit+0x6e>
    huart->gState = HAL_UART_STATE_READY;
 80192f6:	67e3      	str	r3, [r4, #124]	@ 0x7c
    return HAL_OK;
 80192f8:	e008      	b.n	801930c <HAL_UART_Transmit+0x72>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80192fa:	2200      	movs	r2, #0
 80192fc:	2180      	movs	r1, #128	@ 0x80
 80192fe:	4620      	mov	r0, r4
 8019300:	f7ff ff87 	bl	8019212 <UART_WaitOnFlagUntilTimeout>
 8019304:	b128      	cbz	r0, 8019312 <HAL_UART_Transmit+0x78>
        huart->gState = HAL_UART_STATE_READY;
 8019306:	2320      	movs	r3, #32
        return HAL_TIMEOUT;
 8019308:	2003      	movs	r0, #3
        huart->gState = HAL_UART_STATE_READY;
 801930a:	67e3      	str	r3, [r4, #124]	@ 0x7c
}
 801930c:	b003      	add	sp, #12
 801930e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8019312:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 8019314:	b956      	cbnz	r6, 801932c <HAL_UART_Transmit+0x92>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8019316:	f835 3b02 	ldrh.w	r3, [r5], #2
 801931a:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 801931e:	6293      	str	r3, [r2, #40]	@ 0x28
      huart->TxXferCount--;
 8019320:	f8b4 2052 	ldrh.w	r2, [r4, #82]	@ 0x52
 8019324:	3a01      	subs	r2, #1
 8019326:	f8a4 2052 	strh.w	r2, [r4, #82]	@ 0x52
 801932a:	e7d7      	b.n	80192dc <HAL_UART_Transmit+0x42>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 801932c:	f816 3b01 	ldrb.w	r3, [r6], #1
 8019330:	e7f5      	b.n	801931e <HAL_UART_Transmit+0x84>
    return HAL_BUSY;
 8019332:	2002      	movs	r0, #2
 8019334:	e7ea      	b.n	801930c <HAL_UART_Transmit+0x72>
      return  HAL_ERROR;
 8019336:	2001      	movs	r0, #1
 8019338:	e7e8      	b.n	801930c <HAL_UART_Transmit+0x72>

0801933a <UART_CheckIdleState>:
{
 801933a:	b537      	push	{r0, r1, r2, r4, r5, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 801933c:	2500      	movs	r5, #0
{
 801933e:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8019340:	f8c0 5084 	str.w	r5, [r0, #132]	@ 0x84
  tickstart = HAL_GetTick();
 8019344:	f7fe fcb4 	bl	8017cb0 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8019348:	6822      	ldr	r2, [r4, #0]
  tickstart = HAL_GetTick();
 801934a:	4603      	mov	r3, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 801934c:	6812      	ldr	r2, [r2, #0]
 801934e:	0712      	lsls	r2, r2, #28
 8019350:	d51a      	bpl.n	8019388 <UART_CheckIdleState+0x4e>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8019352:	f06f 427e 	mvn.w	r2, #4261412864	@ 0xfe000000
 8019356:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 801935a:	4620      	mov	r0, r4
 801935c:	9200      	str	r2, [sp, #0]
 801935e:	462a      	mov	r2, r5
 8019360:	f7ff ff57 	bl	8019212 <UART_WaitOnFlagUntilTimeout>
 8019364:	b180      	cbz	r0, 8019388 <UART_CheckIdleState+0x4e>
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE));
 8019366:	6822      	ldr	r2, [r4, #0]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8019368:	e852 3f00 	ldrex	r3, [r2]
 801936c:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8019370:	e842 3100 	strex	r1, r3, [r2]
 8019374:	2900      	cmp	r1, #0
 8019376:	d1f6      	bne.n	8019366 <UART_CheckIdleState+0x2c>
      huart->gState = HAL_UART_STATE_READY;
 8019378:	2320      	movs	r3, #32
      return HAL_TIMEOUT;
 801937a:	2003      	movs	r0, #3
      huart->gState = HAL_UART_STATE_READY;
 801937c:	67e3      	str	r3, [r4, #124]	@ 0x7c
      __HAL_UNLOCK(huart);
 801937e:	2300      	movs	r3, #0
 8019380:	f884 3078 	strb.w	r3, [r4, #120]	@ 0x78
}
 8019384:	b003      	add	sp, #12
 8019386:	bd30      	pop	{r4, r5, pc}
  huart->gState = HAL_UART_STATE_READY;
 8019388:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 801938a:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 801938c:	67e3      	str	r3, [r4, #124]	@ 0x7c
  huart->RxState = HAL_UART_STATE_READY;
 801938e:	f8c4 3080 	str.w	r3, [r4, #128]	@ 0x80
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8019392:	6620      	str	r0, [r4, #96]	@ 0x60
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 8019394:	6660      	str	r0, [r4, #100]	@ 0x64
  return HAL_OK;
 8019396:	e7f2      	b.n	801937e <UART_CheckIdleState+0x44>

08019398 <HAL_UART_Init>:
{
 8019398:	b510      	push	{r4, lr}
  if (huart == NULL)
 801939a:	4604      	mov	r4, r0
 801939c:	b340      	cbz	r0, 80193f0 <HAL_UART_Init+0x58>
  if (huart->gState == HAL_UART_STATE_RESET)
 801939e:	6fc3      	ldr	r3, [r0, #124]	@ 0x7c
 80193a0:	b91b      	cbnz	r3, 80193aa <HAL_UART_Init+0x12>
    huart->Lock = HAL_UNLOCKED;
 80193a2:	f880 3078 	strb.w	r3, [r0, #120]	@ 0x78
    HAL_UART_MspInit(huart);
 80193a6:	f7fe fa83 	bl	80178b0 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 80193aa:	2324      	movs	r3, #36	@ 0x24
  __HAL_UART_DISABLE(huart);
 80193ac:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80193ae:	67e3      	str	r3, [r4, #124]	@ 0x7c
  __HAL_UART_DISABLE(huart);
 80193b0:	6813      	ldr	r3, [r2, #0]
 80193b2:	f023 0301 	bic.w	r3, r3, #1
 80193b6:	6013      	str	r3, [r2, #0]
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80193b8:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 80193ba:	b113      	cbz	r3, 80193c2 <HAL_UART_Init+0x2a>
    UART_AdvFeatureConfig(huart);
 80193bc:	4620      	mov	r0, r4
 80193be:	f7ff fed3 	bl	8019168 <UART_AdvFeatureConfig>
  if (UART_SetConfig(huart) == HAL_ERROR)
 80193c2:	4620      	mov	r0, r4
 80193c4:	f7ff fdd2 	bl	8018f6c <UART_SetConfig>
 80193c8:	2801      	cmp	r0, #1
 80193ca:	d011      	beq.n	80193f0 <HAL_UART_Init+0x58>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80193cc:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 80193ce:	4620      	mov	r0, r4
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80193d0:	685a      	ldr	r2, [r3, #4]
 80193d2:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 80193d6:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80193d8:	689a      	ldr	r2, [r3, #8]
 80193da:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 80193de:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 80193e0:	681a      	ldr	r2, [r3, #0]
 80193e2:	f042 0201 	orr.w	r2, r2, #1
}
 80193e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  __HAL_UART_ENABLE(huart);
 80193ea:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 80193ec:	f7ff bfa5 	b.w	801933a <UART_CheckIdleState>
}
 80193f0:	2001      	movs	r0, #1
 80193f2:	bd10      	pop	{r4, pc}

080193f4 <LZ4_decompress_safe>:

/*===== Instantiate the API decoding functions. =====*/

LZ4_FORCE_O2
int LZ4_decompress_safe(const char* source, char* dest, int compressedSize, int maxDecompressedSize)
{
 80193f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80193f8:	4688      	mov	r8, r1
    if ((src == NULL) || (outputSize < 0)) { return -1; }
 80193fa:	2800      	cmp	r0, #0
 80193fc:	f000 8144 	beq.w	8019688 <LZ4_decompress_safe+0x294>
 8019400:	2b00      	cmp	r3, #0
 8019402:	f2c0 8141 	blt.w	8019688 <LZ4_decompress_safe+0x294>
        if (unlikely(outputSize==0)) {
 8019406:	d10a      	bne.n	801941e <LZ4_decompress_safe+0x2a>
            return ((srcSize==1) && (*ip==0)) ? 0 : -1;
 8019408:	2a01      	cmp	r2, #1
 801940a:	f040 813d 	bne.w	8019688 <LZ4_decompress_safe+0x294>
 801940e:	7800      	ldrb	r0, [r0, #0]
 8019410:	3800      	subs	r0, #0
 8019412:	bf18      	it	ne
 8019414:	2001      	movne	r0, #1
 8019416:	4240      	negs	r0, r0
    return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,
                                  decode_full_block, noDict,
                                  (BYTE*)dest, NULL, 0);
}
 8019418:	b003      	add	sp, #12
 801941a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (unlikely(srcSize==0)) { return -1; }
 801941e:	2a00      	cmp	r2, #0
 8019420:	f000 8132 	beq.w	8019688 <LZ4_decompress_safe+0x294>
        const BYTE* const iend = ip + srcSize;
 8019424:	1887      	adds	r7, r0, r2
        BYTE* const oend = op + outputSize;
 8019426:	440b      	add	r3, r1
    {   const BYTE* ip = (const BYTE*) src;
 8019428:	4684      	mov	ip, r0
        BYTE* op = (BYTE*) dst;
 801942a:	460d      	mov	r5, r1
        const BYTE* const shortiend = iend - 14 /*maxLL*/ - 2 /*offset*/;
 801942c:	f1a7 0210 	sub.w	r2, r7, #16
        const BYTE* const shortoend = oend - 14 /*maxLL*/ - 18 /*maxML*/;
 8019430:	f1a3 0a20 	sub.w	sl, r3, #32
        const BYTE* const shortiend = iend - 14 /*maxLL*/ - 2 /*offset*/;
 8019434:	9201      	str	r2, [sp, #4]
            assert(ip < iend);
 8019436:	4567      	cmp	r7, ip
 8019438:	d806      	bhi.n	8019448 <LZ4_decompress_safe+0x54>
 801943a:	4b95      	ldr	r3, [pc, #596]	@ (8019690 <LZ4_decompress_safe+0x29c>)
 801943c:	f640 01ab 	movw	r1, #2219	@ 0x8ab
 8019440:	4a94      	ldr	r2, [pc, #592]	@ (8019694 <LZ4_decompress_safe+0x2a0>)
                assert(match <= op); /* check overflow */
 8019442:	4895      	ldr	r0, [pc, #596]	@ (8019698 <LZ4_decompress_safe+0x2a4>)
 8019444:	f001 fc4c 	bl	801ace0 <__assert_func>
            token = *ip++;
 8019448:	4661      	mov	r1, ip
 801944a:	f811 6b01 	ldrb.w	r6, [r1], #1
            length = token >> ML_BITS;  /* literal length */
 801944e:	0932      	lsrs	r2, r6, #4
            if ( (length != RUN_MASK)
 8019450:	2a0f      	cmp	r2, #15
 8019452:	d03f      	beq.n	80194d4 <LZ4_decompress_safe+0xe0>
              && likely((ip < shortiend) & (op <= shortoend)) ) {
 8019454:	9c01      	ldr	r4, [sp, #4]
 8019456:	428c      	cmp	r4, r1
 8019458:	d95c      	bls.n	8019514 <LZ4_decompress_safe+0x120>
 801945a:	45aa      	cmp	sl, r5
 801945c:	d35a      	bcc.n	8019514 <LZ4_decompress_safe+0x120>
                op += length; ip += length;
 801945e:	18ac      	adds	r4, r5, r2
 8019460:	eb01 0e02 	add.w	lr, r1, r2
                LZ4_memcpy(op, ip, 16);
 8019464:	46a9      	mov	r9, r5
 8019466:	f10c 0c11 	add.w	ip, ip, #17
 801946a:	f851 bb04 	ldr.w	fp, [r1], #4
 801946e:	4561      	cmp	r1, ip
 8019470:	f849 bb04 	str.w	fp, [r9], #4
 8019474:	d1f9      	bne.n	801946a <LZ4_decompress_safe+0x76>
                offset = LZ4_readLE16(ip); ip += 2;
 8019476:	f8be c000 	ldrh.w	ip, [lr]
                match = op - offset;
 801947a:	eba2 020c 	sub.w	r2, r2, ip
 801947e:	eb05 0902 	add.w	r9, r5, r2
                assert(match <= op); /* check overflow */
 8019482:	45a1      	cmp	r9, r4
 8019484:	d904      	bls.n	8019490 <LZ4_decompress_safe+0x9c>
 8019486:	4b85      	ldr	r3, [pc, #532]	@ (801969c <LZ4_decompress_safe+0x2a8>)
 8019488:	f640 01c6 	movw	r1, #2246	@ 0x8c6
 801948c:	4a81      	ldr	r2, [pc, #516]	@ (8019694 <LZ4_decompress_safe+0x2a0>)
 801948e:	e7d8      	b.n	8019442 <LZ4_decompress_safe+0x4e>
 8019490:	f006 0b0f 	and.w	fp, r6, #15
                offset = LZ4_readLE16(ip); ip += 2;
 8019494:	f10e 0102 	add.w	r1, lr, #2
                if ( (length != ML_MASK)
 8019498:	f1bb 0f0f 	cmp.w	fp, #15
 801949c:	d065      	beq.n	801956a <LZ4_decompress_safe+0x176>
                  && (offset >= 8)
 801949e:	f1bc 0f07 	cmp.w	ip, #7
                length = token & ML_MASK; /* match length */
 80194a2:	465e      	mov	r6, fp
                  && (offset >= 8)
 80194a4:	d976      	bls.n	8019594 <LZ4_decompress_safe+0x1a0>
                  && (dict==withPrefix64k || match >= lowPrefix) ) {
 80194a6:	45c8      	cmp	r8, r9
 80194a8:	f200 80eb 	bhi.w	8019682 <LZ4_decompress_safe+0x28e>
                    LZ4_memcpy(op + 0, match + 0, 8);
 80194ac:	58aa      	ldr	r2, [r5, r2]
                    op += length + MINMATCH;
 80194ae:	f10b 0b04 	add.w	fp, fp, #4
                    LZ4_memcpy(op + 0, match + 0, 8);
 80194b2:	6022      	str	r2, [r4, #0]
                    op += length + MINMATCH;
 80194b4:	eb04 050b 	add.w	r5, r4, fp
                    LZ4_memcpy(op + 0, match + 0, 8);
 80194b8:	f8d9 2004 	ldr.w	r2, [r9, #4]
 80194bc:	6062      	str	r2, [r4, #4]
                    LZ4_memcpy(op + 8, match + 8, 8);
 80194be:	f8d9 2008 	ldr.w	r2, [r9, #8]
 80194c2:	60a2      	str	r2, [r4, #8]
 80194c4:	f8d9 200c 	ldr.w	r2, [r9, #12]
 80194c8:	60e2      	str	r2, [r4, #12]
                    LZ4_memcpy(op +16, match +16, 2);
 80194ca:	f8b9 2010 	ldrh.w	r2, [r9, #16]
 80194ce:	8222      	strh	r2, [r4, #16]
{
 80194d0:	468c      	mov	ip, r1
 80194d2:	e7b0      	b.n	8019436 <LZ4_decompress_safe+0x42>
                size_t const addl = read_variable_length(&ip, iend-RUN_MASK, 1);
 80194d4:	f1a7 0e0f 	sub.w	lr, r7, #15
    if (initial_check && unlikely((*ip) >= ilimit)) {    /* read limit reached */
 80194d8:	4571      	cmp	r1, lr
 80194da:	f080 80d2 	bcs.w	8019682 <LZ4_decompress_safe+0x28e>
    (*ip)++;
 80194de:	f10c 0102 	add.w	r1, ip, #2
    if (unlikely((*ip) > ilimit)) {    /* read limit reached */
 80194e2:	458e      	cmp	lr, r1
 80194e4:	f0c0 80cd 	bcc.w	8019682 <LZ4_decompress_safe+0x28e>
    s = **ip;
 80194e8:	f89c 2001 	ldrb.w	r2, [ip, #1]
    if (likely(s != 255)) return length;
 80194ec:	2aff      	cmp	r2, #255	@ 0xff
 80194ee:	d10a      	bne.n	8019506 <LZ4_decompress_safe+0x112>
        (*ip)++;
 80194f0:	3101      	adds	r1, #1
        if (unlikely((*ip) > ilimit)) {    /* read limit reached */
 80194f2:	458e      	cmp	lr, r1
 80194f4:	f0c0 80c5 	bcc.w	8019682 <LZ4_decompress_safe+0x28e>
        s = **ip;
 80194f8:	f811 4c01 	ldrb.w	r4, [r1, #-1]
        if ((sizeof(length) < 8) && unlikely(length > ((Rvl_t)(-1)/2)) ) {
 80194fc:	1912      	adds	r2, r2, r4
 80194fe:	f100 80c0 	bmi.w	8019682 <LZ4_decompress_safe+0x28e>
    } while (s == 255);
 8019502:	2cff      	cmp	r4, #255	@ 0xff
 8019504:	e7f3      	b.n	80194ee <LZ4_decompress_safe+0xfa>
                length += addl;
 8019506:	320f      	adds	r2, #15
                if (unlikely((uptrval)(op)+length<(uptrval)(op))) { goto _output_error; } /* overflow detection */
 8019508:	42d5      	cmn	r5, r2
 801950a:	f080 80ba 	bcs.w	8019682 <LZ4_decompress_safe+0x28e>
                if (unlikely((uptrval)(ip)+length<(uptrval)(ip))) { goto _output_error; } /* overflow detection */
 801950e:	42d1      	cmn	r1, r2
 8019510:	f080 80b7 	bcs.w	8019682 <LZ4_decompress_safe+0x28e>
            cpy = op+length;
 8019514:	18ac      	adds	r4, r5, r2
            if ((cpy>oend-MFLIMIT) || (ip+length>iend-(2+1+LASTLITERALS))) {
 8019516:	f1a3 0e0c 	sub.w	lr, r3, #12
 801951a:	eb01 0c02 	add.w	ip, r1, r2
 801951e:	4574      	cmp	r4, lr
 8019520:	d803      	bhi.n	801952a <LZ4_decompress_safe+0x136>
 8019522:	f1a7 0e08 	sub.w	lr, r7, #8
 8019526:	45f4      	cmp	ip, lr
 8019528:	d90b      	bls.n	8019542 <LZ4_decompress_safe+0x14e>
                    if ((ip+length != iend) || (cpy > oend)) {
 801952a:	4567      	cmp	r7, ip
 801952c:	f040 80a9 	bne.w	8019682 <LZ4_decompress_safe+0x28e>
 8019530:	42a3      	cmp	r3, r4
 8019532:	f0c0 80a6 	bcc.w	8019682 <LZ4_decompress_safe+0x28e>
                LZ4_memmove(op, ip, length);  /* supports overlapping memory regions, for in-place decompression scenarios */
 8019536:	4628      	mov	r0, r5
 8019538:	f001 fdb3 	bl	801b0a2 <memmove>
        return (int) (((char*)op)-dst);     /* Nb of output bytes decoded */
 801953c:	eba4 0008 	sub.w	r0, r4, r8
 8019540:	e76a      	b.n	8019418 <LZ4_decompress_safe+0x24>
    do { LZ4_memcpy(d,s,8); d+=8; s+=8; } while (d<e);
 8019542:	680a      	ldr	r2, [r1, #0]
 8019544:	3508      	adds	r5, #8
 8019546:	3108      	adds	r1, #8
 8019548:	f845 2c08 	str.w	r2, [r5, #-8]
 801954c:	f851 2c04 	ldr.w	r2, [r1, #-4]
 8019550:	f845 2c04 	str.w	r2, [r5, #-4]
 8019554:	42ac      	cmp	r4, r5
 8019556:	d8f4      	bhi.n	8019542 <LZ4_decompress_safe+0x14e>
static U16 LZ4_read16(const void* ptr) { return ((const LZ4_unalign16*)ptr)->u16; }
 8019558:	4661      	mov	r1, ip
 801955a:	f006 060f 	and.w	r6, r6, #15
            offset = LZ4_readLE16(ip); ip+=2;
 801955e:	f831 cb02 	ldrh.w	ip, [r1], #2
            if (length == ML_MASK) {
 8019562:	2e0f      	cmp	r6, #15
            match = op - offset;
 8019564:	eba4 090c 	sub.w	r9, r4, ip
            if (length == ML_MASK) {
 8019568:	d114      	bne.n	8019594 <LZ4_decompress_safe+0x1a0>
                size_t const addl = read_variable_length(&ip, iend - LASTLITERALS + 1, 0);
 801956a:	1f3d      	subs	r5, r7, #4
    (*ip)++;
 801956c:	1c4a      	adds	r2, r1, #1
    if (unlikely((*ip) > ilimit)) {    /* read limit reached */
 801956e:	4295      	cmp	r5, r2
 8019570:	f0c0 8086 	bcc.w	8019680 <LZ4_decompress_safe+0x28c>
    s = **ip;
 8019574:	780e      	ldrb	r6, [r1, #0]
    (*ip)++;
 8019576:	4611      	mov	r1, r2
    if (likely(s != 255)) return length;
 8019578:	2eff      	cmp	r6, #255	@ 0xff
 801957a:	d108      	bne.n	801958e <LZ4_decompress_safe+0x19a>
        (*ip)++;
 801957c:	3101      	adds	r1, #1
        if (unlikely((*ip) > ilimit)) {    /* read limit reached */
 801957e:	428d      	cmp	r5, r1
 8019580:	d37f      	bcc.n	8019682 <LZ4_decompress_safe+0x28e>
        s = **ip;
 8019582:	f811 2c01 	ldrb.w	r2, [r1, #-1]
        if ((sizeof(length) < 8) && unlikely(length > ((Rvl_t)(-1)/2)) ) {
 8019586:	18b6      	adds	r6, r6, r2
 8019588:	d47b      	bmi.n	8019682 <LZ4_decompress_safe+0x28e>
    } while (s == 255);
 801958a:	2aff      	cmp	r2, #255	@ 0xff
 801958c:	e7f5      	b.n	801957a <LZ4_decompress_safe+0x186>
                length += addl;
 801958e:	360f      	adds	r6, #15
                if (unlikely((uptrval)(op)+length<(uptrval)op)) goto _output_error;   /* overflow detection */
 8019590:	42f4      	cmn	r4, r6
 8019592:	d276      	bcs.n	8019682 <LZ4_decompress_safe+0x28e>
            if ((checkOffset) && (unlikely(match + dictSize < lowPrefix))) goto _output_error;   /* Error : offset outside buffers */
 8019594:	45c8      	cmp	r8, r9
 8019596:	d874      	bhi.n	8019682 <LZ4_decompress_safe+0x28e>
            assert(op<=oend);
 8019598:	42a3      	cmp	r3, r4
 801959a:	d204      	bcs.n	80195a6 <LZ4_decompress_safe+0x1b2>
 801959c:	4b40      	ldr	r3, [pc, #256]	@ (80196a0 <LZ4_decompress_safe+0x2ac>)
 801959e:	f640 115a 	movw	r1, #2394	@ 0x95a
 80195a2:	4a3c      	ldr	r2, [pc, #240]	@ (8019694 <LZ4_decompress_safe+0x2a0>)
 80195a4:	e74d      	b.n	8019442 <LZ4_decompress_safe+0x4e>
            length += MINMATCH;
 80195a6:	3604      	adds	r6, #4
            if (unlikely(offset<8)) {
 80195a8:	f1bc 0f07 	cmp.w	ip, #7
            cpy = op + length;
 80195ac:	eb04 0506 	add.w	r5, r4, r6
            if (unlikely(offset<8)) {
 80195b0:	d844      	bhi.n	801963c <LZ4_decompress_safe+0x248>
static void LZ4_write32(void* memPtr, U32 value) { ((LZ4_unalign32*)memPtr)->u32 = value; }
 80195b2:	2200      	movs	r2, #0
 80195b4:	7022      	strb	r2, [r4, #0]
 80195b6:	7062      	strb	r2, [r4, #1]
 80195b8:	70a2      	strb	r2, [r4, #2]
 80195ba:	70e2      	strb	r2, [r4, #3]
                op[0] = match[0];
 80195bc:	f899 2000 	ldrb.w	r2, [r9]
 80195c0:	7022      	strb	r2, [r4, #0]
                op[1] = match[1];
 80195c2:	f899 2001 	ldrb.w	r2, [r9, #1]
 80195c6:	7062      	strb	r2, [r4, #1]
                op[2] = match[2];
 80195c8:	f899 2002 	ldrb.w	r2, [r9, #2]
 80195cc:	70a2      	strb	r2, [r4, #2]
                op[3] = match[3];
 80195ce:	f899 2003 	ldrb.w	r2, [r9, #3]
 80195d2:	70e2      	strb	r2, [r4, #3]
                match += inc32table[offset];
 80195d4:	4a33      	ldr	r2, [pc, #204]	@ (80196a4 <LZ4_decompress_safe+0x2b0>)
 80195d6:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 80195da:	eb09 0e02 	add.w	lr, r9, r2
                LZ4_memcpy(op+4, match, 4);
 80195de:	f859 2002 	ldr.w	r2, [r9, r2]
 80195e2:	6062      	str	r2, [r4, #4]
                match -= dec64table[offset];
 80195e4:	4a30      	ldr	r2, [pc, #192]	@ (80196a8 <LZ4_decompress_safe+0x2b4>)
 80195e6:	f852 202c 	ldr.w	r2, [r2, ip, lsl #2]
 80195ea:	ebae 0202 	sub.w	r2, lr, r2
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
 80195ee:	f1a3 0e0c 	sub.w	lr, r3, #12
            op += 8;
 80195f2:	f104 0c08 	add.w	ip, r4, #8
            if (unlikely(cpy > oend-MATCH_SAFEGUARD_DISTANCE)) {
 80195f6:	4575      	cmp	r5, lr
 80195f8:	d929      	bls.n	801964e <LZ4_decompress_safe+0x25a>
                if (cpy > oend-LASTLITERALS) { goto _output_error; } /* Error : last LASTLITERALS bytes must be literals (uncompressed) */
 80195fa:	1f5c      	subs	r4, r3, #5
 80195fc:	42a5      	cmp	r5, r4
 80195fe:	d840      	bhi.n	8019682 <LZ4_decompress_safe+0x28e>
                BYTE* const oCopyLimit = oend - (WILDCOPYLENGTH-1);
 8019600:	1fde      	subs	r6, r3, #7
                if (op < oCopyLimit) {
 8019602:	45b4      	cmp	ip, r6
 8019604:	d212      	bcs.n	801962c <LZ4_decompress_safe+0x238>
    const BYTE* s = (const BYTE*)srcPtr;
 8019606:	4696      	mov	lr, r2
    BYTE* d = (BYTE*)dstPtr;
 8019608:	4664      	mov	r4, ip
    do { LZ4_memcpy(d,s,8); d+=8; s+=8; } while (d<e);
 801960a:	f8de 9000 	ldr.w	r9, [lr]
 801960e:	3408      	adds	r4, #8
 8019610:	f10e 0e08 	add.w	lr, lr, #8
 8019614:	f844 9c08 	str.w	r9, [r4, #-8]
 8019618:	f85e 9c04 	ldr.w	r9, [lr, #-4]
 801961c:	f844 9c04 	str.w	r9, [r4, #-4]
 8019620:	42a6      	cmp	r6, r4
 8019622:	d8f2      	bhi.n	801960a <LZ4_decompress_safe+0x216>
                    match += oCopyLimit - op;
 8019624:	eba6 0c0c 	sub.w	ip, r6, ip
 8019628:	4462      	add	r2, ip
                    op = oCopyLimit;
 801962a:	46b4      	mov	ip, r6
                while (op < cpy) { *op++ = *match++; }
 801962c:	4565      	cmp	r5, ip
 801962e:	f67f af4f 	bls.w	80194d0 <LZ4_decompress_safe+0xdc>
 8019632:	f812 4b01 	ldrb.w	r4, [r2], #1
 8019636:	f80c 4b01 	strb.w	r4, [ip], #1
 801963a:	e7f7      	b.n	801962c <LZ4_decompress_safe+0x238>
                LZ4_memcpy(op, match, 8);
 801963c:	f8d9 2000 	ldr.w	r2, [r9]
 8019640:	6022      	str	r2, [r4, #0]
 8019642:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8019646:	6062      	str	r2, [r4, #4]
                match += 8;
 8019648:	f109 0208 	add.w	r2, r9, #8
 801964c:	e7cf      	b.n	80195ee <LZ4_decompress_safe+0x1fa>
                LZ4_memcpy(op, match, 8);
 801964e:	f8d2 e000 	ldr.w	lr, [r2]
                if (length > 16) { LZ4_wildCopy8(op+8, match+8, cpy); }
 8019652:	2e10      	cmp	r6, #16
                LZ4_memcpy(op, match, 8);
 8019654:	f8c4 e008 	str.w	lr, [r4, #8]
 8019658:	f8d2 e004 	ldr.w	lr, [r2, #4]
 801965c:	f8cc e004 	str.w	lr, [ip, #4]
                if (length > 16) { LZ4_wildCopy8(op+8, match+8, cpy); }
 8019660:	f67f af36 	bls.w	80194d0 <LZ4_decompress_safe+0xdc>
 8019664:	3410      	adds	r4, #16
 8019666:	3208      	adds	r2, #8
    do { LZ4_memcpy(d,s,8); d+=8; s+=8; } while (d<e);
 8019668:	6816      	ldr	r6, [r2, #0]
 801966a:	3408      	adds	r4, #8
 801966c:	3208      	adds	r2, #8
 801966e:	f844 6c08 	str.w	r6, [r4, #-8]
 8019672:	f852 6c04 	ldr.w	r6, [r2, #-4]
 8019676:	f844 6c04 	str.w	r6, [r4, #-4]
 801967a:	42a5      	cmp	r5, r4
 801967c:	d8f4      	bhi.n	8019668 <LZ4_decompress_safe+0x274>
 801967e:	e727      	b.n	80194d0 <LZ4_decompress_safe+0xdc>
    (*ip)++;
 8019680:	4611      	mov	r1, r2
        return (int) (-(((const char*)ip)-src))-1;
 8019682:	1a40      	subs	r0, r0, r1
 8019684:	3801      	subs	r0, #1
 8019686:	e6c7      	b.n	8019418 <LZ4_decompress_safe+0x24>
    if ((src == NULL) || (outputSize < 0)) { return -1; }
 8019688:	f04f 30ff 	mov.w	r0, #4294967295
    return LZ4_decompress_generic(source, dest, compressedSize, maxDecompressedSize,
 801968c:	e6c4      	b.n	8019418 <LZ4_decompress_safe+0x24>
 801968e:	bf00      	nop
 8019690:	0801c33a 	.word	0x0801c33a
 8019694:	0801c3cf 	.word	0x0801c3cf
 8019698:	0801c314 	.word	0x0801c314
 801969c:	0801c344 	.word	0x0801c344
 80196a0:	0801c350 	.word	0x0801c350
 80196a4:	0801c408 	.word	0x0801c408
 80196a8:	0801c3e8 	.word	0x0801c3e8

080196ac <add_round_key>:
	(void)_copy(s, sizeof(t), t, sizeof(t));
}

static inline void add_round_key(uint8_t *s, const unsigned int *k)
{
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
 80196ac:	78cb      	ldrb	r3, [r1, #3]
 80196ae:	7802      	ldrb	r2, [r0, #0]
 80196b0:	4053      	eors	r3, r2
 80196b2:	7842      	ldrb	r2, [r0, #1]
 80196b4:	7003      	strb	r3, [r0, #0]
 80196b6:	884b      	ldrh	r3, [r1, #2]
 80196b8:	4053      	eors	r3, r2
 80196ba:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
 80196bc:	7883      	ldrb	r3, [r0, #2]
 80196be:	680a      	ldr	r2, [r1, #0]
 80196c0:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 80196c4:	7083      	strb	r3, [r0, #2]
 80196c6:	78c3      	ldrb	r3, [r0, #3]
 80196c8:	780a      	ldrb	r2, [r1, #0]
 80196ca:	4053      	eors	r3, r2
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
 80196cc:	7902      	ldrb	r2, [r0, #4]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
 80196ce:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
 80196d0:	79cb      	ldrb	r3, [r1, #7]
 80196d2:	4053      	eors	r3, r2
 80196d4:	7942      	ldrb	r2, [r0, #5]
 80196d6:	7103      	strb	r3, [r0, #4]
 80196d8:	88cb      	ldrh	r3, [r1, #6]
 80196da:	4053      	eors	r3, r2
 80196dc:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
 80196de:	7983      	ldrb	r3, [r0, #6]
 80196e0:	684a      	ldr	r2, [r1, #4]
 80196e2:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 80196e6:	7183      	strb	r3, [r0, #6]
 80196e8:	79c3      	ldrb	r3, [r0, #7]
 80196ea:	790a      	ldrb	r2, [r1, #4]
 80196ec:	4053      	eors	r3, r2
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
 80196ee:	7a02      	ldrb	r2, [r0, #8]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
 80196f0:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
 80196f2:	7acb      	ldrb	r3, [r1, #11]
 80196f4:	4053      	eors	r3, r2
 80196f6:	7a42      	ldrb	r2, [r0, #9]
 80196f8:	7203      	strb	r3, [r0, #8]
 80196fa:	894b      	ldrh	r3, [r1, #10]
 80196fc:	4053      	eors	r3, r2
 80196fe:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
 8019700:	7a83      	ldrb	r3, [r0, #10]
 8019702:	688a      	ldr	r2, [r1, #8]
 8019704:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 8019708:	7283      	strb	r3, [r0, #10]
 801970a:	7a0a      	ldrb	r2, [r1, #8]
 801970c:	7ac3      	ldrb	r3, [r0, #11]
 801970e:	4053      	eors	r3, r2
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
 8019710:	7b02      	ldrb	r2, [r0, #12]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
 8019712:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
 8019714:	7bcb      	ldrb	r3, [r1, #15]
 8019716:	4053      	eors	r3, r2
 8019718:	7b42      	ldrb	r2, [r0, #13]
 801971a:	7303      	strb	r3, [r0, #12]
 801971c:	89cb      	ldrh	r3, [r1, #14]
 801971e:	4053      	eors	r3, r2
 8019720:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
 8019722:	7b83      	ldrb	r3, [r0, #14]
 8019724:	68ca      	ldr	r2, [r1, #12]
 8019726:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
 801972a:	7383      	strb	r3, [r0, #14]
 801972c:	7bc3      	ldrb	r3, [r0, #15]
 801972e:	7b0a      	ldrb	r2, [r1, #12]
 8019730:	4053      	eors	r3, r2
 8019732:	73c3      	strb	r3, [r0, #15]
}
 8019734:	4770      	bx	lr
	...

08019738 <inv_sub_bytes>:

static inline void inv_sub_bytes(uint8_t *s)
{
	unsigned int i;

	for (i = 0; i < (Nb*Nk); ++i) {
 8019738:	1e43      	subs	r3, r0, #1
		s[i] = inv_sbox[s[i]];
 801973a:	4904      	ldr	r1, [pc, #16]	@ (801974c <inv_sub_bytes+0x14>)
 801973c:	300f      	adds	r0, #15
 801973e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8019742:	5c8a      	ldrb	r2, [r1, r2]
	for (i = 0; i < (Nb*Nk); ++i) {
 8019744:	4283      	cmp	r3, r0
		s[i] = inv_sbox[s[i]];
 8019746:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < (Nb*Nk); ++i) {
 8019748:	d1f9      	bne.n	801973e <inv_sub_bytes+0x6>
	}
}
 801974a:	4770      	bx	lr
 801974c:	0801c428 	.word	0x0801c428

08019750 <mult_row_column>:
{
 8019750:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019754:	4605      	mov	r5, r0
	out[0] = multe(in[0]) ^ multb(in[1]) ^ multd(in[2]) ^ mult9(in[3]);
 8019756:	7808      	ldrb	r0, [r1, #0]
{
 8019758:	460c      	mov	r4, r1
	out[0] = multe(in[0]) ^ multb(in[1]) ^ multd(in[2]) ^ mult9(in[3]);
 801975a:	f001 fab7 	bl	801accc <_double_byte>
 801975e:	f001 fab5 	bl	801accc <_double_byte>
 8019762:	f001 fab3 	bl	801accc <_double_byte>
 8019766:	4683      	mov	fp, r0
 8019768:	7820      	ldrb	r0, [r4, #0]
 801976a:	f001 faaf 	bl	801accc <_double_byte>
 801976e:	f001 faad 	bl	801accc <_double_byte>
 8019772:	4682      	mov	sl, r0
 8019774:	7820      	ldrb	r0, [r4, #0]
 8019776:	f001 faa9 	bl	801accc <_double_byte>
 801977a:	4681      	mov	r9, r0
 801977c:	7860      	ldrb	r0, [r4, #1]
 801977e:	f001 faa5 	bl	801accc <_double_byte>
 8019782:	f001 faa3 	bl	801accc <_double_byte>
 8019786:	f001 faa1 	bl	801accc <_double_byte>
 801978a:	4680      	mov	r8, r0
 801978c:	7860      	ldrb	r0, [r4, #1]
 801978e:	f001 fa9d 	bl	801accc <_double_byte>
 8019792:	4607      	mov	r7, r0
 8019794:	78a0      	ldrb	r0, [r4, #2]
 8019796:	7866      	ldrb	r6, [r4, #1]
 8019798:	f001 fa98 	bl	801accc <_double_byte>
 801979c:	f001 fa96 	bl	801accc <_double_byte>
 80197a0:	f001 fa94 	bl	801accc <_double_byte>
 80197a4:	9000      	str	r0, [sp, #0]
 80197a6:	78a0      	ldrb	r0, [r4, #2]
 80197a8:	f001 fa90 	bl	801accc <_double_byte>
 80197ac:	f001 fa8e 	bl	801accc <_double_byte>
 80197b0:	78a2      	ldrb	r2, [r4, #2]
 80197b2:	9001      	str	r0, [sp, #4]
 80197b4:	78e0      	ldrb	r0, [r4, #3]
 80197b6:	4056      	eors	r6, r2
 80197b8:	f001 fa88 	bl	801accc <_double_byte>
 80197bc:	f001 fa86 	bl	801accc <_double_byte>
 80197c0:	f001 fa84 	bl	801accc <_double_byte>
 80197c4:	78e2      	ldrb	r2, [r4, #3]
 80197c6:	ea86 0302 	eor.w	r3, r6, r2
 80197ca:	9e00      	ldr	r6, [sp, #0]
 80197cc:	ea8b 0b03 	eor.w	fp, fp, r3
 80197d0:	9b01      	ldr	r3, [sp, #4]
 80197d2:	ea8a 0a0b 	eor.w	sl, sl, fp
 80197d6:	ea89 090a 	eor.w	r9, r9, sl
 80197da:	ea88 0809 	eor.w	r8, r8, r9
 80197de:	ea87 0708 	eor.w	r7, r7, r8
 80197e2:	407e      	eors	r6, r7
 80197e4:	405e      	eors	r6, r3
 80197e6:	4070      	eors	r0, r6
 80197e8:	7028      	strb	r0, [r5, #0]
	out[1] = mult9(in[0]) ^ multe(in[1]) ^ multb(in[2]) ^ multd(in[3]);
 80197ea:	7820      	ldrb	r0, [r4, #0]
 80197ec:	f001 fa6e 	bl	801accc <_double_byte>
 80197f0:	f001 fa6c 	bl	801accc <_double_byte>
 80197f4:	f001 fa6a 	bl	801accc <_double_byte>
 80197f8:	4683      	mov	fp, r0
 80197fa:	7860      	ldrb	r0, [r4, #1]
 80197fc:	7826      	ldrb	r6, [r4, #0]
 80197fe:	f001 fa65 	bl	801accc <_double_byte>
 8019802:	f001 fa63 	bl	801accc <_double_byte>
 8019806:	f001 fa61 	bl	801accc <_double_byte>
 801980a:	4682      	mov	sl, r0
 801980c:	7860      	ldrb	r0, [r4, #1]
 801980e:	f001 fa5d 	bl	801accc <_double_byte>
 8019812:	f001 fa5b 	bl	801accc <_double_byte>
 8019816:	4681      	mov	r9, r0
 8019818:	7860      	ldrb	r0, [r4, #1]
 801981a:	f001 fa57 	bl	801accc <_double_byte>
 801981e:	4680      	mov	r8, r0
 8019820:	78a0      	ldrb	r0, [r4, #2]
 8019822:	f001 fa53 	bl	801accc <_double_byte>
 8019826:	f001 fa51 	bl	801accc <_double_byte>
 801982a:	f001 fa4f 	bl	801accc <_double_byte>
 801982e:	4607      	mov	r7, r0
 8019830:	78a0      	ldrb	r0, [r4, #2]
 8019832:	f001 fa4b 	bl	801accc <_double_byte>
 8019836:	78a2      	ldrb	r2, [r4, #2]
 8019838:	9000      	str	r0, [sp, #0]
 801983a:	78e0      	ldrb	r0, [r4, #3]
 801983c:	4056      	eors	r6, r2
 801983e:	f001 fa45 	bl	801accc <_double_byte>
 8019842:	f001 fa43 	bl	801accc <_double_byte>
 8019846:	f001 fa41 	bl	801accc <_double_byte>
 801984a:	9001      	str	r0, [sp, #4]
 801984c:	78e0      	ldrb	r0, [r4, #3]
 801984e:	f001 fa3d 	bl	801accc <_double_byte>
 8019852:	f001 fa3b 	bl	801accc <_double_byte>
 8019856:	78e2      	ldrb	r2, [r4, #3]
 8019858:	ea86 0302 	eor.w	r3, r6, r2
 801985c:	9e00      	ldr	r6, [sp, #0]
 801985e:	ea8b 0b03 	eor.w	fp, fp, r3
 8019862:	9b01      	ldr	r3, [sp, #4]
 8019864:	ea8a 0a0b 	eor.w	sl, sl, fp
 8019868:	ea89 090a 	eor.w	r9, r9, sl
 801986c:	ea88 0809 	eor.w	r8, r8, r9
 8019870:	ea87 0708 	eor.w	r7, r7, r8
 8019874:	407e      	eors	r6, r7
 8019876:	405e      	eors	r6, r3
 8019878:	4070      	eors	r0, r6
 801987a:	7068      	strb	r0, [r5, #1]
	out[2] = multd(in[0]) ^ mult9(in[1]) ^ multe(in[2]) ^ multb(in[3]);
 801987c:	7820      	ldrb	r0, [r4, #0]
 801987e:	f001 fa25 	bl	801accc <_double_byte>
 8019882:	f001 fa23 	bl	801accc <_double_byte>
 8019886:	f001 fa21 	bl	801accc <_double_byte>
 801988a:	4683      	mov	fp, r0
 801988c:	7820      	ldrb	r0, [r4, #0]
 801988e:	f001 fa1d 	bl	801accc <_double_byte>
 8019892:	f001 fa1b 	bl	801accc <_double_byte>
 8019896:	4682      	mov	sl, r0
 8019898:	7860      	ldrb	r0, [r4, #1]
 801989a:	7826      	ldrb	r6, [r4, #0]
 801989c:	f001 fa16 	bl	801accc <_double_byte>
 80198a0:	f001 fa14 	bl	801accc <_double_byte>
 80198a4:	f001 fa12 	bl	801accc <_double_byte>
 80198a8:	7863      	ldrb	r3, [r4, #1]
 80198aa:	4681      	mov	r9, r0
 80198ac:	78a0      	ldrb	r0, [r4, #2]
 80198ae:	405e      	eors	r6, r3
 80198b0:	f001 fa0c 	bl	801accc <_double_byte>
 80198b4:	f001 fa0a 	bl	801accc <_double_byte>
 80198b8:	f001 fa08 	bl	801accc <_double_byte>
 80198bc:	4680      	mov	r8, r0
 80198be:	78a0      	ldrb	r0, [r4, #2]
 80198c0:	f001 fa04 	bl	801accc <_double_byte>
 80198c4:	f001 fa02 	bl	801accc <_double_byte>
 80198c8:	4607      	mov	r7, r0
 80198ca:	78a0      	ldrb	r0, [r4, #2]
 80198cc:	f001 f9fe 	bl	801accc <_double_byte>
 80198d0:	9000      	str	r0, [sp, #0]
 80198d2:	78e0      	ldrb	r0, [r4, #3]
 80198d4:	f001 f9fa 	bl	801accc <_double_byte>
 80198d8:	f001 f9f8 	bl	801accc <_double_byte>
 80198dc:	f001 f9f6 	bl	801accc <_double_byte>
 80198e0:	9001      	str	r0, [sp, #4]
 80198e2:	78e0      	ldrb	r0, [r4, #3]
 80198e4:	f001 f9f2 	bl	801accc <_double_byte>
 80198e8:	78e2      	ldrb	r2, [r4, #3]
 80198ea:	ea86 0302 	eor.w	r3, r6, r2
 80198ee:	9e00      	ldr	r6, [sp, #0]
 80198f0:	ea8b 0b03 	eor.w	fp, fp, r3
 80198f4:	9b01      	ldr	r3, [sp, #4]
 80198f6:	ea8a 0a0b 	eor.w	sl, sl, fp
 80198fa:	ea89 090a 	eor.w	r9, r9, sl
 80198fe:	ea88 0809 	eor.w	r8, r8, r9
 8019902:	ea87 0708 	eor.w	r7, r7, r8
 8019906:	407e      	eors	r6, r7
 8019908:	405e      	eors	r6, r3
 801990a:	4070      	eors	r0, r6
 801990c:	70a8      	strb	r0, [r5, #2]
	out[3] = multb(in[0]) ^ multd(in[1]) ^ mult9(in[2]) ^ multe(in[3]);
 801990e:	7820      	ldrb	r0, [r4, #0]
 8019910:	f001 f9dc 	bl	801accc <_double_byte>
 8019914:	f001 f9da 	bl	801accc <_double_byte>
 8019918:	f001 f9d8 	bl	801accc <_double_byte>
 801991c:	4682      	mov	sl, r0
 801991e:	7820      	ldrb	r0, [r4, #0]
 8019920:	f001 f9d4 	bl	801accc <_double_byte>
 8019924:	4681      	mov	r9, r0
 8019926:	7860      	ldrb	r0, [r4, #1]
 8019928:	7826      	ldrb	r6, [r4, #0]
 801992a:	f001 f9cf 	bl	801accc <_double_byte>
 801992e:	f001 f9cd 	bl	801accc <_double_byte>
 8019932:	f001 f9cb 	bl	801accc <_double_byte>
 8019936:	4680      	mov	r8, r0
 8019938:	7860      	ldrb	r0, [r4, #1]
 801993a:	f001 f9c7 	bl	801accc <_double_byte>
 801993e:	f001 f9c5 	bl	801accc <_double_byte>
 8019942:	7863      	ldrb	r3, [r4, #1]
 8019944:	4607      	mov	r7, r0
 8019946:	78a0      	ldrb	r0, [r4, #2]
 8019948:	405e      	eors	r6, r3
 801994a:	f001 f9bf 	bl	801accc <_double_byte>
 801994e:	f001 f9bd 	bl	801accc <_double_byte>
 8019952:	f001 f9bb 	bl	801accc <_double_byte>
 8019956:	78a3      	ldrb	r3, [r4, #2]
 8019958:	405e      	eors	r6, r3
 801995a:	ea8a 0a06 	eor.w	sl, sl, r6
 801995e:	ea89 090a 	eor.w	r9, r9, sl
 8019962:	ea88 0809 	eor.w	r8, r8, r9
 8019966:	ea87 0708 	eor.w	r7, r7, r8
 801996a:	4047      	eors	r7, r0
 801996c:	78e0      	ldrb	r0, [r4, #3]
 801996e:	f001 f9ad 	bl	801accc <_double_byte>
 8019972:	f001 f9ab 	bl	801accc <_double_byte>
 8019976:	f001 f9a9 	bl	801accc <_double_byte>
 801997a:	ea80 0807 	eor.w	r8, r0, r7
 801997e:	78e0      	ldrb	r0, [r4, #3]
 8019980:	f001 f9a4 	bl	801accc <_double_byte>
 8019984:	f001 f9a2 	bl	801accc <_double_byte>
 8019988:	ea80 0608 	eor.w	r6, r0, r8
 801998c:	78e0      	ldrb	r0, [r4, #3]
 801998e:	f001 f99d 	bl	801accc <_double_byte>
 8019992:	4070      	eors	r0, r6
 8019994:	70e8      	strb	r0, [r5, #3]
}
 8019996:	b003      	add	sp, #12
 8019998:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801999c <tc_aes128_set_decrypt_key>:
	return tc_aes128_set_encrypt_key(s, k);
 801999c:	f000 b8e2 	b.w	8019b64 <tc_aes128_set_encrypt_key>

080199a0 <tc_aes_decrypt>:
	t[12] = s[12]; t[13] = s[9]; t[14] = s[6]; t[15] = s[3];
	(void)_copy(s, sizeof(t), t, sizeof(t));
}

int tc_aes_decrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
 80199a0:	b570      	push	{r4, r5, r6, lr}
 80199a2:	4606      	mov	r6, r0
 80199a4:	b088      	sub	sp, #32
 80199a6:	4614      	mov	r4, r2
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
 80199a8:	2800      	cmp	r0, #0
 80199aa:	f000 80d5 	beq.w	8019b58 <tc_aes_decrypt+0x1b8>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
 80199ae:	2900      	cmp	r1, #0
 80199b0:	f000 80d4 	beq.w	8019b5c <tc_aes_decrypt+0x1bc>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
 80199b4:	2a00      	cmp	r2, #0
 80199b6:	f000 80d3 	beq.w	8019b60 <tc_aes_decrypt+0x1c0>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
 80199ba:	2310      	movs	r3, #16
 80199bc:	460a      	mov	r2, r1
 80199be:	4668      	mov	r0, sp
 80199c0:	f104 0590 	add.w	r5, r4, #144	@ 0x90
 80199c4:	4619      	mov	r1, r3
 80199c6:	f001 f972 	bl	801acae <_copy>

	add_round_key(state, s->words + Nb*Nr);
 80199ca:	f104 01a0 	add.w	r1, r4, #160	@ 0xa0
 80199ce:	4668      	mov	r0, sp
 80199d0:	f7ff fe6c 	bl	80196ac <add_round_key>
	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
 80199d4:	f89d 3000 	ldrb.w	r3, [sp]
	(void)_copy(s, sizeof(t), t, sizeof(t));
 80199d8:	4668      	mov	r0, sp
	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
 80199da:	f88d 3010 	strb.w	r3, [sp, #16]
 80199de:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80199e2:	f88d 3011 	strb.w	r3, [sp, #17]
 80199e6:	f89d 300a 	ldrb.w	r3, [sp, #10]
 80199ea:	f88d 3012 	strb.w	r3, [sp, #18]
 80199ee:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80199f2:	f88d 3013 	strb.w	r3, [sp, #19]
	t[4]  = s[4]; t[5] = s[1]; t[6] = s[14]; t[7] = s[11];
 80199f6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80199fa:	f88d 3014 	strb.w	r3, [sp, #20]
 80199fe:	f89d 3001 	ldrb.w	r3, [sp, #1]
 8019a02:	f88d 3015 	strb.w	r3, [sp, #21]
 8019a06:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8019a0a:	f88d 3016 	strb.w	r3, [sp, #22]
 8019a0e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8019a12:	f88d 3017 	strb.w	r3, [sp, #23]
	t[8]  = s[8]; t[9] = s[5]; t[10] = s[2]; t[11] = s[15];
 8019a16:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8019a1a:	f88d 3018 	strb.w	r3, [sp, #24]
 8019a1e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8019a22:	f88d 3019 	strb.w	r3, [sp, #25]
 8019a26:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8019a2a:	f88d 301a 	strb.w	r3, [sp, #26]
 8019a2e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8019a32:	f88d 301b 	strb.w	r3, [sp, #27]
	t[12] = s[12]; t[13] = s[9]; t[14] = s[6]; t[15] = s[3];
 8019a36:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8019a3a:	f88d 301c 	strb.w	r3, [sp, #28]
 8019a3e:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8019a42:	f88d 301d 	strb.w	r3, [sp, #29]
 8019a46:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8019a4a:	f88d 301e 	strb.w	r3, [sp, #30]
 8019a4e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8019a52:	f88d 301f 	strb.w	r3, [sp, #31]
	(void)_copy(s, sizeof(t), t, sizeof(t));
 8019a56:	2310      	movs	r3, #16
 8019a58:	eb0d 0203 	add.w	r2, sp, r3
 8019a5c:	4619      	mov	r1, r3
 8019a5e:	f001 f926 	bl	801acae <_copy>

	for (i = Nr - 1; i > 0; --i) {
		inv_shift_rows(state);
		inv_sub_bytes(state);
 8019a62:	4668      	mov	r0, sp
 8019a64:	f7ff fe68 	bl	8019738 <inv_sub_bytes>
		add_round_key(state, s->words + Nb*i);
 8019a68:	4629      	mov	r1, r5
 8019a6a:	4668      	mov	r0, sp
	for (i = Nr - 1; i > 0; --i) {
 8019a6c:	3d10      	subs	r5, #16
		add_round_key(state, s->words + Nb*i);
 8019a6e:	f7ff fe1d 	bl	80196ac <add_round_key>
	mult_row_column(t, s);
 8019a72:	4669      	mov	r1, sp
 8019a74:	a804      	add	r0, sp, #16
 8019a76:	f7ff fe6b 	bl	8019750 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
 8019a7a:	a901      	add	r1, sp, #4
 8019a7c:	a805      	add	r0, sp, #20
 8019a7e:	f7ff fe67 	bl	8019750 <mult_row_column>
	mult_row_column(&t[2*Nb], s+(2*Nb));
 8019a82:	a902      	add	r1, sp, #8
 8019a84:	a806      	add	r0, sp, #24
 8019a86:	f7ff fe63 	bl	8019750 <mult_row_column>
	mult_row_column(&t[3*Nb], s+(3*Nb));
 8019a8a:	a903      	add	r1, sp, #12
 8019a8c:	a807      	add	r0, sp, #28
 8019a8e:	f7ff fe5f 	bl	8019750 <mult_row_column>
	(void)_copy(s, sizeof(t), t, sizeof(t));
 8019a92:	2310      	movs	r3, #16
 8019a94:	4668      	mov	r0, sp
 8019a96:	eb0d 0203 	add.w	r2, sp, r3
 8019a9a:	4619      	mov	r1, r3
 8019a9c:	f001 f907 	bl	801acae <_copy>
	for (i = Nr - 1; i > 0; --i) {
 8019aa0:	42a5      	cmp	r5, r4
 8019aa2:	d197      	bne.n	80199d4 <tc_aes_decrypt+0x34>
	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
 8019aa4:	f89d 3000 	ldrb.w	r3, [sp]
	(void)_copy(s, sizeof(t), t, sizeof(t));
 8019aa8:	4668      	mov	r0, sp
	t[0]  = s[0]; t[1] = s[13]; t[2] = s[10]; t[3] = s[7];
 8019aaa:	f88d 3010 	strb.w	r3, [sp, #16]
 8019aae:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8019ab2:	f88d 3011 	strb.w	r3, [sp, #17]
 8019ab6:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8019aba:	f88d 3012 	strb.w	r3, [sp, #18]
 8019abe:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8019ac2:	f88d 3013 	strb.w	r3, [sp, #19]
	t[4]  = s[4]; t[5] = s[1]; t[6] = s[14]; t[7] = s[11];
 8019ac6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8019aca:	f88d 3014 	strb.w	r3, [sp, #20]
 8019ace:	f89d 3001 	ldrb.w	r3, [sp, #1]
 8019ad2:	f88d 3015 	strb.w	r3, [sp, #21]
 8019ad6:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8019ada:	f88d 3016 	strb.w	r3, [sp, #22]
 8019ade:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8019ae2:	f88d 3017 	strb.w	r3, [sp, #23]
	t[8]  = s[8]; t[9] = s[5]; t[10] = s[2]; t[11] = s[15];
 8019ae6:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8019aea:	f88d 3018 	strb.w	r3, [sp, #24]
 8019aee:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8019af2:	f88d 3019 	strb.w	r3, [sp, #25]
 8019af6:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8019afa:	f88d 301a 	strb.w	r3, [sp, #26]
 8019afe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8019b02:	f88d 301b 	strb.w	r3, [sp, #27]
	t[12] = s[12]; t[13] = s[9]; t[14] = s[6]; t[15] = s[3];
 8019b06:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8019b0a:	f88d 301c 	strb.w	r3, [sp, #28]
 8019b0e:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8019b12:	f88d 301d 	strb.w	r3, [sp, #29]
 8019b16:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8019b1a:	f88d 301e 	strb.w	r3, [sp, #30]
 8019b1e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8019b22:	f88d 301f 	strb.w	r3, [sp, #31]
	(void)_copy(s, sizeof(t), t, sizeof(t));
 8019b26:	2310      	movs	r3, #16
 8019b28:	eb0d 0203 	add.w	r2, sp, r3
 8019b2c:	4619      	mov	r1, r3
 8019b2e:	f001 f8be 	bl	801acae <_copy>
		inv_mix_columns(state);
	}

	inv_shift_rows(state);
	inv_sub_bytes(state);
 8019b32:	4668      	mov	r0, sp
 8019b34:	f7ff fe00 	bl	8019738 <inv_sub_bytes>
	add_round_key(state, s->words);
 8019b38:	4629      	mov	r1, r5
 8019b3a:	4668      	mov	r0, sp
 8019b3c:	f7ff fdb6 	bl	80196ac <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
 8019b40:	2310      	movs	r3, #16
 8019b42:	466a      	mov	r2, sp
 8019b44:	4630      	mov	r0, r6
 8019b46:	4619      	mov	r1, r3
 8019b48:	f001 f8b1 	bl	801acae <_copy>

	/*zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
 8019b4c:	4668      	mov	r0, sp
 8019b4e:	2210      	movs	r2, #16
 8019b50:	2100      	movs	r1, #0
 8019b52:	f001 f8b9 	bl	801acc8 <_set>


	return TC_CRYPTO_SUCCESS;
 8019b56:	2001      	movs	r0, #1
}
 8019b58:	b008      	add	sp, #32
 8019b5a:	bd70      	pop	{r4, r5, r6, pc}
		return TC_CRYPTO_FAIL;
 8019b5c:	4608      	mov	r0, r1
 8019b5e:	e7fb      	b.n	8019b58 <tc_aes_decrypt+0x1b8>
 8019b60:	4610      	mov	r0, r2
 8019b62:	e7f9      	b.n	8019b58 <tc_aes_decrypt+0x1b8>

08019b64 <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
 8019b64:	b5f0      	push	{r4, r5, r6, r7, lr}
	const unsigned int rconst[11] = {
 8019b66:	4e28      	ldr	r6, [pc, #160]	@ (8019c08 <tc_aes128_set_encrypt_key+0xa4>)
{
 8019b68:	b08d      	sub	sp, #52	@ 0x34
 8019b6a:	4607      	mov	r7, r0
 8019b6c:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
 8019b6e:	ad01      	add	r5, sp, #4
 8019b70:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8019b72:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019b74:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8019b76:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8019b78:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 8019b7c:	e885 0007 	stmia.w	r5, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
 8019b80:	2f00      	cmp	r7, #0
 8019b82:	d03d      	beq.n	8019c00 <tc_aes128_set_encrypt_key+0x9c>
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
 8019b84:	2c00      	cmp	r4, #0
 8019b86:	d03d      	beq.n	8019c04 <tc_aes128_set_encrypt_key+0xa0>
 8019b88:	1f38      	subs	r0, r7, #4
 8019b8a:	4621      	mov	r1, r4
 8019b8c:	3410      	adds	r4, #16
 8019b8e:	4602      	mov	r2, r0
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
 8019b90:	784b      	ldrb	r3, [r1, #1]
	for (i = 0; i < Nk; ++i) {
 8019b92:	3104      	adds	r1, #4
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
 8019b94:	f811 5c04 	ldrb.w	r5, [r1, #-4]
 8019b98:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
 8019b9a:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
 8019b9e:	f811 5c01 	ldrb.w	r5, [r1, #-1]
 8019ba2:	432b      	orrs	r3, r5
 8019ba4:	f811 5c02 	ldrb.w	r5, [r1, #-2]
	for (i = 0; i < Nk; ++i) {
 8019ba8:	428c      	cmp	r4, r1
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
 8019baa:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
 8019bae:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
 8019bb2:	d1ed      	bne.n	8019b90 <tc_aes128_set_encrypt_key+0x2c>
 8019bb4:	2104      	movs	r1, #4
	}

	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
 8019bb6:	4c15      	ldr	r4, [pc, #84]	@ (8019c0c <tc_aes128_set_encrypt_key+0xa8>)
		if ((i % Nk) == 0) {
 8019bb8:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
 8019bba:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
 8019bbc:	d116      	bne.n	8019bec <tc_aes128_set_encrypt_key+0x88>
			t = subword(rotword(t)) ^ rconst[i/Nk];
 8019bbe:	f3c3 4207 	ubfx	r2, r3, #16, #8
 8019bc2:	5ca5      	ldrb	r5, [r4, r2]
 8019bc4:	0e1a      	lsrs	r2, r3, #24
 8019bc6:	5ca2      	ldrb	r2, [r4, r2]
 8019bc8:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
 8019bcc:	f3c3 2507 	ubfx	r5, r3, #8, #8
 8019bd0:	b2db      	uxtb	r3, r3
 8019bd2:	5d65      	ldrb	r5, [r4, r5]
 8019bd4:	5ce3      	ldrb	r3, [r4, r3]
 8019bd6:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
 8019bda:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 8019bde:	f021 0303 	bic.w	r3, r1, #3
 8019be2:	3330      	adds	r3, #48	@ 0x30
 8019be4:	446b      	add	r3, sp
 8019be6:	f853 3c2c 	ldr.w	r3, [r3, #-44]
 8019bea:	4053      	eors	r3, r2
		}
		s->words[i] = s->words[i-Nk] ^ t;
 8019bec:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
 8019bf0:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
 8019bf2:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
 8019bf4:	292c      	cmp	r1, #44	@ 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
 8019bf6:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
 8019bf8:	d1de      	bne.n	8019bb8 <tc_aes128_set_encrypt_key+0x54>
	}

	return TC_CRYPTO_SUCCESS;
 8019bfa:	2001      	movs	r0, #1
}
 8019bfc:	b00d      	add	sp, #52	@ 0x34
 8019bfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
 8019c00:	4638      	mov	r0, r7
 8019c02:	e7fb      	b.n	8019bfc <tc_aes128_set_encrypt_key+0x98>
 8019c04:	4620      	mov	r0, r4
 8019c06:	e7f9      	b.n	8019bfc <tc_aes128_set_encrypt_key+0x98>
 8019c08:	0801bf98 	.word	0x0801bf98
 8019c0c:	0801c528 	.word	0x0801c528

08019c10 <tc_cbc_mode_decrypt>:
}

int tc_cbc_mode_decrypt(uint8_t *out, unsigned int outlen, const uint8_t *in,
			    unsigned int inlen, const uint8_t *iv,
			    const TCAesKeySched_t sched)
{
 8019c10:	e92d 45f0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, lr}
 8019c14:	b085      	sub	sp, #20
 8019c16:	4680      	mov	r8, r0
 8019c18:	460f      	mov	r7, r1
 8019c1a:	4614      	mov	r4, r2
 8019c1c:	9d0d      	ldr	r5, [sp, #52]	@ 0x34
	uint8_t buffer[TC_AES_BLOCK_SIZE];
	const uint8_t *p;
	unsigned int n, m;

	/* sanity check the inputs */
	if (out == (uint8_t *) 0 ||
 8019c1e:	b340      	cbz	r0, 8019c72 <tc_cbc_mode_decrypt+0x62>
 8019c20:	b33a      	cbz	r2, 8019c72 <tc_cbc_mode_decrypt+0x62>
	    in == (const uint8_t *) 0 ||
 8019c22:	b335      	cbz	r5, 8019c72 <tc_cbc_mode_decrypt+0x62>
	    sched == (TCAesKeySched_t) 0 ||
 8019c24:	b32b      	cbz	r3, 8019c72 <tc_cbc_mode_decrypt+0x62>
	    inlen == 0 ||
 8019c26:	b321      	cbz	r1, 8019c72 <tc_cbc_mode_decrypt+0x62>
 8019c28:	ea43 0001 	orr.w	r0, r3, r1
	    outlen == 0 ||
	    (inlen % TC_AES_BLOCK_SIZE) != 0 ||
 8019c2c:	f010 000f 	ands.w	r0, r0, #15
 8019c30:	d11f      	bne.n	8019c72 <tc_cbc_mode_decrypt+0x62>
	    (outlen % TC_AES_BLOCK_SIZE) != 0 ||
 8019c32:	428b      	cmp	r3, r1
 8019c34:	d118      	bne.n	8019c68 <tc_cbc_mode_decrypt+0x58>
	 * Note that in == iv + ciphertext, i.e. the iv and the ciphertext are
	 * contiguous. This allows for a very efficient decryption algorithm
	 * that would not otherwise be possible.
	 */
	p = iv;
	for (n = m = 0; n < outlen; ++n) {
 8019c36:	4606      	mov	r6, r0
		if ((n % TC_AES_BLOCK_SIZE) == 0) {
 8019c38:	f016 0a0f 	ands.w	sl, r6, #15
 8019c3c:	d106      	bne.n	8019c4c <tc_cbc_mode_decrypt+0x3c>
			(void)tc_aes_decrypt(buffer, in, sched);
 8019c3e:	4621      	mov	r1, r4
 8019c40:	462a      	mov	r2, r5
 8019c42:	4668      	mov	r0, sp
			in += TC_AES_BLOCK_SIZE;
 8019c44:	3410      	adds	r4, #16
			(void)tc_aes_decrypt(buffer, in, sched);
 8019c46:	f7ff feab 	bl	80199a0 <tc_aes_decrypt>
			m = 0;
 8019c4a:	4650      	mov	r0, sl
		}
		*out++ = buffer[m++] ^ *p++;
 8019c4c:	f100 0310 	add.w	r3, r0, #16
 8019c50:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8019c52:	446b      	add	r3, sp
 8019c54:	5d92      	ldrb	r2, [r2, r6]
 8019c56:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 8019c5a:	4053      	eors	r3, r2
 8019c5c:	f808 3006 	strb.w	r3, [r8, r6]
	for (n = m = 0; n < outlen; ++n) {
 8019c60:	3601      	adds	r6, #1
 8019c62:	42b7      	cmp	r7, r6
 8019c64:	d103      	bne.n	8019c6e <tc_cbc_mode_decrypt+0x5e>
	}

	return TC_CRYPTO_SUCCESS;
 8019c66:	2001      	movs	r0, #1
}
 8019c68:	b005      	add	sp, #20
 8019c6a:	e8bd 85f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, pc}
 8019c6e:	3001      	adds	r0, #1
 8019c70:	e7e2      	b.n	8019c38 <tc_cbc_mode_decrypt+0x28>
		return TC_CRYPTO_FAIL;
 8019c72:	2000      	movs	r0, #0
 8019c74:	e7f8      	b.n	8019c68 <tc_cbc_mode_decrypt+0x58>

08019c76 <uECC_vli_add>:

/* Computes result = left + right, returning carry, in constant time.
 * Can modify in place. */
static uECC_word_t uECC_vli_add(uECC_word_t *result, const uECC_word_t *left,
				const uECC_word_t *right, wordcount_t num_words)
{
 8019c76:	b5f0      	push	{r4, r5, r6, r7, lr}
	uECC_word_t carry = 0;
	wordcount_t i;
	for (i = 0; i < num_words; ++i) {
 8019c78:	2400      	movs	r4, #0
{
 8019c7a:	4607      	mov	r7, r0
	uECC_word_t carry = 0;
 8019c7c:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
 8019c7e:	b265      	sxtb	r5, r4
 8019c80:	42ab      	cmp	r3, r5
 8019c82:	dc00      	bgt.n	8019c86 <uECC_vli_add+0x10>
		uECC_word_t val = (sum < left[i]);
		carry = cond_set(val, carry, (sum != left[i]));
		result[i] = sum;
	}
	return carry;
}
 8019c84:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
 8019c86:	f851 5024 	ldr.w	r5, [r1, r4, lsl #2]
 8019c8a:	f852 6024 	ldr.w	r6, [r2, r4, lsl #2]
 8019c8e:	442e      	add	r6, r5
 8019c90:	4406      	add	r6, r0
	return (p_true*(cond)) | (p_false*(!cond));
 8019c92:	42b5      	cmp	r5, r6
		result[i] = sum;
 8019c94:	f847 6024 	str.w	r6, [r7, r4, lsl #2]
 8019c98:	f104 0401 	add.w	r4, r4, #1
	return (p_true*(cond)) | (p_false*(!cond));
 8019c9c:	bf0c      	ite	eq
 8019c9e:	4605      	moveq	r5, r0
 8019ca0:	2500      	movne	r5, #0
 8019ca2:	bf94      	ite	ls
 8019ca4:	4628      	movls	r0, r5
 8019ca6:	f045 0001 	orrhi.w	r0, r5, #1
	for (i = 0; i < num_words; ++i) {
 8019caa:	e7e8      	b.n	8019c7e <uECC_vli_add+0x8>

08019cac <uECC_vli_rshift1>:
static void uECC_vli_rshift1(uECC_word_t *vli, wordcount_t num_words)
{
	uECC_word_t *end = vli;
	uECC_word_t carry = 0;

	vli += num_words;
 8019cac:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	uECC_word_t carry = 0;
 8019cb0:	2300      	movs	r3, #0
	while (vli-- > end) {
 8019cb2:	4281      	cmp	r1, r0
 8019cb4:	d800      	bhi.n	8019cb8 <uECC_vli_rshift1+0xc>
		uECC_word_t temp = *vli;
		*vli = (temp >> 1) | carry;
		carry = temp << (uECC_WORD_BITS - 1);
	}
}
 8019cb6:	4770      	bx	lr
		uECC_word_t temp = *vli;
 8019cb8:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
 8019cbc:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 8019cc0:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
 8019cc2:	07d3      	lsls	r3, r2, #31
 8019cc4:	e7f5      	b.n	8019cb2 <uECC_vli_rshift1+0x6>

08019cc6 <vli_modInv_update>:
			      wordcount_t num_words)
{

	uECC_word_t carry = 0;

	if (!EVEN(uv)) {
 8019cc6:	6803      	ldr	r3, [r0, #0]
{
 8019cc8:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
 8019cca:	f013 0501 	ands.w	r5, r3, #1
{
 8019cce:	4606      	mov	r6, r0
 8019cd0:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
 8019cd2:	d005      	beq.n	8019ce0 <vli_modInv_update+0x1a>
		carry = uECC_vli_add(uv, uv, mod, num_words);
 8019cd4:	4613      	mov	r3, r2
 8019cd6:	460a      	mov	r2, r1
 8019cd8:	4601      	mov	r1, r0
 8019cda:	f7ff ffcc 	bl	8019c76 <uECC_vli_add>
 8019cde:	4605      	mov	r5, r0
	}
	uECC_vli_rshift1(uv, num_words);
 8019ce0:	4621      	mov	r1, r4
 8019ce2:	4630      	mov	r0, r6
 8019ce4:	f7ff ffe2 	bl	8019cac <uECC_vli_rshift1>
	if (carry) {
 8019ce8:	b145      	cbz	r5, 8019cfc <vli_modInv_update+0x36>
		uv[num_words - 1] |= HIGH_BIT_SET;
 8019cea:	f104 4280 	add.w	r2, r4, #1073741824	@ 0x40000000
 8019cee:	3a01      	subs	r2, #1
 8019cf0:	f856 3022 	ldr.w	r3, [r6, r2, lsl #2]
 8019cf4:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8019cf8:	f846 3022 	str.w	r3, [r6, r2, lsl #2]
	}
}
 8019cfc:	bd70      	pop	{r4, r5, r6, pc}

08019cfe <uECC_vli_mult>:
{
 8019cfe:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (k = 0; k < num_words; ++k) {
 8019d02:	2700      	movs	r7, #0
{
 8019d04:	9200      	str	r2, [sp, #0]
	uECC_word_t r1 = 0;
 8019d06:	463d      	mov	r5, r7
	uECC_word_t r0 = 0;
 8019d08:	463c      	mov	r4, r7
	for (k = 0; k < num_words; ++k) {
 8019d0a:	fa4f f987 	sxtb.w	r9, r7
 8019d0e:	454b      	cmp	r3, r9
 8019d10:	dc14      	bgt.n	8019d3c <uECC_vli_mult+0x3e>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
 8019d12:	f04f 36ff 	mov.w	r6, #4294967295
 8019d16:	f04f 0800 	mov.w	r8, #0
 8019d1a:	eb06 0243 	add.w	r2, r6, r3, lsl #1
 8019d1e:	9201      	str	r2, [sp, #4]
 8019d20:	eb08 0e03 	add.w	lr, r8, r3
 8019d24:	9a01      	ldr	r2, [sp, #4]
 8019d26:	fa4f fe8e 	sxtb.w	lr, lr
 8019d2a:	4596      	cmp	lr, r2
 8019d2c:	db29      	blt.n	8019d82 <uECC_vli_mult+0x84>
	result[num_words * 2 - 1] = r0;
 8019d2e:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 8019d32:	f840 4c04 	str.w	r4, [r0, #-4]
}
 8019d36:	b003      	add	sp, #12
 8019d38:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019d3c:	9a00      	ldr	r2, [sp, #0]
	for (k = 0; k < num_words; ++k) {
 8019d3e:	f04f 0e00 	mov.w	lr, #0
 8019d42:	eb02 0a87 	add.w	sl, r2, r7, lsl #2
 8019d46:	46f0      	mov	r8, lr
	uECC_dword_t p = (uECC_dword_t)a * b;
 8019d48:	f851 202e 	ldr.w	r2, [r1, lr, lsl #2]
		for (i = 0; i <= k; ++i) {
 8019d4c:	f10e 0e01 	add.w	lr, lr, #1
			muladd(left[i], right[k - i], &r0, &r1, &r2);
 8019d50:	f85a 6904 	ldr.w	r6, [sl], #-4
	r01 += p;
 8019d54:	f04f 0b00 	mov.w	fp, #0
	uECC_dword_t p = (uECC_dword_t)a * b;
 8019d58:	fba2 6c06 	umull	r6, ip, r2, r6
 8019d5c:	1936      	adds	r6, r6, r4
 8019d5e:	eb5c 0c05 	adcs.w	ip, ip, r5
	*r0 = (uECC_word_t)r01;
 8019d62:	4634      	mov	r4, r6
		for (i = 0; i <= k; ++i) {
 8019d64:	fa4f f68e 	sxtb.w	r6, lr
 8019d68:	bf28      	it	cs
 8019d6a:	f04f 0b01 	movcs.w	fp, #1
	*r1 = r01 >> uECC_WORD_BITS;
 8019d6e:	4665      	mov	r5, ip
		for (i = 0; i <= k; ++i) {
 8019d70:	45b1      	cmp	r9, r6
	*r2 += (r01 < p);
 8019d72:	44d8      	add	r8, fp
		for (i = 0; i <= k; ++i) {
 8019d74:	dae8      	bge.n	8019d48 <uECC_vli_mult+0x4a>
		result[k] = r0;
 8019d76:	f840 4027 	str.w	r4, [r0, r7, lsl #2]
		r1 = r2;
 8019d7a:	4645      	mov	r5, r8
 8019d7c:	3701      	adds	r7, #1
		r0 = r1;
 8019d7e:	4664      	mov	r4, ip
 8019d80:	e7c3      	b.n	8019d0a <uECC_vli_mult+0xc>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 8019d82:	f108 0701 	add.w	r7, r8, #1
 8019d86:	9a00      	ldr	r2, [sp, #0]
 8019d88:	46a9      	mov	r9, r5
 8019d8a:	2500      	movs	r5, #0
 8019d8c:	b27f      	sxtb	r7, r7
 8019d8e:	eb02 0a8e 	add.w	sl, r2, lr, lsl #2
 8019d92:	b27e      	sxtb	r6, r7
 8019d94:	42b3      	cmp	r3, r6
 8019d96:	dc05      	bgt.n	8019da4 <uECC_vli_mult+0xa6>
		result[k] = r0;
 8019d98:	f840 402e 	str.w	r4, [r0, lr, lsl #2]
	for (k = num_words; k < num_words * 2 - 1; ++k) {
 8019d9c:	f108 0801 	add.w	r8, r8, #1
		r0 = r1;
 8019da0:	464c      	mov	r4, r9
 8019da2:	e7bd      	b.n	8019d20 <uECC_vli_mult+0x22>
			muladd(left[i], right[k - i], &r0, &r1, &r2);
 8019da4:	f06f 0203 	mvn.w	r2, #3
 8019da8:	f04f 0b00 	mov.w	fp, #0
 8019dac:	fb02 f607 	mul.w	r6, r2, r7
	uECC_dword_t p = (uECC_dword_t)a * b;
 8019db0:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
 8019db4:	3701      	adds	r7, #1
 8019db6:	f85a 6006 	ldr.w	r6, [sl, r6]
 8019dba:	fba6 6c02 	umull	r6, ip, r6, r2
 8019dbe:	1936      	adds	r6, r6, r4
 8019dc0:	eb5c 0c09 	adcs.w	ip, ip, r9
	*r0 = (uECC_word_t)r01;
 8019dc4:	4634      	mov	r4, r6
 8019dc6:	bf28      	it	cs
 8019dc8:	f04f 0b01 	movcs.w	fp, #1
	*r1 = r01 >> uECC_WORD_BITS;
 8019dcc:	46e1      	mov	r9, ip
	*r2 += (r01 < p);
 8019dce:	445d      	add	r5, fp
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 8019dd0:	e7df      	b.n	8019d92 <uECC_vli_mult+0x94>

08019dd2 <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
 8019dd2:	2300      	movs	r3, #0
{
 8019dd4:	b510      	push	{r4, lr}
		 vli[i] = 0;
 8019dd6:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
 8019dd8:	b25a      	sxtb	r2, r3
 8019dda:	4291      	cmp	r1, r2
 8019ddc:	dc00      	bgt.n	8019de0 <uECC_vli_clear+0xe>
}
 8019dde:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
 8019de0:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
 8019de4:	3301      	adds	r3, #1
 8019de6:	e7f7      	b.n	8019dd8 <uECC_vli_clear+0x6>

08019de8 <uECC_vli_isZero>:
	for (i = 0; i < num_words; ++i) {
 8019de8:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
 8019dea:	461a      	mov	r2, r3
{
 8019dec:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
 8019dee:	b25c      	sxtb	r4, r3
 8019df0:	42a1      	cmp	r1, r4
 8019df2:	dc03      	bgt.n	8019dfc <uECC_vli_isZero+0x14>
}
 8019df4:	fab2 f082 	clz	r0, r2
 8019df8:	0940      	lsrs	r0, r0, #5
 8019dfa:	bd10      	pop	{r4, pc}
		bits |= vli[i];
 8019dfc:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 8019e00:	3301      	adds	r3, #1
 8019e02:	4322      	orrs	r2, r4
	for (i = 0; i < num_words; ++i) {
 8019e04:	e7f3      	b.n	8019dee <uECC_vli_isZero+0x6>

08019e06 <uECC_vli_testBit>:
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 8019e06:	114a      	asrs	r2, r1, #5
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 8019e08:	2301      	movs	r3, #1
 8019e0a:	f001 011f 	and.w	r1, r1, #31
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 8019e0e:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 8019e12:	408b      	lsls	r3, r1
}
 8019e14:	4018      	ands	r0, r3
 8019e16:	4770      	bx	lr

08019e18 <uECC_vli_numBits>:
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 8019e18:	1e4b      	subs	r3, r1, #1
{
 8019e1a:	b510      	push	{r4, lr}
 8019e1c:	b25b      	sxtb	r3, r3
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 8019e1e:	1d04      	adds	r4, r0, #4
 8019e20:	061a      	lsls	r2, r3, #24
 8019e22:	d403      	bmi.n	8019e2c <uECC_vli_numBits+0x14>
 8019e24:	1e5a      	subs	r2, r3, #1
 8019e26:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 8019e2a:	b161      	cbz	r1, 8019e46 <uECC_vli_numBits+0x2e>
	return (i + 1);
 8019e2c:	3301      	adds	r3, #1
 8019e2e:	b25b      	sxtb	r3, r3
	if (num_digits == 0) {
 8019e30:	b15b      	cbz	r3, 8019e4a <uECC_vli_numBits+0x32>
	digit = vli[num_digits - 1];
 8019e32:	f103 4280 	add.w	r2, r3, #1073741824	@ 0x40000000
 8019e36:	3a01      	subs	r2, #1
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
 8019e38:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 8019e3c:	fab2 f282 	clz	r2, r2
 8019e40:	ebc2 1043 	rsb	r0, r2, r3, lsl #5
}
 8019e44:	bd10      	pop	{r4, pc}
 8019e46:	4613      	mov	r3, r2
 8019e48:	e7ea      	b.n	8019e20 <uECC_vli_numBits+0x8>
 8019e4a:	4618      	mov	r0, r3
 8019e4c:	e7fa      	b.n	8019e44 <uECC_vli_numBits+0x2c>

08019e4e <uECC_vli_set>:
	for (i = 0; i < num_words; ++i) {
 8019e4e:	2300      	movs	r3, #0
{
 8019e50:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
 8019e52:	b25c      	sxtb	r4, r3
 8019e54:	42a2      	cmp	r2, r4
 8019e56:	dc00      	bgt.n	8019e5a <uECC_vli_set+0xc>
}
 8019e58:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
 8019e5a:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
 8019e5e:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
 8019e62:	3301      	adds	r3, #1
 8019e64:	e7f5      	b.n	8019e52 <uECC_vli_set+0x4>

08019e66 <uECC_vli_cmp_unsafe>:
	for (i = num_words - 1; i >= 0; --i) {
 8019e66:	3a01      	subs	r2, #1
 8019e68:	b252      	sxtb	r2, r2
{
 8019e6a:	b510      	push	{r4, lr}
	for (i = num_words - 1; i >= 0; --i) {
 8019e6c:	0613      	lsls	r3, r2, #24
 8019e6e:	d501      	bpl.n	8019e74 <uECC_vli_cmp_unsafe+0xe>
	return 0;
 8019e70:	2000      	movs	r0, #0
}
 8019e72:	bd10      	pop	{r4, pc}
		if (left[i] > right[i]) {
 8019e74:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
 8019e78:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
 8019e7c:	429c      	cmp	r4, r3
 8019e7e:	d805      	bhi.n	8019e8c <uECC_vli_cmp_unsafe+0x26>
		} else if (left[i] < right[i]) {
 8019e80:	f102 32ff 	add.w	r2, r2, #4294967295
 8019e84:	d2f2      	bcs.n	8019e6c <uECC_vli_cmp_unsafe+0x6>
			return -1;
 8019e86:	f04f 30ff 	mov.w	r0, #4294967295
 8019e8a:	e7f2      	b.n	8019e72 <uECC_vli_cmp_unsafe+0xc>
			return 1;
 8019e8c:	2001      	movs	r0, #1
 8019e8e:	e7f0      	b.n	8019e72 <uECC_vli_cmp_unsafe+0xc>

08019e90 <uECC_vli_equal>:
	for (i = num_words - 1; i >= 0; --i) {
 8019e90:	3a01      	subs	r2, #1
	uECC_word_t diff = 0;
 8019e92:	2300      	movs	r3, #0
 8019e94:	b252      	sxtb	r2, r2
{
 8019e96:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
 8019e98:	0614      	lsls	r4, r2, #24
 8019e9a:	d503      	bpl.n	8019ea4 <uECC_vli_equal+0x14>
}
 8019e9c:	1e18      	subs	r0, r3, #0
 8019e9e:	bf18      	it	ne
 8019ea0:	2001      	movne	r0, #1
 8019ea2:	bd30      	pop	{r4, r5, pc}
		diff |= (left[i] ^ right[i]);
 8019ea4:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
 8019ea8:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
 8019eac:	3a01      	subs	r2, #1
 8019eae:	406c      	eors	r4, r5
 8019eb0:	4323      	orrs	r3, r4
	for (i = num_words - 1; i >= 0; --i) {
 8019eb2:	e7f1      	b.n	8019e98 <uECC_vli_equal+0x8>

08019eb4 <uECC_vli_sub>:
{
 8019eb4:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
 8019eb6:	2400      	movs	r4, #0
{
 8019eb8:	4607      	mov	r7, r0
 8019eba:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
 8019ebc:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
 8019ebe:	b265      	sxtb	r5, r4
 8019ec0:	45ac      	cmp	ip, r5
 8019ec2:	dc00      	bgt.n	8019ec6 <uECC_vli_sub+0x12>
}
 8019ec4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
 8019ec6:	f851 5024 	ldr.w	r5, [r1, r4, lsl #2]
 8019eca:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
 8019ece:	1a2e      	subs	r6, r5, r0
 8019ed0:	1af6      	subs	r6, r6, r3
	return (p_true*(cond)) | (p_false*(!cond));
 8019ed2:	42b5      	cmp	r5, r6
		result[i] = diff;
 8019ed4:	f847 6024 	str.w	r6, [r7, r4, lsl #2]
 8019ed8:	f104 0401 	add.w	r4, r4, #1
	return (p_true*(cond)) | (p_false*(!cond));
 8019edc:	bf0c      	ite	eq
 8019ede:	4605      	moveq	r5, r0
 8019ee0:	2500      	movne	r5, #0
 8019ee2:	bf2c      	ite	cs
 8019ee4:	4628      	movcs	r0, r5
 8019ee6:	f045 0001 	orrcc.w	r0, r5, #1
	for (i = 0; i < num_words; ++i) {
 8019eea:	e7e8      	b.n	8019ebe <uECC_vli_sub+0xa>

08019eec <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
 8019eec:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
 8019eee:	2208      	movs	r2, #8
{
 8019ef0:	b089      	sub	sp, #36	@ 0x24
	uECC_vli_set(result, product, NUM_ECC_WORDS);
 8019ef2:	f7ff ffac 	bl	8019e4e <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
	tmp[3] = product[11];
 8019ef6:	6acb      	ldr	r3, [r1, #44]	@ 0x2c
{
 8019ef8:	4606      	mov	r6, r0
	tmp[0] = tmp[1] = tmp[2] = 0;
 8019efa:	2700      	movs	r7, #0
	tmp[3] = product[11];
 8019efc:	9303      	str	r3, [sp, #12]
{
 8019efe:	460c      	mov	r4, r1
	tmp[4] = product[12];
 8019f00:	6b0b      	ldr	r3, [r1, #48]	@ 0x30
	tmp[5] = product[13];
	tmp[6] = product[14];
	tmp[7] = product[15];
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 8019f02:	4668      	mov	r0, sp
	tmp[0] = tmp[1] = tmp[2] = 0;
 8019f04:	9700      	str	r7, [sp, #0]
	tmp[4] = product[12];
 8019f06:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
 8019f08:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
 8019f0a:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
 8019f0c:	6b8b      	ldr	r3, [r1, #56]	@ 0x38
 8019f0e:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
 8019f10:	6bcb      	ldr	r3, [r1, #60]	@ 0x3c
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 8019f12:	4669      	mov	r1, sp
	tmp[7] = product[15];
 8019f14:	9307      	str	r3, [sp, #28]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 8019f16:	4613      	mov	r3, r2
 8019f18:	466a      	mov	r2, sp
	tmp[0] = tmp[1] = tmp[2] = 0;
 8019f1a:	e9cd 7701 	strd	r7, r7, [sp, #4]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 8019f1e:	f7ff feaa 	bl	8019c76 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 8019f22:	4631      	mov	r1, r6
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 8019f24:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 8019f26:	4630      	mov	r0, r6
 8019f28:	f7ff fea5 	bl	8019c76 <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
 8019f2c:	6b21      	ldr	r1, [r4, #48]	@ 0x30
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 8019f2e:	4405      	add	r5, r0
	tmp[4] = product[13];
	tmp[5] = product[14];
	tmp[6] = product[15];
	tmp[7] = 0;
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 8019f30:	4668      	mov	r0, sp
	tmp[3] = product[12];
 8019f32:	9103      	str	r1, [sp, #12]
	tmp[4] = product[13];
 8019f34:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8019f36:	9104      	str	r1, [sp, #16]
	tmp[5] = product[14];
 8019f38:	6ba1      	ldr	r1, [r4, #56]	@ 0x38
 8019f3a:	9105      	str	r1, [sp, #20]
	tmp[6] = product[15];
 8019f3c:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
	tmp[7] = 0;
 8019f3e:	e9cd 1706 	strd	r1, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 8019f42:	4669      	mov	r1, sp
 8019f44:	f7ff fe97 	bl	8019c76 <uECC_vli_add>
 8019f48:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 8019f4a:	4631      	mov	r1, r6
 8019f4c:	4630      	mov	r0, r6
 8019f4e:	f7ff fe92 	bl	8019c76 <uECC_vli_add>
 8019f52:	4405      	add	r5, r0

	/* s3 */
	tmp[0] = product[8];
 8019f54:	6a20      	ldr	r0, [r4, #32]
	tmp[1] = product[9];
	tmp[2] = product[10];
	tmp[3] = tmp[4] = tmp[5] = 0;
 8019f56:	9703      	str	r7, [sp, #12]
	tmp[0] = product[8];
 8019f58:	9000      	str	r0, [sp, #0]
	tmp[1] = product[9];
 8019f5a:	6a60      	ldr	r0, [r4, #36]	@ 0x24
 8019f5c:	9001      	str	r0, [sp, #4]
	tmp[2] = product[10];
 8019f5e:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8019f60:	9002      	str	r0, [sp, #8]
	tmp[6] = product[14];
 8019f62:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 8019f64:	9006      	str	r0, [sp, #24]
	tmp[7] = product[15];
 8019f66:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8019f68:	9007      	str	r0, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 8019f6a:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
 8019f6c:	e9cd 7704 	strd	r7, r7, [sp, #16]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 8019f70:	f7ff fe81 	bl	8019c76 <uECC_vli_add>
 8019f74:	4405      	add	r5, r0

	/* s4 */
	tmp[0] = product[9];
 8019f76:	6a60      	ldr	r0, [r4, #36]	@ 0x24
	tmp[1] = product[10];
	tmp[2] = product[11];
	tmp[3] = product[13];
 8019f78:	f8d4 c034 	ldr.w	ip, [r4, #52]	@ 0x34
	tmp[0] = product[9];
 8019f7c:	9000      	str	r0, [sp, #0]
	tmp[1] = product[10];
 8019f7e:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
	tmp[3] = product[13];
 8019f80:	f8cd c00c 	str.w	ip, [sp, #12]
	tmp[1] = product[10];
 8019f84:	9001      	str	r0, [sp, #4]
	tmp[2] = product[11];
 8019f86:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8019f88:	9002      	str	r0, [sp, #8]
	tmp[4] = product[14];
 8019f8a:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
 8019f8c:	9004      	str	r0, [sp, #16]
	tmp[5] = product[15];
 8019f8e:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
	tmp[6] = product[13];
 8019f90:	e9cd 0c05 	strd	r0, ip, [sp, #20]
	tmp[7] = product[8];
 8019f94:	6a20      	ldr	r0, [r4, #32]
 8019f96:	9007      	str	r0, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 8019f98:	4630      	mov	r0, r6
 8019f9a:	f7ff fe6c 	bl	8019c76 <uECC_vli_add>
 8019f9e:	4405      	add	r5, r0

	/* d1 */
	tmp[0] = product[11];
 8019fa0:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
	tmp[1] = product[12];
	tmp[2] = product[13];
	tmp[3] = tmp[4] = tmp[5] = 0;
 8019fa2:	9703      	str	r7, [sp, #12]
	tmp[0] = product[11];
 8019fa4:	9000      	str	r0, [sp, #0]
	tmp[1] = product[12];
 8019fa6:	6b20      	ldr	r0, [r4, #48]	@ 0x30
 8019fa8:	9001      	str	r0, [sp, #4]
	tmp[2] = product[13];
 8019faa:	6b60      	ldr	r0, [r4, #52]	@ 0x34
 8019fac:	9002      	str	r0, [sp, #8]
	tmp[6] = product[8];
 8019fae:	6a20      	ldr	r0, [r4, #32]
 8019fb0:	9006      	str	r0, [sp, #24]
	tmp[7] = product[10];
 8019fb2:	6aa0      	ldr	r0, [r4, #40]	@ 0x28
 8019fb4:	9007      	str	r0, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 8019fb6:	4630      	mov	r0, r6
	tmp[3] = tmp[4] = tmp[5] = 0;
 8019fb8:	e9cd 7704 	strd	r7, r7, [sp, #16]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 8019fbc:	f7ff ff7a 	bl	8019eb4 <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
 8019fc0:	6b23      	ldr	r3, [r4, #48]	@ 0x30
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 8019fc2:	1a2d      	subs	r5, r5, r0
	tmp[2] = product[14];
	tmp[3] = product[15];
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
	tmp[7] = product[11];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 8019fc4:	4630      	mov	r0, r6
	tmp[0] = product[12];
 8019fc6:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
 8019fc8:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8019fca:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
 8019fcc:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8019fce:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
 8019fd0:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8019fd2:	9303      	str	r3, [sp, #12]
	tmp[6] = product[9];
 8019fd4:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8019fd6:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
 8019fd8:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 8019fda:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 8019fdc:	2308      	movs	r3, #8
 8019fde:	f7ff ff69 	bl	8019eb4 <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
 8019fe2:	6b63      	ldr	r3, [r4, #52]	@ 0x34
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 8019fe4:	1a2d      	subs	r5, r5, r0
	tmp[3] = product[8];
	tmp[4] = product[9];
	tmp[5] = product[10];
	tmp[6] = 0;
	tmp[7] = product[12];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 8019fe6:	4630      	mov	r0, r6
	tmp[0] = product[13];
 8019fe8:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
 8019fea:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8019fec:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
 8019fee:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8019ff0:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
 8019ff2:	6a23      	ldr	r3, [r4, #32]
 8019ff4:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
 8019ff6:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8019ff8:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
 8019ffa:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
	tmp[6] = 0;
 8019ffc:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
 801a000:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 801a002:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 801a004:	2308      	movs	r3, #8
 801a006:	f7ff ff55 	bl	8019eb4 <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
 801a00a:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 801a00c:	1a2d      	subs	r5, r5, r0
	tmp[3] = product[9];
	tmp[4] = product[10];
	tmp[5] = product[11];
	tmp[6] = 0;
	tmp[7] = product[13];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 801a00e:	4630      	mov	r0, r6
	tmp[0] = product[14];
 801a010:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
 801a012:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
	tmp[2] = 0;
 801a014:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
 801a018:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 801a01a:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
 801a01c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 801a01e:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
 801a020:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 801a022:	9305      	str	r3, [sp, #20]
	tmp[7] = product[13];
 801a024:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 801a026:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 801a028:	2308      	movs	r3, #8
 801a02a:	f7ff ff43 	bl	8019eb4 <uECC_vli_sub>

	if (carry < 0) {
 801a02e:	1a2d      	subs	r5, r5, r0
 801a030:	d510      	bpl.n	801a054 <vli_mmod_fast_secp256r1+0x168>
		do {
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
 801a032:	2308      	movs	r3, #8
 801a034:	4a0c      	ldr	r2, [pc, #48]	@ (801a068 <vli_mmod_fast_secp256r1+0x17c>)
 801a036:	4631      	mov	r1, r6
 801a038:	4630      	mov	r0, r6
 801a03a:	f7ff fe1c 	bl	8019c76 <uECC_vli_add>
		}
		while (carry < 0);
 801a03e:	182d      	adds	r5, r5, r0
 801a040:	d4f7      	bmi.n	801a032 <vli_mmod_fast_secp256r1+0x146>
		while (carry || 
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
		}
	}
}
 801a042:	b009      	add	sp, #36	@ 0x24
 801a044:	bdf0      	pop	{r4, r5, r6, r7, pc}
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
 801a046:	2308      	movs	r3, #8
 801a048:	4a07      	ldr	r2, [pc, #28]	@ (801a068 <vli_mmod_fast_secp256r1+0x17c>)
 801a04a:	4631      	mov	r1, r6
 801a04c:	4630      	mov	r0, r6
 801a04e:	f7ff ff31 	bl	8019eb4 <uECC_vli_sub>
 801a052:	1a2d      	subs	r5, r5, r0
		while (carry || 
 801a054:	2d00      	cmp	r5, #0
 801a056:	d1f6      	bne.n	801a046 <vli_mmod_fast_secp256r1+0x15a>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
 801a058:	2208      	movs	r2, #8
 801a05a:	4631      	mov	r1, r6
 801a05c:	4802      	ldr	r0, [pc, #8]	@ (801a068 <vli_mmod_fast_secp256r1+0x17c>)
 801a05e:	f7ff ff02 	bl	8019e66 <uECC_vli_cmp_unsafe>
		while (carry || 
 801a062:	2801      	cmp	r0, #1
 801a064:	d1ef      	bne.n	801a046 <vli_mmod_fast_secp256r1+0x15a>
 801a066:	e7ec      	b.n	801a042 <vli_mmod_fast_secp256r1+0x156>
 801a068:	0801c62c 	.word	0x0801c62c

0801a06c <uECC_vli_modAdd>:
{
 801a06c:	b570      	push	{r4, r5, r6, lr}
 801a06e:	f99d 5010 	ldrsb.w	r5, [sp, #16]
 801a072:	461e      	mov	r6, r3
 801a074:	4604      	mov	r4, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 801a076:	462b      	mov	r3, r5
 801a078:	f7ff fdfd 	bl	8019c76 <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
 801a07c:	b930      	cbnz	r0, 801a08c <uECC_vli_modAdd+0x20>
 801a07e:	462a      	mov	r2, r5
 801a080:	4621      	mov	r1, r4
 801a082:	4630      	mov	r0, r6
 801a084:	f7ff feef 	bl	8019e66 <uECC_vli_cmp_unsafe>
 801a088:	2801      	cmp	r0, #1
 801a08a:	d007      	beq.n	801a09c <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
 801a08c:	462b      	mov	r3, r5
 801a08e:	4632      	mov	r2, r6
 801a090:	4621      	mov	r1, r4
 801a092:	4620      	mov	r0, r4
}
 801a094:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
 801a098:	f7ff bf0c 	b.w	8019eb4 <uECC_vli_sub>
}
 801a09c:	bd70      	pop	{r4, r5, r6, pc}

0801a09e <uECC_vli_modSub>:
{
 801a09e:	b570      	push	{r4, r5, r6, lr}
 801a0a0:	f99d 5010 	ldrsb.w	r5, [sp, #16]
 801a0a4:	461e      	mov	r6, r3
 801a0a6:	4604      	mov	r4, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 801a0a8:	462b      	mov	r3, r5
 801a0aa:	f7ff ff03 	bl	8019eb4 <uECC_vli_sub>
	if (l_borrow) {
 801a0ae:	b138      	cbz	r0, 801a0c0 <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
 801a0b0:	462b      	mov	r3, r5
 801a0b2:	4632      	mov	r2, r6
 801a0b4:	4621      	mov	r1, r4
 801a0b6:	4620      	mov	r0, r4
}
 801a0b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
 801a0bc:	f7ff bddb 	b.w	8019c76 <uECC_vli_add>
}
 801a0c0:	bd70      	pop	{r4, r5, r6, pc}

0801a0c2 <uECC_vli_mmod>:
{
 801a0c2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a0c6:	b0a5      	sub	sp, #148	@ 0x94
 801a0c8:	461d      	mov	r5, r3
 801a0ca:	4690      	mov	r8, r2
	uECC_word_t *v[2] = {tmp, product};
 801a0cc:	ab14      	add	r3, sp, #80	@ 0x50
{
 801a0ce:	9001      	str	r0, [sp, #4]
			   uECC_vli_numBits(mod, num_words);
 801a0d0:	4610      	mov	r0, r2
	uECC_vli_clear(mod_multiple, word_shift);
 801a0d2:	af04      	add	r7, sp, #16
	uECC_word_t *v[2] = {tmp, product};
 801a0d4:	e9cd 3102 	strd	r3, r1, [sp, #8]
			   uECC_vli_numBits(mod, num_words);
 801a0d8:	4629      	mov	r1, r5
 801a0da:	f7ff fe9d 	bl	8019e18 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
 801a0de:	ebc0 1485 	rsb	r4, r0, r5, lsl #6
	uECC_vli_clear(mod_multiple, word_shift);
 801a0e2:	4638      	mov	r0, r7
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
 801a0e4:	b224      	sxth	r4, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 801a0e6:	2c00      	cmp	r4, #0
 801a0e8:	4621      	mov	r1, r4
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 801a0ea:	f004 061f 	and.w	r6, r4, #31
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 801a0ee:	bfb8      	it	lt
 801a0f0:	f104 011f 	addlt.w	r1, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 801a0f4:	4263      	negs	r3, r4
 801a0f6:	f003 031f 	and.w	r3, r3, #31
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 801a0fa:	f341 1147 	sbfx	r1, r1, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 801a0fe:	bf58      	it	pl
 801a100:	425e      	negpl	r6, r3
	uECC_vli_clear(mod_multiple, word_shift);
 801a102:	f7ff fe66 	bl	8019dd2 <uECC_vli_clear>
	if (bit_shift > 0) {
 801a106:	2e00      	cmp	r6, #0
 801a108:	dd26      	ble.n	801a158 <uECC_vli_mmod+0x96>
	uECC_word_t carry = 0;
 801a10a:	2200      	movs	r2, #0
 801a10c:	eb07 0081 	add.w	r0, r7, r1, lsl #2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 801a110:	f1c6 0e20 	rsb	lr, r6, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 801a114:	4613      	mov	r3, r2
 801a116:	429d      	cmp	r5, r3
 801a118:	d813      	bhi.n	801a142 <uECC_vli_mmod+0x80>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 801a11a:	f105 38ff 	add.w	r8, r5, #4294967295
 801a11e:	ab24      	add	r3, sp, #144	@ 0x90
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 801a120:	2601      	movs	r6, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 801a122:	eb03 0888 	add.w	r8, r3, r8, lsl #2
	for (index = 1; shift >= 0; --shift) {
 801a126:	2c00      	cmp	r4, #0
 801a128:	da55      	bge.n	801a1d6 <uECC_vli_mmod+0x114>
	uECC_vli_set(result, v[index], num_words);
 801a12a:	ab24      	add	r3, sp, #144	@ 0x90
 801a12c:	462a      	mov	r2, r5
 801a12e:	9801      	ldr	r0, [sp, #4]
 801a130:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 801a134:	f856 1c88 	ldr.w	r1, [r6, #-136]
 801a138:	f7ff fe89 	bl	8019e4e <uECC_vli_set>
}
 801a13c:	b025      	add	sp, #148	@ 0x94
 801a13e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 801a142:	f858 c023 	ldr.w	ip, [r8, r3, lsl #2]
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 801a146:	3301      	adds	r3, #1
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 801a148:	fa0c f106 	lsl.w	r1, ip, r6
 801a14c:	430a      	orrs	r2, r1
 801a14e:	f840 2b04 	str.w	r2, [r0], #4
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 801a152:	fa2c f20e 	lsr.w	r2, ip, lr
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 801a156:	e7de      	b.n	801a116 <uECC_vli_mmod+0x54>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
 801a158:	eb07 0081 	add.w	r0, r7, r1, lsl #2
 801a15c:	462a      	mov	r2, r5
 801a15e:	4641      	mov	r1, r8
 801a160:	f7ff fe75 	bl	8019e4e <uECC_vli_set>
 801a164:	e7d9      	b.n	801a11a <uECC_vli_mmod+0x58>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 801a166:	f85a 3c88 	ldr.w	r3, [sl, #-136]
 801a16a:	f10c 0c01 	add.w	ip, ip, #1
 801a16e:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 801a172:	ab24      	add	r3, sp, #144	@ 0x90
 801a174:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 801a178:	f853 3c80 	ldr.w	r3, [r3, #-128]
 801a17c:	440b      	add	r3, r1
 801a17e:	1ad3      	subs	r3, r2, r3
 801a180:	bf34      	ite	cc
 801a182:	f04f 0b01 	movcc.w	fp, #1
 801a186:	f04f 0b00 	movcs.w	fp, #0
				borrow = (diff > v[index][i]);
 801a18a:	429a      	cmp	r2, r3
 801a18c:	bf18      	it	ne
 801a18e:	4659      	movne	r1, fp
			v[1 - index][i] = diff;
 801a190:	f85e 2c88 	ldr.w	r2, [lr, #-136]
 801a194:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
 801a198:	fa4f f08c 	sxtb.w	r0, ip
 801a19c:	ebb0 0f45 	cmp.w	r0, r5, lsl #1
 801a1a0:	dbe1      	blt.n	801a166 <uECC_vli_mmod+0xa4>
		index = !(index ^ borrow);
 801a1a2:	1a73      	subs	r3, r6, r1
		uECC_vli_rshift1(mod_multiple, num_words);
 801a1a4:	4638      	mov	r0, r7
 801a1a6:	4629      	mov	r1, r5
 801a1a8:	3c01      	subs	r4, #1
		index = !(index ^ borrow);
 801a1aa:	425e      	negs	r6, r3
	for (index = 1; shift >= 0; --shift) {
 801a1ac:	b224      	sxth	r4, r4
		index = !(index ^ borrow);
 801a1ae:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
 801a1b0:	f7ff fd7c 	bl	8019cac <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 801a1b4:	ab24      	add	r3, sp, #144	@ 0x90
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 801a1b6:	4629      	mov	r1, r5
 801a1b8:	eb07 0085 	add.w	r0, r7, r5, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 801a1bc:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 801a1c0:	f853 2c80 	ldr.w	r2, [r3, #-128]
 801a1c4:	f858 3c80 	ldr.w	r3, [r8, #-128]
 801a1c8:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
 801a1cc:	f848 3c80 	str.w	r3, [r8, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 801a1d0:	f7ff fd6c 	bl	8019cac <uECC_vli_rshift1>
	for (index = 1; shift >= 0; --shift) {
 801a1d4:	e7a7      	b.n	801a126 <uECC_vli_mmod+0x64>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 801a1d6:	ab24      	add	r3, sp, #144	@ 0x90
 801a1d8:	f04f 0c00 	mov.w	ip, #0
			v[1 - index][i] = diff;
 801a1dc:	f086 0e01 	eor.w	lr, r6, #1
		uECC_word_t borrow = 0;
 801a1e0:	4661      	mov	r1, ip
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 801a1e2:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
 801a1e6:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 801a1ea:	e7d5      	b.n	801a198 <uECC_vli_mmod+0xd6>

0801a1ec <uECC_vli_modMult>:
{
 801a1ec:	b530      	push	{r4, r5, lr}
 801a1ee:	b091      	sub	sp, #68	@ 0x44
 801a1f0:	4604      	mov	r4, r0
 801a1f2:	461d      	mov	r5, r3
	uECC_vli_mult(product, left, right, num_words);
 801a1f4:	4668      	mov	r0, sp
 801a1f6:	f99d 3050 	ldrsb.w	r3, [sp, #80]	@ 0x50
 801a1fa:	f7ff fd80 	bl	8019cfe <uECC_vli_mult>
	uECC_vli_mmod(result, product, mod, num_words);
 801a1fe:	462a      	mov	r2, r5
 801a200:	4669      	mov	r1, sp
 801a202:	4620      	mov	r0, r4
 801a204:	f7ff ff5d 	bl	801a0c2 <uECC_vli_mmod>
}
 801a208:	b011      	add	sp, #68	@ 0x44
 801a20a:	bd30      	pop	{r4, r5, pc}

0801a20c <uECC_vli_modMult_fast>:
{
 801a20c:	b530      	push	{r4, r5, lr}
 801a20e:	b091      	sub	sp, #68	@ 0x44
 801a210:	4605      	mov	r5, r0
 801a212:	461c      	mov	r4, r3
	uECC_vli_mult(product, left, right, curve->num_words);
 801a214:	f993 3000 	ldrsb.w	r3, [r3]
 801a218:	4668      	mov	r0, sp
 801a21a:	f7ff fd70 	bl	8019cfe <uECC_vli_mult>
	curve->mmod_fast(result, product);
 801a21e:	f8d4 30ac 	ldr.w	r3, [r4, #172]	@ 0xac
 801a222:	4669      	mov	r1, sp
 801a224:	4628      	mov	r0, r5
 801a226:	4798      	blx	r3
}
 801a228:	b011      	add	sp, #68	@ 0x44
 801a22a:	bd30      	pop	{r4, r5, pc}

0801a22c <uECC_vli_modSquare_fast>:
{
 801a22c:	4613      	mov	r3, r2
	uECC_vli_modMult_fast(result, left, left, curve);
 801a22e:	460a      	mov	r2, r1
 801a230:	f7ff bfec 	b.w	801a20c <uECC_vli_modMult_fast>

0801a234 <double_jacobian_default>:
{
 801a234:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
 801a238:	f993 6000 	ldrsb.w	r6, [r3]
{
 801a23c:	b092      	sub	sp, #72	@ 0x48
 801a23e:	4604      	mov	r4, r0
 801a240:	4689      	mov	r9, r1
	if (uECC_vli_isZero(Z1, num_words)) {
 801a242:	4610      	mov	r0, r2
 801a244:	4631      	mov	r1, r6
{
 801a246:	4615      	mov	r5, r2
 801a248:	4698      	mov	r8, r3
	if (uECC_vli_isZero(Z1, num_words)) {
 801a24a:	f7ff fdcd 	bl	8019de8 <uECC_vli_isZero>
 801a24e:	2800      	cmp	r0, #0
 801a250:	f040 8091 	bne.w	801a376 <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
 801a254:	4642      	mov	r2, r8
 801a256:	4649      	mov	r1, r9
 801a258:	a802      	add	r0, sp, #8
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 801a25a:	f108 0704 	add.w	r7, r8, #4
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
 801a25e:	f7ff ffe5 	bl	801a22c <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
 801a262:	4643      	mov	r3, r8
 801a264:	aa02      	add	r2, sp, #8
 801a266:	4621      	mov	r1, r4
 801a268:	a80a      	add	r0, sp, #40	@ 0x28
 801a26a:	f7ff ffcf 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
 801a26e:	a902      	add	r1, sp, #8
 801a270:	4642      	mov	r2, r8
 801a272:	4608      	mov	r0, r1
 801a274:	f7ff ffda 	bl	801a22c <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
 801a278:	4643      	mov	r3, r8
 801a27a:	462a      	mov	r2, r5
 801a27c:	4649      	mov	r1, r9
 801a27e:	4648      	mov	r0, r9
 801a280:	f7ff ffc4 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
 801a284:	4642      	mov	r2, r8
 801a286:	4629      	mov	r1, r5
 801a288:	4628      	mov	r0, r5
 801a28a:	f7ff ffcf 	bl	801a22c <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 801a28e:	463b      	mov	r3, r7
 801a290:	462a      	mov	r2, r5
 801a292:	4621      	mov	r1, r4
 801a294:	4620      	mov	r0, r4
 801a296:	9600      	str	r6, [sp, #0]
 801a298:	f7ff fee8 	bl	801a06c <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
 801a29c:	463b      	mov	r3, r7
 801a29e:	462a      	mov	r2, r5
 801a2a0:	4629      	mov	r1, r5
 801a2a2:	4628      	mov	r0, r5
 801a2a4:	9600      	str	r6, [sp, #0]
 801a2a6:	f7ff fee1 	bl	801a06c <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
 801a2aa:	463b      	mov	r3, r7
 801a2ac:	462a      	mov	r2, r5
 801a2ae:	4621      	mov	r1, r4
 801a2b0:	4628      	mov	r0, r5
 801a2b2:	9600      	str	r6, [sp, #0]
 801a2b4:	f7ff fef3 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
 801a2b8:	4643      	mov	r3, r8
 801a2ba:	462a      	mov	r2, r5
 801a2bc:	4621      	mov	r1, r4
 801a2be:	4620      	mov	r0, r4
 801a2c0:	f7ff ffa4 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
 801a2c4:	463b      	mov	r3, r7
 801a2c6:	4622      	mov	r2, r4
 801a2c8:	4621      	mov	r1, r4
 801a2ca:	4628      	mov	r0, r5
 801a2cc:	9600      	str	r6, [sp, #0]
 801a2ce:	f7ff fecd 	bl	801a06c <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
 801a2d2:	463b      	mov	r3, r7
 801a2d4:	462a      	mov	r2, r5
 801a2d6:	4621      	mov	r1, r4
 801a2d8:	4620      	mov	r0, r4
 801a2da:	9600      	str	r6, [sp, #0]
 801a2dc:	f7ff fec6 	bl	801a06c <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 801a2e0:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
 801a2e2:	07db      	lsls	r3, r3, #31
 801a2e4:	d54a      	bpl.n	801a37c <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 801a2e6:	4633      	mov	r3, r6
 801a2e8:	463a      	mov	r2, r7
 801a2ea:	4621      	mov	r1, r4
 801a2ec:	4620      	mov	r0, r4
 801a2ee:	f7ff fcc2 	bl	8019c76 <uECC_vli_add>
		uECC_vli_rshift1(X1, num_words);
 801a2f2:	4631      	mov	r1, r6
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 801a2f4:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
 801a2f6:	4620      	mov	r0, r4
 801a2f8:	f7ff fcd8 	bl	8019cac <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
 801a2fc:	f106 4380 	add.w	r3, r6, #1073741824	@ 0x40000000
 801a300:	3b01      	subs	r3, #1
 801a302:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 801a306:	ea42 72ca 	orr.w	r2, r2, sl, lsl #31
 801a30a:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
 801a30e:	4642      	mov	r2, r8
 801a310:	4621      	mov	r1, r4
 801a312:	4628      	mov	r0, r5
 801a314:	f7ff ff8a 	bl	801a22c <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
 801a318:	463b      	mov	r3, r7
 801a31a:	aa0a      	add	r2, sp, #40	@ 0x28
 801a31c:	4629      	mov	r1, r5
 801a31e:	4628      	mov	r0, r5
 801a320:	9600      	str	r6, [sp, #0]
 801a322:	f7ff febc 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
 801a326:	463b      	mov	r3, r7
 801a328:	aa0a      	add	r2, sp, #40	@ 0x28
 801a32a:	4629      	mov	r1, r5
 801a32c:	4628      	mov	r0, r5
 801a32e:	9600      	str	r6, [sp, #0]
 801a330:	f7ff feb5 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
 801a334:	a90a      	add	r1, sp, #40	@ 0x28
 801a336:	463b      	mov	r3, r7
 801a338:	462a      	mov	r2, r5
 801a33a:	4608      	mov	r0, r1
 801a33c:	9600      	str	r6, [sp, #0]
 801a33e:	f7ff feae 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
 801a342:	4643      	mov	r3, r8
 801a344:	aa0a      	add	r2, sp, #40	@ 0x28
 801a346:	4621      	mov	r1, r4
 801a348:	4620      	mov	r0, r4
 801a34a:	f7ff ff5f 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
 801a34e:	aa02      	add	r2, sp, #8
 801a350:	463b      	mov	r3, r7
 801a352:	4621      	mov	r1, r4
 801a354:	4610      	mov	r0, r2
 801a356:	9600      	str	r6, [sp, #0]
 801a358:	f7ff fea1 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
 801a35c:	4632      	mov	r2, r6
 801a35e:	4629      	mov	r1, r5
 801a360:	4620      	mov	r0, r4
 801a362:	f7ff fd74 	bl	8019e4e <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
 801a366:	4649      	mov	r1, r9
 801a368:	4628      	mov	r0, r5
 801a36a:	f7ff fd70 	bl	8019e4e <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
 801a36e:	a902      	add	r1, sp, #8
 801a370:	4648      	mov	r0, r9
 801a372:	f7ff fd6c 	bl	8019e4e <uECC_vli_set>
}
 801a376:	b012      	add	sp, #72	@ 0x48
 801a378:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
 801a37c:	4631      	mov	r1, r6
 801a37e:	4620      	mov	r0, r4
 801a380:	f7ff fc94 	bl	8019cac <uECC_vli_rshift1>
 801a384:	e7c3      	b.n	801a30e <double_jacobian_default+0xda>

0801a386 <x_side_default>:
{
 801a386:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a38a:	b08a      	sub	sp, #40	@ 0x28
 801a38c:	4615      	mov	r5, r2
 801a38e:	4604      	mov	r4, r0
 801a390:	4688      	mov	r8, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 801a392:	221c      	movs	r2, #28
 801a394:	2100      	movs	r1, #0
 801a396:	a803      	add	r0, sp, #12
 801a398:	f000 fe9c 	bl	801b0d4 <memset>
	wordcount_t num_words = curve->num_words;
 801a39c:	f995 7000 	ldrsb.w	r7, [r5]
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 801a3a0:	2303      	movs	r3, #3
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
 801a3a2:	462a      	mov	r2, r5
 801a3a4:	4641      	mov	r1, r8
 801a3a6:	4620      	mov	r0, r4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 801a3a8:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
 801a3aa:	f7ff ff3f 	bl	801a22c <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
 801a3ae:	1d2b      	adds	r3, r5, #4
 801a3b0:	aa02      	add	r2, sp, #8
 801a3b2:	4621      	mov	r1, r4
 801a3b4:	4620      	mov	r0, r4
 801a3b6:	9700      	str	r7, [sp, #0]
 801a3b8:	f7ff fe71 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
 801a3bc:	462b      	mov	r3, r5
 801a3be:	4642      	mov	r2, r8
 801a3c0:	4621      	mov	r1, r4
 801a3c2:	4620      	mov	r0, r4
 801a3c4:	f7ff ff22 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
 801a3c8:	1d2b      	adds	r3, r5, #4
 801a3ca:	f105 0284 	add.w	r2, r5, #132	@ 0x84
 801a3ce:	4621      	mov	r1, r4
 801a3d0:	4620      	mov	r0, r4
 801a3d2:	9700      	str	r7, [sp, #0]
 801a3d4:	f7ff fe4a 	bl	801a06c <uECC_vli_modAdd>
}
 801a3d8:	b00a      	add	sp, #40	@ 0x28
 801a3da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801a3de <uECC_vli_modInv>:
{
 801a3de:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a3e0:	460f      	mov	r7, r1
 801a3e2:	b0a1      	sub	sp, #132	@ 0x84
 801a3e4:	4606      	mov	r6, r0
	if (uECC_vli_isZero(input, num_words)) {
 801a3e6:	4619      	mov	r1, r3
 801a3e8:	4638      	mov	r0, r7
{
 801a3ea:	4615      	mov	r5, r2
 801a3ec:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
 801a3ee:	f7ff fcfb 	bl	8019de8 <uECC_vli_isZero>
 801a3f2:	b128      	cbz	r0, 801a400 <uECC_vli_modInv+0x22>
		uECC_vli_clear(result, num_words);
 801a3f4:	4630      	mov	r0, r6
}
 801a3f6:	b021      	add	sp, #132	@ 0x84
 801a3f8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		uECC_vli_clear(result, num_words);
 801a3fc:	f7ff bce9 	b.w	8019dd2 <uECC_vli_clear>
	uECC_vli_set(a, input, num_words);
 801a400:	4622      	mov	r2, r4
 801a402:	4639      	mov	r1, r7
 801a404:	4668      	mov	r0, sp
 801a406:	f7ff fd22 	bl	8019e4e <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
 801a40a:	4629      	mov	r1, r5
 801a40c:	a808      	add	r0, sp, #32
 801a40e:	f7ff fd1e 	bl	8019e4e <uECC_vli_set>
	uECC_vli_clear(u, num_words);
 801a412:	a810      	add	r0, sp, #64	@ 0x40
 801a414:	4621      	mov	r1, r4
 801a416:	f7ff fcdc 	bl	8019dd2 <uECC_vli_clear>
	u[0] = 1;
 801a41a:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
 801a41c:	a818      	add	r0, sp, #96	@ 0x60
	u[0] = 1;
 801a41e:	9310      	str	r3, [sp, #64]	@ 0x40
	uECC_vli_clear(v, num_words);
 801a420:	f7ff fcd7 	bl	8019dd2 <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
 801a424:	4622      	mov	r2, r4
 801a426:	a908      	add	r1, sp, #32
 801a428:	4668      	mov	r0, sp
 801a42a:	f7ff fd1c 	bl	8019e66 <uECC_vli_cmp_unsafe>
 801a42e:	b930      	cbnz	r0, 801a43e <uECC_vli_modInv+0x60>
  	uECC_vli_set(result, u, num_words);
 801a430:	4622      	mov	r2, r4
 801a432:	a910      	add	r1, sp, #64	@ 0x40
 801a434:	4630      	mov	r0, r6
 801a436:	f7ff fd0a 	bl	8019e4e <uECC_vli_set>
}
 801a43a:	b021      	add	sp, #132	@ 0x84
 801a43c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (EVEN(a)) {
 801a43e:	9b00      	ldr	r3, [sp, #0]
 801a440:	07da      	lsls	r2, r3, #31
 801a442:	d409      	bmi.n	801a458 <uECC_vli_modInv+0x7a>
			uECC_vli_rshift1(a, num_words);
 801a444:	4621      	mov	r1, r4
 801a446:	4668      	mov	r0, sp
 801a448:	f7ff fc30 	bl	8019cac <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
 801a44c:	4622      	mov	r2, r4
 801a44e:	4629      	mov	r1, r5
 801a450:	a810      	add	r0, sp, #64	@ 0x40
      			vli_modInv_update(v, mod, num_words);
 801a452:	f7ff fc38 	bl	8019cc6 <vli_modInv_update>
 801a456:	e7e5      	b.n	801a424 <uECC_vli_modInv+0x46>
    		} else if (EVEN(b)) {
 801a458:	9b08      	ldr	r3, [sp, #32]
 801a45a:	07db      	lsls	r3, r3, #31
 801a45c:	d407      	bmi.n	801a46e <uECC_vli_modInv+0x90>
			uECC_vli_rshift1(b, num_words);
 801a45e:	4621      	mov	r1, r4
 801a460:	a808      	add	r0, sp, #32
 801a462:	f7ff fc23 	bl	8019cac <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
 801a466:	4622      	mov	r2, r4
 801a468:	4629      	mov	r1, r5
 801a46a:	a818      	add	r0, sp, #96	@ 0x60
 801a46c:	e7f1      	b.n	801a452 <uECC_vli_modInv+0x74>
		} else if (cmpResult > 0) {
 801a46e:	2801      	cmp	r0, #1
			uECC_vli_sub(a, a, b, num_words);
 801a470:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
 801a472:	d11c      	bne.n	801a4ae <uECC_vli_modInv+0xd0>
			uECC_vli_sub(a, a, b, num_words);
 801a474:	aa08      	add	r2, sp, #32
 801a476:	4669      	mov	r1, sp
 801a478:	4668      	mov	r0, sp
 801a47a:	f7ff fd1b 	bl	8019eb4 <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
 801a47e:	4621      	mov	r1, r4
 801a480:	4668      	mov	r0, sp
 801a482:	f7ff fc13 	bl	8019cac <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
 801a486:	4622      	mov	r2, r4
 801a488:	a918      	add	r1, sp, #96	@ 0x60
 801a48a:	a810      	add	r0, sp, #64	@ 0x40
 801a48c:	f7ff fceb 	bl	8019e66 <uECC_vli_cmp_unsafe>
 801a490:	3001      	adds	r0, #1
 801a492:	d105      	bne.n	801a4a0 <uECC_vli_modInv+0xc2>
        			uECC_vli_add(u, u, mod, num_words);
 801a494:	a910      	add	r1, sp, #64	@ 0x40
 801a496:	4623      	mov	r3, r4
 801a498:	462a      	mov	r2, r5
 801a49a:	4608      	mov	r0, r1
 801a49c:	f7ff fbeb 	bl	8019c76 <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
 801a4a0:	a910      	add	r1, sp, #64	@ 0x40
 801a4a2:	4623      	mov	r3, r4
 801a4a4:	aa18      	add	r2, sp, #96	@ 0x60
 801a4a6:	4608      	mov	r0, r1
 801a4a8:	f7ff fd04 	bl	8019eb4 <uECC_vli_sub>
 801a4ac:	e7ce      	b.n	801a44c <uECC_vli_modInv+0x6e>
      			uECC_vli_sub(b, b, a, num_words);
 801a4ae:	466a      	mov	r2, sp
 801a4b0:	a808      	add	r0, sp, #32
 801a4b2:	f7ff fcff 	bl	8019eb4 <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
 801a4b6:	4621      	mov	r1, r4
 801a4b8:	a808      	add	r0, sp, #32
 801a4ba:	f7ff fbf7 	bl	8019cac <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
 801a4be:	4622      	mov	r2, r4
 801a4c0:	a910      	add	r1, sp, #64	@ 0x40
 801a4c2:	a818      	add	r0, sp, #96	@ 0x60
 801a4c4:	f7ff fccf 	bl	8019e66 <uECC_vli_cmp_unsafe>
 801a4c8:	3001      	adds	r0, #1
 801a4ca:	d105      	bne.n	801a4d8 <uECC_vli_modInv+0xfa>
        			uECC_vli_add(v, v, mod, num_words);
 801a4cc:	a918      	add	r1, sp, #96	@ 0x60
 801a4ce:	4623      	mov	r3, r4
 801a4d0:	462a      	mov	r2, r5
 801a4d2:	4608      	mov	r0, r1
 801a4d4:	f7ff fbcf 	bl	8019c76 <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
 801a4d8:	a918      	add	r1, sp, #96	@ 0x60
 801a4da:	4623      	mov	r3, r4
 801a4dc:	aa10      	add	r2, sp, #64	@ 0x40
 801a4de:	4608      	mov	r0, r1
 801a4e0:	f7ff fce8 	bl	8019eb4 <uECC_vli_sub>
 801a4e4:	e7bf      	b.n	801a466 <uECC_vli_modInv+0x88>
	...

0801a4e8 <uECC_secp256r1>:
}
 801a4e8:	4800      	ldr	r0, [pc, #0]	@ (801a4ec <uECC_secp256r1+0x4>)
 801a4ea:	4770      	bx	lr
 801a4ec:	0801c628 	.word	0x0801c628

0801a4f0 <apply_z>:
	return uECC_vli_isZero(point, curve->num_words * 2);
}

void apply_z(uECC_word_t * X1, uECC_word_t * Y1, const uECC_word_t * const Z,
	     uECC_Curve curve)
{
 801a4f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 801a4f2:	4616      	mov	r6, r2
 801a4f4:	b089      	sub	sp, #36	@ 0x24
 801a4f6:	461c      	mov	r4, r3
 801a4f8:	4607      	mov	r7, r0
 801a4fa:	460d      	mov	r5, r1
	uECC_word_t t1[NUM_ECC_WORDS];

	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
 801a4fc:	461a      	mov	r2, r3
 801a4fe:	4631      	mov	r1, r6
 801a500:	4668      	mov	r0, sp
 801a502:	f7ff fe93 	bl	801a22c <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
 801a506:	4623      	mov	r3, r4
 801a508:	466a      	mov	r2, sp
 801a50a:	4639      	mov	r1, r7
 801a50c:	4638      	mov	r0, r7
 801a50e:	f7ff fe7d 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
 801a512:	4623      	mov	r3, r4
 801a514:	4632      	mov	r2, r6
 801a516:	4669      	mov	r1, sp
 801a518:	4668      	mov	r0, sp
 801a51a:	f7ff fe77 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
 801a51e:	4623      	mov	r3, r4
 801a520:	466a      	mov	r2, sp
 801a522:	4629      	mov	r1, r5
 801a524:	4628      	mov	r0, r5
 801a526:	f7ff fe71 	bl	801a20c <uECC_vli_modMult_fast>
}
 801a52a:	b009      	add	sp, #36	@ 0x24
 801a52c:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801a52e <XYcZ_add>:
}

void XYcZ_add(uECC_word_t * X1, uECC_word_t * Y1,
	      uECC_word_t * X2, uECC_word_t * Y2,
	      uECC_Curve curve)
{
 801a52e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801a532:	b08a      	sub	sp, #40	@ 0x28
 801a534:	4614      	mov	r4, r2
 801a536:	461f      	mov	r7, r3
 801a538:	4681      	mov	r9, r0
 801a53a:	f8dd 8048 	ldr.w	r8, [sp, #72]	@ 0x48
 801a53e:	468a      	mov	sl, r1
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 801a540:	4602      	mov	r2, r0
 801a542:	4621      	mov	r1, r4
	wordcount_t num_words = curve->num_words;
 801a544:	4645      	mov	r5, r8
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 801a546:	a802      	add	r0, sp, #8
	wordcount_t num_words = curve->num_words;
 801a548:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 801a54c:	462b      	mov	r3, r5
 801a54e:	9600      	str	r6, [sp, #0]
 801a550:	f7ff fda5 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
 801a554:	a902      	add	r1, sp, #8
 801a556:	4642      	mov	r2, r8
 801a558:	4608      	mov	r0, r1
 801a55a:	f7ff fe67 	bl	801a22c <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
 801a55e:	4643      	mov	r3, r8
 801a560:	aa02      	add	r2, sp, #8
 801a562:	4649      	mov	r1, r9
 801a564:	4648      	mov	r0, r9
 801a566:	f7ff fe51 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
 801a56a:	4643      	mov	r3, r8
 801a56c:	aa02      	add	r2, sp, #8
 801a56e:	4621      	mov	r1, r4
 801a570:	4620      	mov	r0, r4
 801a572:	f7ff fe4b 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 801a576:	462b      	mov	r3, r5
 801a578:	4652      	mov	r2, sl
 801a57a:	4639      	mov	r1, r7
 801a57c:	4638      	mov	r0, r7
 801a57e:	9600      	str	r6, [sp, #0]
 801a580:	f7ff fd8d 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
 801a584:	4642      	mov	r2, r8
 801a586:	4639      	mov	r1, r7
 801a588:	a802      	add	r0, sp, #8
 801a58a:	f7ff fe4f 	bl	801a22c <uECC_vli_modSquare_fast>

	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
 801a58e:	a902      	add	r1, sp, #8
 801a590:	462b      	mov	r3, r5
 801a592:	464a      	mov	r2, r9
 801a594:	4608      	mov	r0, r1
 801a596:	9600      	str	r6, [sp, #0]
 801a598:	f7ff fd81 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
 801a59c:	a902      	add	r1, sp, #8
 801a59e:	462b      	mov	r3, r5
 801a5a0:	4622      	mov	r2, r4
 801a5a2:	4608      	mov	r0, r1
 801a5a4:	9600      	str	r6, [sp, #0]
 801a5a6:	f7ff fd7a 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
 801a5aa:	462b      	mov	r3, r5
 801a5ac:	464a      	mov	r2, r9
 801a5ae:	4621      	mov	r1, r4
 801a5b0:	4620      	mov	r0, r4
 801a5b2:	9600      	str	r6, [sp, #0]
 801a5b4:	f7ff fd73 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
 801a5b8:	4643      	mov	r3, r8
 801a5ba:	4622      	mov	r2, r4
 801a5bc:	4651      	mov	r1, sl
 801a5be:	4650      	mov	r0, sl
 801a5c0:	f7ff fe24 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
 801a5c4:	462b      	mov	r3, r5
 801a5c6:	aa02      	add	r2, sp, #8
 801a5c8:	4649      	mov	r1, r9
 801a5ca:	4620      	mov	r0, r4
 801a5cc:	9600      	str	r6, [sp, #0]
 801a5ce:	f7ff fd66 	bl	801a09e <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
 801a5d2:	4643      	mov	r3, r8
 801a5d4:	4622      	mov	r2, r4
 801a5d6:	4639      	mov	r1, r7
 801a5d8:	4638      	mov	r0, r7
 801a5da:	f7ff fe17 	bl	801a20c <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
 801a5de:	462b      	mov	r3, r5
 801a5e0:	4652      	mov	r2, sl
 801a5e2:	4639      	mov	r1, r7
 801a5e4:	4638      	mov	r0, r7
 801a5e6:	9600      	str	r6, [sp, #0]
 801a5e8:	f7ff fd59 	bl	801a09e <uECC_vli_modSub>

	uECC_vli_set(X2, t5, num_words);
 801a5ec:	4632      	mov	r2, r6
 801a5ee:	a902      	add	r1, sp, #8
 801a5f0:	4620      	mov	r0, r4
 801a5f2:	f7ff fc2c 	bl	8019e4e <uECC_vli_set>
}
 801a5f6:	b00a      	add	sp, #40	@ 0x28
 801a5f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0801a5fc <uECC_vli_bytesToNative>:
}

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
 801a5fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a5fe:	460d      	mov	r5, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 801a600:	1cd1      	adds	r1, r2, #3
{
 801a602:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 801a604:	bf48      	it	mi
 801a606:	1d91      	addmi	r1, r2, #6
	for (i = 0; i < num_bytes; ++i) {
		unsigned b = num_bytes - 1 - i;
 801a608:	1e67      	subs	r7, r4, #1
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 801a60a:	f341 0187 	sbfx	r1, r1, #2, #8
 801a60e:	f7ff fbe0 	bl	8019dd2 <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
 801a612:	2100      	movs	r1, #0
 801a614:	b24a      	sxtb	r2, r1
 801a616:	42a2      	cmp	r2, r4
 801a618:	db00      	blt.n	801a61c <uECC_vli_bytesToNative+0x20>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
 801a61a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
 801a61c:	1abb      	subs	r3, r7, r2
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
 801a61e:	5caa      	ldrb	r2, [r5, r2]
	for (i = 0; i < num_bytes; ++i) {
 801a620:	3101      	adds	r1, #1
		native[b / uECC_WORD_SIZE] |=
 801a622:	f023 0603 	bic.w	r6, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
 801a626:	f003 0303 	and.w	r3, r3, #3
 801a62a:	00db      	lsls	r3, r3, #3
 801a62c:	409a      	lsls	r2, r3
		native[b / uECC_WORD_SIZE] |=
 801a62e:	5983      	ldr	r3, [r0, r6]
 801a630:	4313      	orrs	r3, r2
 801a632:	5183      	str	r3, [r0, r6]
	for (i = 0; i < num_bytes; ++i) {
 801a634:	e7ee      	b.n	801a614 <uECC_vli_bytesToNative+0x18>

0801a636 <bits2int>:
#include "ecc_dsa.h"


static void bits2int(uECC_word_t *native, const uint8_t *bits,
		     unsigned bits_size, uECC_Curve curve)
{
 801a636:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801a63a:	461f      	mov	r7, r3
	unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 801a63c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
 801a640:	4688      	mov	r8, r1
 801a642:	4606      	mov	r6, r0
	unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 801a644:	f113 011f 	adds.w	r1, r3, #31
 801a648:	bf48      	it	mi
 801a64a:	f103 013e 	addmi.w	r1, r3, #62	@ 0x3e
	unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 801a64e:	1ddc      	adds	r4, r3, #7
 801a650:	bf48      	it	mi
 801a652:	f103 040e 	addmi.w	r4, r3, #14
	unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 801a656:	114d      	asrs	r5, r1, #5
	unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
 801a658:	10e4      	asrs	r4, r4, #3

	if (bits_size > num_n_bytes) {
		bits_size = num_n_bytes;
	}

	uECC_vli_clear(native, num_n_words);
 801a65a:	fa4f f985 	sxtb.w	r9, r5
	if (bits_size > num_n_bytes) {
 801a65e:	4294      	cmp	r4, r2
	uECC_vli_clear(native, num_n_words);
 801a660:	4649      	mov	r1, r9
	if (bits_size > num_n_bytes) {
 801a662:	bf28      	it	cs
 801a664:	4614      	movcs	r4, r2
	uECC_vli_clear(native, num_n_words);
 801a666:	f7ff fbb4 	bl	8019dd2 <uECC_vli_clear>
	uECC_vli_bytesToNative(native, bits, bits_size);
 801a66a:	4641      	mov	r1, r8
 801a66c:	4630      	mov	r0, r6
 801a66e:	4622      	mov	r2, r4
 801a670:	f7ff ffc4 	bl	801a5fc <uECC_vli_bytesToNative>
	if (bits_size * 8 <= (unsigned)curve->num_n_bits) {
 801a674:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801a678:	ebb3 0fc4 	cmp.w	r3, r4, lsl #3
 801a67c:	d221      	bcs.n	801a6c2 <bits2int+0x8c>
		return;
	}
	shift = bits_size * 8 - curve->num_n_bits;
 801a67e:	ebc3 03c4 	rsb	r3, r3, r4, lsl #3
	carry = 0;
 801a682:	2000      	movs	r0, #0
	ptr = native + num_n_words;
 801a684:	eb06 0185 	add.w	r1, r6, r5, lsl #2
	while (ptr-- > native) {
		uECC_word_t temp = *ptr;
		*ptr = (temp >> shift) | carry;
		carry = temp << (uECC_WORD_BITS - shift);
 801a688:	f1c3 0520 	rsb	r5, r3, #32
	while (ptr-- > native) {
 801a68c:	42b1      	cmp	r1, r6
 801a68e:	d80f      	bhi.n	801a6b0 <bits2int+0x7a>
	}

	/* Reduce mod curve_n */
	if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {
 801a690:	3724      	adds	r7, #36	@ 0x24
 801a692:	464a      	mov	r2, r9
 801a694:	4631      	mov	r1, r6
 801a696:	4638      	mov	r0, r7
 801a698:	f7ff fbe5 	bl	8019e66 <uECC_vli_cmp_unsafe>
 801a69c:	2801      	cmp	r0, #1
 801a69e:	d010      	beq.n	801a6c2 <bits2int+0x8c>
		uECC_vli_sub(native, native, curve->n, num_n_words);
 801a6a0:	464b      	mov	r3, r9
 801a6a2:	463a      	mov	r2, r7
 801a6a4:	4631      	mov	r1, r6
 801a6a6:	4630      	mov	r0, r6
	}
}
 801a6a8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		uECC_vli_sub(native, native, curve->n, num_n_words);
 801a6ac:	f7ff bc02 	b.w	8019eb4 <uECC_vli_sub>
		uECC_word_t temp = *ptr;
 801a6b0:	f851 4d04 	ldr.w	r4, [r1, #-4]!
		*ptr = (temp >> shift) | carry;
 801a6b4:	fa24 f203 	lsr.w	r2, r4, r3
 801a6b8:	4302      	orrs	r2, r0
		carry = temp << (uECC_WORD_BITS - shift);
 801a6ba:	fa04 f005 	lsl.w	r0, r4, r5
		*ptr = (temp >> shift) | carry;
 801a6be:	600a      	str	r2, [r1, #0]
		carry = temp << (uECC_WORD_BITS - shift);
 801a6c0:	e7e4      	b.n	801a68c <bits2int+0x56>
}
 801a6c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0801a6c6 <uECC_verify>:
}

int uECC_verify(const uint8_t *public_key, const uint8_t *message_hash,
		unsigned hash_size, const uint8_t *signature,
	        uECC_Curve curve)
{
 801a6c6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801a6ca:	b0fb      	sub	sp, #492	@ 0x1ec
 801a6cc:	461e      	mov	r6, r3
 801a6ce:	4683      	mov	fp, r0
 801a6d0:	4689      	mov	r9, r1
 801a6d2:	9d84      	ldr	r5, [sp, #528]	@ 0x210

	rx[num_n_words - 1] = 0;
	r[num_n_words - 1] = 0;
	s[num_n_words - 1] = 0;

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
 801a6d4:	4601      	mov	r1, r0
{
 801a6d6:	9203      	str	r2, [sp, #12]
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
 801a6d8:	a86a      	add	r0, sp, #424	@ 0x1a8
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 801a6da:	f9b5 3002 	ldrsh.w	r3, [r5, #2]
	wordcount_t num_words = curve->num_words;
 801a6de:	f995 4000 	ldrsb.w	r4, [r5]
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 801a6e2:	f113 021f 	adds.w	r2, r3, #31
 801a6e6:	bf48      	it	mi
 801a6e8:	f103 023e 	addmi.w	r2, r3, #62	@ 0x3e
	rx[num_n_words - 1] = 0;
 801a6ec:	2300      	movs	r3, #0
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 801a6ee:	f342 1847 	sbfx	r8, r2, #5, #8
	rx[num_n_words - 1] = 0;
 801a6f2:	aa22      	add	r2, sp, #136	@ 0x88
 801a6f4:	f108 37ff 	add.w	r7, r8, #4294967295
 801a6f8:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
	r[num_n_words - 1] = 0;
 801a6fc:	aa7a      	add	r2, sp, #488	@ 0x1e8
 801a6fe:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 801a702:	f842 3cc0 	str.w	r3, [r2, #-192]
	s[num_n_words - 1] = 0;
 801a706:	f842 3ca0 	str.w	r3, [r2, #-160]
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
 801a70a:	f995 2001 	ldrsb.w	r2, [r5, #1]
 801a70e:	f7ff ff75 	bl	801a5fc <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public + num_words, public_key + curve->num_bytes,
 801a712:	f995 2001 	ldrsb.w	r2, [r5, #1]
 801a716:	00a3      	lsls	r3, r4, #2
 801a718:	eb0b 0102 	add.w	r1, fp, r2
 801a71c:	9305      	str	r3, [sp, #20]
 801a71e:	ab6a      	add	r3, sp, #424	@ 0x1a8
 801a720:	eb03 0a84 	add.w	sl, r3, r4, lsl #2
 801a724:	4650      	mov	r0, sl
 801a726:	f7ff ff69 	bl	801a5fc <uECC_vli_bytesToNative>
			       curve->num_bytes);
	uECC_vli_bytesToNative(r, signature, curve->num_bytes);
 801a72a:	f995 2001 	ldrsb.w	r2, [r5, #1]
 801a72e:	4631      	mov	r1, r6
 801a730:	a84a      	add	r0, sp, #296	@ 0x128
 801a732:	f7ff ff63 	bl	801a5fc <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(s, signature + curve->num_bytes, curve->num_bytes);
 801a736:	f995 2001 	ldrsb.w	r2, [r5, #1]
 801a73a:	a852      	add	r0, sp, #328	@ 0x148
 801a73c:	18b1      	adds	r1, r6, r2
 801a73e:	f7ff ff5d 	bl	801a5fc <uECC_vli_bytesToNative>

	/* r, s must not be 0. */
	if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
 801a742:	4621      	mov	r1, r4
 801a744:	a84a      	add	r0, sp, #296	@ 0x128
 801a746:	f7ff fb4f 	bl	8019de8 <uECC_vli_isZero>
 801a74a:	b118      	cbz	r0, 801a754 <uECC_verify+0x8e>
		return 0;
 801a74c:	2000      	movs	r0, #0
		uECC_vli_sub(rx, rx, curve->n, num_n_words);
	}

	/* Accept only if v == r. */
	return (int)(uECC_vli_equal(rx, r, num_words) == 0);
}
 801a74e:	b07b      	add	sp, #492	@ 0x1ec
 801a750:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uECC_vli_isZero(r, num_words) || uECC_vli_isZero(s, num_words)) {
 801a754:	4621      	mov	r1, r4
 801a756:	a852      	add	r0, sp, #328	@ 0x148
 801a758:	f7ff fb46 	bl	8019de8 <uECC_vli_isZero>
 801a75c:	9002      	str	r0, [sp, #8]
 801a75e:	2800      	cmp	r0, #0
 801a760:	d1f4      	bne.n	801a74c <uECC_verify+0x86>
	if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 801a762:	4642      	mov	r2, r8
 801a764:	a94a      	add	r1, sp, #296	@ 0x128
 801a766:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 801a76a:	f7ff fb7c 	bl	8019e66 <uECC_vli_cmp_unsafe>
 801a76e:	2801      	cmp	r0, #1
 801a770:	d1ec      	bne.n	801a74c <uECC_verify+0x86>
	    uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
 801a772:	4642      	mov	r2, r8
 801a774:	a952      	add	r1, sp, #328	@ 0x148
 801a776:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 801a77a:	f7ff fb74 	bl	8019e66 <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 801a77e:	2801      	cmp	r0, #1
	    uECC_vli_cmp_unsafe(curve->n, s, num_n_words) != 1) {
 801a780:	9004      	str	r0, [sp, #16]
	if (uECC_vli_cmp_unsafe(curve->n, r, num_n_words) != 1 ||
 801a782:	d1e3      	bne.n	801a74c <uECC_verify+0x86>
	uECC_vli_modInv(z, s, curve->n, num_n_words); /* z = 1/s */
 801a784:	ae1a      	add	r6, sp, #104	@ 0x68
 801a786:	4643      	mov	r3, r8
 801a788:	f105 0224 	add.w	r2, r5, #36	@ 0x24
 801a78c:	a952      	add	r1, sp, #328	@ 0x148
 801a78e:	4630      	mov	r0, r6
 801a790:	f7ff fe25 	bl	801a3de <uECC_vli_modInv>
	u1[num_n_words - 1] = 0;
 801a794:	9b02      	ldr	r3, [sp, #8]
 801a796:	aa0a      	add	r2, sp, #40	@ 0x28
	bits2int(u1, message_hash, hash_size, curve);
 801a798:	4649      	mov	r1, r9
 801a79a:	a80a      	add	r0, sp, #40	@ 0x28
	u1[num_n_words - 1] = 0;
 801a79c:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
	bits2int(u1, message_hash, hash_size, curve);
 801a7a0:	462b      	mov	r3, r5
 801a7a2:	9a03      	ldr	r2, [sp, #12]
	uECC_vli_set(sum, _public, num_words);
 801a7a4:	af5a      	add	r7, sp, #360	@ 0x168
	bits2int(u1, message_hash, hash_size, curve);
 801a7a6:	f7ff ff46 	bl	801a636 <bits2int>
	uECC_vli_modMult(u1, u1, z, curve->n, num_n_words); /* u1 = e/s */
 801a7aa:	a90a      	add	r1, sp, #40	@ 0x28
 801a7ac:	f105 0324 	add.w	r3, r5, #36	@ 0x24
 801a7b0:	4632      	mov	r2, r6
 801a7b2:	4608      	mov	r0, r1
 801a7b4:	f8cd 8000 	str.w	r8, [sp]
 801a7b8:	f7ff fd18 	bl	801a1ec <uECC_vli_modMult>
	uECC_vli_modMult(u2, r, z, curve->n, num_n_words); /* u2 = r/s */
 801a7bc:	f105 0324 	add.w	r3, r5, #36	@ 0x24
 801a7c0:	4632      	mov	r2, r6
 801a7c2:	a94a      	add	r1, sp, #296	@ 0x128
 801a7c4:	a812      	add	r0, sp, #72	@ 0x48
 801a7c6:	f8cd 8000 	str.w	r8, [sp]
 801a7ca:	f7ff fd0f 	bl	801a1ec <uECC_vli_modMult>
	uECC_vli_set(sum, _public, num_words);
 801a7ce:	4638      	mov	r0, r7
 801a7d0:	4622      	mov	r2, r4
 801a7d2:	a96a      	add	r1, sp, #424	@ 0x1a8
 801a7d4:	f7ff fb3b 	bl	8019e4e <uECC_vli_set>
	uECC_vli_set(sum + num_words, _public + num_words, num_words);
 801a7d8:	4651      	mov	r1, sl
	uECC_vli_set(tx, curve->G, num_words);
 801a7da:	f105 0a44 	add.w	sl, r5, #68	@ 0x44
	uECC_vli_set(sum + num_words, _public + num_words, num_words);
 801a7de:	eb07 0084 	add.w	r0, r7, r4, lsl #2
 801a7e2:	4622      	mov	r2, r4
 801a7e4:	f7ff fb33 	bl	8019e4e <uECC_vli_set>
	uECC_vli_set(tx, curve->G, num_words);
 801a7e8:	4651      	mov	r1, sl
 801a7ea:	4622      	mov	r2, r4
 801a7ec:	a832      	add	r0, sp, #200	@ 0xc8
 801a7ee:	f7ff fb2e 	bl	8019e4e <uECC_vli_set>
	uECC_vli_set(ty, curve->G + num_words, num_words);
 801a7f2:	4622      	mov	r2, r4
 801a7f4:	eb0a 0184 	add.w	r1, sl, r4, lsl #2
 801a7f8:	a83a      	add	r0, sp, #232	@ 0xe8
 801a7fa:	f7ff fb28 	bl	8019e4e <uECC_vli_set>
	uECC_vli_modSub(z, sum, tx, curve->p, num_words); /* z = x2 - x1 */
 801a7fe:	1d2b      	adds	r3, r5, #4
 801a800:	4639      	mov	r1, r7
 801a802:	aa32      	add	r2, sp, #200	@ 0xc8
 801a804:	4630      	mov	r0, r6
 801a806:	9400      	str	r4, [sp, #0]
 801a808:	9303      	str	r3, [sp, #12]
 801a80a:	f7ff fc48 	bl	801a09e <uECC_vli_modSub>
	XYcZ_add(tx, ty, sum, sum + num_words, curve);
 801a80e:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 801a812:	463a      	mov	r2, r7
 801a814:	a93a      	add	r1, sp, #232	@ 0xe8
 801a816:	a832      	add	r0, sp, #200	@ 0xc8
 801a818:	9500      	str	r5, [sp, #0]
 801a81a:	f7ff fe88 	bl	801a52e <XYcZ_add>
	uECC_vli_modInv(z, z, curve->p, num_words); /* z = 1/z */
 801a81e:	4623      	mov	r3, r4
 801a820:	1d2a      	adds	r2, r5, #4
 801a822:	4631      	mov	r1, r6
 801a824:	4630      	mov	r0, r6
 801a826:	f7ff fdda 	bl	801a3de <uECC_vli_modInv>
	apply_z(sum, sum + num_words, z, curve);
 801a82a:	462b      	mov	r3, r5
 801a82c:	eb07 0184 	add.w	r1, r7, r4, lsl #2
 801a830:	4638      	mov	r0, r7
 801a832:	4632      	mov	r2, r6
 801a834:	f7ff fe5c 	bl	801a4f0 <apply_z>
	points[0] = 0;
 801a838:	9a02      	ldr	r2, [sp, #8]
	num_bits = smax(uECC_vli_numBits(u1, num_n_words),
 801a83a:	4641      	mov	r1, r8
 801a83c:	a80a      	add	r0, sp, #40	@ 0x28
	points[1] = curve->G;
 801a83e:	e9cd 2a06 	strd	r2, sl, [sp, #24]
	points[2] = _public;
 801a842:	aa6a      	add	r2, sp, #424	@ 0x1a8
	points[3] = sum;
 801a844:	e9cd 2708 	strd	r2, r7, [sp, #32]
	num_bits = smax(uECC_vli_numBits(u1, num_n_words),
 801a848:	f7ff fae6 	bl	8019e18 <uECC_vli_numBits>
 801a84c:	4681      	mov	r9, r0
 801a84e:	4641      	mov	r1, r8
 801a850:	a812      	add	r0, sp, #72	@ 0x48
 801a852:	f7ff fae1 	bl	8019e18 <uECC_vli_numBits>
	point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 801a856:	4581      	cmp	r9, r0
 801a858:	bfb8      	it	lt
 801a85a:	4681      	movlt	r9, r0
 801a85c:	a80a      	add	r0, sp, #40	@ 0x28
 801a85e:	f109 3aff 	add.w	sl, r9, #4294967295
	for (i = num_bits - 2; i >= 0; --i) {
 801a862:	f1a9 0902 	sub.w	r9, r9, #2
	point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 801a866:	fa0f f18a 	sxth.w	r1, sl
 801a86a:	f7ff facc 	bl	8019e06 <uECC_vli_testBit>
 801a86e:	4607      	mov	r7, r0
                       ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
 801a870:	fa0f f18a 	sxth.w	r1, sl
 801a874:	a812      	add	r0, sp, #72	@ 0x48
 801a876:	f7ff fac6 	bl	8019e06 <uECC_vli_testBit>
 801a87a:	3800      	subs	r0, #0
	point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 801a87c:	ab06      	add	r3, sp, #24
	uECC_vli_set(rx, point, num_words);
 801a87e:	4622      	mov	r2, r4
                       ((!!uECC_vli_testBit(u2, num_bits - 1)) << 1)];
 801a880:	bf18      	it	ne
 801a882:	2001      	movne	r0, #1
	point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 801a884:	3f00      	subs	r7, #0
 801a886:	bf18      	it	ne
 801a888:	2701      	movne	r7, #1
 801a88a:	ea47 0740 	orr.w	r7, r7, r0, lsl #1
	uECC_vli_set(rx, point, num_words);
 801a88e:	a822      	add	r0, sp, #136	@ 0x88
	point = points[(!!uECC_vli_testBit(u1, num_bits - 1)) |
 801a890:	f853 7027 	ldr.w	r7, [r3, r7, lsl #2]
	uECC_vli_set(rx, point, num_words);
 801a894:	4639      	mov	r1, r7
 801a896:	f7ff fada 	bl	8019e4e <uECC_vli_set>
	uECC_vli_set(ry, point + num_words, num_words);
 801a89a:	4622      	mov	r2, r4
 801a89c:	eb07 0184 	add.w	r1, r7, r4, lsl #2
 801a8a0:	a82a      	add	r0, sp, #168	@ 0xa8
 801a8a2:	f7ff fad4 	bl	8019e4e <uECC_vli_set>
	uECC_vli_clear(z, num_words);
 801a8a6:	4621      	mov	r1, r4
 801a8a8:	4630      	mov	r0, r6
 801a8aa:	f7ff fa92 	bl	8019dd2 <uECC_vli_clear>
	z[0] = 1;
 801a8ae:	9b04      	ldr	r3, [sp, #16]
 801a8b0:	6033      	str	r3, [r6, #0]
	for (i = num_bits - 2; i >= 0; --i) {
 801a8b2:	fa0f f989 	sxth.w	r9, r9
 801a8b6:	f1b9 0f00 	cmp.w	r9, #0
 801a8ba:	da23      	bge.n	801a904 <uECC_verify+0x23e>
	uECC_vli_modInv(z, z, curve->p, num_words); /* Z = 1/Z */
 801a8bc:	4623      	mov	r3, r4
 801a8be:	9a03      	ldr	r2, [sp, #12]
 801a8c0:	4631      	mov	r1, r6
 801a8c2:	4630      	mov	r0, r6
 801a8c4:	f7ff fd8b 	bl	801a3de <uECC_vli_modInv>
	apply_z(rx, ry, z, curve);
 801a8c8:	462b      	mov	r3, r5
 801a8ca:	4632      	mov	r2, r6
 801a8cc:	a92a      	add	r1, sp, #168	@ 0xa8
 801a8ce:	a822      	add	r0, sp, #136	@ 0x88
 801a8d0:	f7ff fe0e 	bl	801a4f0 <apply_z>
	if (uECC_vli_cmp_unsafe(curve->n, rx, num_n_words) != 1) {
 801a8d4:	4642      	mov	r2, r8
 801a8d6:	a922      	add	r1, sp, #136	@ 0x88
 801a8d8:	f105 0024 	add.w	r0, r5, #36	@ 0x24
 801a8dc:	f7ff fac3 	bl	8019e66 <uECC_vli_cmp_unsafe>
 801a8e0:	2801      	cmp	r0, #1
 801a8e2:	d006      	beq.n	801a8f2 <uECC_verify+0x22c>
		uECC_vli_sub(rx, rx, curve->n, num_n_words);
 801a8e4:	a922      	add	r1, sp, #136	@ 0x88
 801a8e6:	4643      	mov	r3, r8
 801a8e8:	f105 0224 	add.w	r2, r5, #36	@ 0x24
 801a8ec:	4608      	mov	r0, r1
 801a8ee:	f7ff fae1 	bl	8019eb4 <uECC_vli_sub>
	return (int)(uECC_vli_equal(rx, r, num_words) == 0);
 801a8f2:	4622      	mov	r2, r4
 801a8f4:	a94a      	add	r1, sp, #296	@ 0x128
 801a8f6:	a822      	add	r0, sp, #136	@ 0x88
 801a8f8:	f7ff faca 	bl	8019e90 <uECC_vli_equal>
 801a8fc:	fab0 f080 	clz	r0, r0
 801a900:	0940      	lsrs	r0, r0, #5
 801a902:	e724      	b.n	801a74e <uECC_verify+0x88>
		curve->double_jacobian(rx, ry, z, curve);
 801a904:	462b      	mov	r3, r5
 801a906:	4632      	mov	r2, r6
 801a908:	f8d5 70a4 	ldr.w	r7, [r5, #164]	@ 0xa4
 801a90c:	a92a      	add	r1, sp, #168	@ 0xa8
 801a90e:	a822      	add	r0, sp, #136	@ 0x88
 801a910:	47b8      	blx	r7
		index = (!!uECC_vli_testBit(u1, i)) | ((!!uECC_vli_testBit(u2, i)) << 1);
 801a912:	4649      	mov	r1, r9
 801a914:	a80a      	add	r0, sp, #40	@ 0x28
 801a916:	f7ff fa76 	bl	8019e06 <uECC_vli_testBit>
 801a91a:	4649      	mov	r1, r9
 801a91c:	4607      	mov	r7, r0
 801a91e:	a812      	add	r0, sp, #72	@ 0x48
 801a920:	f7ff fa71 	bl	8019e06 <uECC_vli_testBit>
 801a924:	3800      	subs	r0, #0
		point = points[index];
 801a926:	ab06      	add	r3, sp, #24
		index = (!!uECC_vli_testBit(u1, i)) | ((!!uECC_vli_testBit(u2, i)) << 1);
 801a928:	bf18      	it	ne
 801a92a:	2001      	movne	r0, #1
 801a92c:	3f00      	subs	r7, #0
 801a92e:	bf18      	it	ne
 801a930:	2701      	movne	r7, #1
 801a932:	ea47 0740 	orr.w	r7, r7, r0, lsl #1
		point = points[index];
 801a936:	f853 7027 	ldr.w	r7, [r3, r7, lsl #2]
		if (point) {
 801a93a:	b327      	cbz	r7, 801a986 <uECC_verify+0x2c0>
			uECC_vli_set(tx, point, num_words);
 801a93c:	4622      	mov	r2, r4
 801a93e:	4639      	mov	r1, r7
 801a940:	a832      	add	r0, sp, #200	@ 0xc8
 801a942:	f7ff fa84 	bl	8019e4e <uECC_vli_set>
			uECC_vli_set(ty, point + num_words, num_words);
 801a946:	9b05      	ldr	r3, [sp, #20]
 801a948:	4622      	mov	r2, r4
 801a94a:	a83a      	add	r0, sp, #232	@ 0xe8
 801a94c:	18f9      	adds	r1, r7, r3
 801a94e:	f7ff fa7e 	bl	8019e4e <uECC_vli_set>
			apply_z(tx, ty, z, curve);
 801a952:	462b      	mov	r3, r5
 801a954:	4632      	mov	r2, r6
 801a956:	a93a      	add	r1, sp, #232	@ 0xe8
 801a958:	a832      	add	r0, sp, #200	@ 0xc8
 801a95a:	f7ff fdc9 	bl	801a4f0 <apply_z>
			uECC_vli_modSub(tz, rx, tx, curve->p, num_words); /* Z = x2 - x1 */
 801a95e:	9b03      	ldr	r3, [sp, #12]
 801a960:	aa32      	add	r2, sp, #200	@ 0xc8
 801a962:	a922      	add	r1, sp, #136	@ 0x88
 801a964:	a842      	add	r0, sp, #264	@ 0x108
 801a966:	9400      	str	r4, [sp, #0]
 801a968:	f7ff fb99 	bl	801a09e <uECC_vli_modSub>
			XYcZ_add(tx, ty, rx, ry, curve);
 801a96c:	ab2a      	add	r3, sp, #168	@ 0xa8
 801a96e:	aa22      	add	r2, sp, #136	@ 0x88
 801a970:	a93a      	add	r1, sp, #232	@ 0xe8
 801a972:	a832      	add	r0, sp, #200	@ 0xc8
 801a974:	9500      	str	r5, [sp, #0]
 801a976:	f7ff fdda 	bl	801a52e <XYcZ_add>
			uECC_vli_modMult_fast(z, z, tz, curve);
 801a97a:	462b      	mov	r3, r5
 801a97c:	aa42      	add	r2, sp, #264	@ 0x108
 801a97e:	4631      	mov	r1, r6
 801a980:	4630      	mov	r0, r6
 801a982:	f7ff fc43 	bl	801a20c <uECC_vli_modMult_fast>
	for (i = num_bits - 2; i >= 0; --i) {
 801a986:	f109 39ff 	add.w	r9, r9, #4294967295
 801a98a:	e792      	b.n	801a8b2 <uECC_verify+0x1ec>

0801a98c <compress>:
	n |= ((unsigned int)(*((*c)++)));
	return n;
}

static void compress(unsigned int *iv, const uint8_t *data)
{
 801a98c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	unsigned int t1, t2;
	unsigned int work_space[16];
	unsigned int n;
	unsigned int i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
 801a990:	6803      	ldr	r3, [r0, #0]
{
 801a992:	b09d      	sub	sp, #116	@ 0x74
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
 801a994:	f8df a1c4 	ldr.w	sl, [pc, #452]	@ 801ab5c <compress+0x1d0>
 801a998:	2600      	movs	r6, #0
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
 801a99a:	9303      	str	r3, [sp, #12]

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
 801a99c:	f10d 0e30 	add.w	lr, sp, #48	@ 0x30
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
 801a9a0:	6843      	ldr	r3, [r0, #4]
{
 801a9a2:	9102      	str	r1, [sp, #8]
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
 801a9a4:	9304      	str	r3, [sp, #16]
 801a9a6:	6883      	ldr	r3, [r0, #8]
 801a9a8:	9305      	str	r3, [sp, #20]
 801a9aa:	68c3      	ldr	r3, [r0, #12]
 801a9ac:	9306      	str	r3, [sp, #24]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
 801a9ae:	6903      	ldr	r3, [r0, #16]
 801a9b0:	9307      	str	r3, [sp, #28]
 801a9b2:	6943      	ldr	r3, [r0, #20]
 801a9b4:	9308      	str	r3, [sp, #32]
 801a9b6:	6983      	ldr	r3, [r0, #24]
 801a9b8:	9309      	str	r3, [sp, #36]	@ 0x24
 801a9ba:	69c3      	ldr	r3, [r0, #28]
 801a9bc:	e9dd 2c07 	ldrd	r2, ip, [sp, #28]
 801a9c0:	4698      	mov	r8, r3
 801a9c2:	930a      	str	r3, [sp, #40]	@ 0x28
 801a9c4:	9b09      	ldr	r3, [sp, #36]	@ 0x24
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
 801a9c6:	e9dd b705 	ldrd	fp, r7, [sp, #20]
 801a9ca:	e9dd 1503 	ldrd	r1, r5, [sp, #12]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
 801a9ce:	9301      	str	r3, [sp, #4]
		n = BigEndian(&data);
 801a9d0:	9b02      	ldr	r3, [sp, #8]
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801a9d2:	f85a 9b04 	ldr.w	r9, [sl], #4
 801a9d6:	599c      	ldr	r4, [r3, r6]
	return (((a) >> n) | ((a) << (32 - n)));
 801a9d8:	ea4f 23f2 	mov.w	r3, r2, ror #11
 801a9dc:	ba24      	rev	r4, r4
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801a9de:	ea83 13b2 	eor.w	r3, r3, r2, ror #6
 801a9e2:	44a1      	add	r9, r4
		t1 = work_space[i] = n;
 801a9e4:	f846 400e 	str.w	r4, [r6, lr]
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801a9e8:	ea83 6372 	eor.w	r3, r3, r2, ror #25
 801a9ec:	9c01      	ldr	r4, [sp, #4]
	for (i = 0; i < 16; ++i) {
 801a9ee:	3604      	adds	r6, #4
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801a9f0:	444b      	add	r3, r9
 801a9f2:	ea24 0402 	bic.w	r4, r4, r2
 801a9f6:	ea02 090c 	and.w	r9, r2, ip
	for (i = 0; i < 16; ++i) {
 801a9fa:	2e40      	cmp	r6, #64	@ 0x40
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801a9fc:	ea84 0409 	eor.w	r4, r4, r9
		t2 = Sigma0(a) + Maj(a, b, c);
 801aa00:	ea05 090b 	and.w	r9, r5, fp
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aa04:	4423      	add	r3, r4
		t2 = Sigma0(a) + Maj(a, b, c);
 801aa06:	ea85 040b 	eor.w	r4, r5, fp
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aa0a:	4443      	add	r3, r8
	return (((a) >> n) | ((a) << (32 - n)));
 801aa0c:	ea4f 3871 	mov.w	r8, r1, ror #13
		t2 = Sigma0(a) + Maj(a, b, c);
 801aa10:	ea04 0401 	and.w	r4, r4, r1
 801aa14:	ea88 08b1 	eor.w	r8, r8, r1, ror #2
 801aa18:	ea84 0409 	eor.w	r4, r4, r9
 801aa1c:	ea88 58b1 	eor.w	r8, r8, r1, ror #22
 801aa20:	44a0      	add	r8, r4
		h = g; g = f; f = e; e = d + t1;
 801aa22:	eb03 0407 	add.w	r4, r3, r7
		d = c; c = b; b = a; a = t1 + t2;
 801aa26:	465f      	mov	r7, fp
 801aa28:	4443      	add	r3, r8
 801aa2a:	f8dd 8004 	ldr.w	r8, [sp, #4]
 801aa2e:	9300      	str	r3, [sp, #0]
	for (i = 0; i < 16; ++i) {
 801aa30:	f040 8082 	bne.w	801ab38 <compress+0x1ac>
 801aa34:	4b48      	ldr	r3, [pc, #288]	@ (801ab58 <compress+0x1cc>)
 801aa36:	f04f 0a10 	mov.w	sl, #16
 801aa3a:	930b      	str	r3, [sp, #44]	@ 0x2c
	}

	for ( ; i < 64; ++i) {
		s0 = work_space[(i+1)&0x0f];
 801aa3c:	4656      	mov	r6, sl
 801aa3e:	f10a 0a01 	add.w	sl, sl, #1
 801aa42:	ab1c      	add	r3, sp, #112	@ 0x70
 801aa44:	f00a 070f 	and.w	r7, sl, #15
		s0 = sigma0(s0);
		s1 = work_space[(i+14)&0x0f];
		s1 = sigma1(s1);

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aa48:	f006 090f 	and.w	r9, r6, #15
	for ( ; i < 64; ++i) {
 801aa4c:	f1ba 0f40 	cmp.w	sl, #64	@ 0x40
		s0 = work_space[(i+1)&0x0f];
 801aa50:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 801aa54:	f857 3c40 	ldr.w	r3, [r7, #-64]
		s1 = work_space[(i+14)&0x0f];
 801aa58:	f106 070e 	add.w	r7, r6, #14
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aa5c:	f106 0609 	add.w	r6, r6, #9
	return (((a) >> n) | ((a) << (32 - n)));
 801aa60:	ea4f 48b3 	mov.w	r8, r3, ror #18
		s0 = work_space[(i+1)&0x0f];
 801aa64:	9302      	str	r3, [sp, #8]
		s1 = work_space[(i+14)&0x0f];
 801aa66:	f007 070f 	and.w	r7, r7, #15
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aa6a:	f006 060f 	and.w	r6, r6, #15
		s0 = sigma0(s0);
 801aa6e:	ea88 18f3 	eor.w	r8, r8, r3, ror #7
		s1 = work_space[(i+14)&0x0f];
 801aa72:	ab1c      	add	r3, sp, #112	@ 0x70
 801aa74:	eb03 0787 	add.w	r7, r3, r7, lsl #2
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aa78:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 801aa7c:	eb03 0989 	add.w	r9, r3, r9, lsl #2
		s1 = work_space[(i+14)&0x0f];
 801aa80:	f857 7c40 	ldr.w	r7, [r7, #-64]
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aa84:	f856 6c40 	ldr.w	r6, [r6, #-64]
 801aa88:	f859 3c40 	ldr.w	r3, [r9, #-64]
	return (((a) >> n) | ((a) << (32 - n)));
 801aa8c:	ea4f 4ef7 	mov.w	lr, r7, ror #19
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aa90:	441e      	add	r6, r3
		s0 = sigma0(s0);
 801aa92:	9b02      	ldr	r3, [sp, #8]
		s1 = sigma1(s1);
 801aa94:	ea8e 4e77 	eor.w	lr, lr, r7, ror #17
		s0 = sigma0(s0);
 801aa98:	ea88 08d3 	eor.w	r8, r8, r3, lsr #3
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aa9c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
		s1 = sigma1(s1);
 801aa9e:	ea8e 2e97 	eor.w	lr, lr, r7, lsr #10
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aaa2:	ea2c 0704 	bic.w	r7, ip, r4
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aaa6:	4446      	add	r6, r8
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aaa8:	ea04 0802 	and.w	r8, r4, r2
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aaac:	4476      	add	r6, lr
	return (((a) >> n) | ((a) << (32 - n)));
 801aaae:	ea4f 2ef4 	mov.w	lr, r4, ror #11
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aab2:	ea87 0708 	eor.w	r7, r7, r8
		t2 = Sigma0(a) + Maj(a, b, c);
 801aab6:	ea01 0805 	and.w	r8, r1, r5
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aaba:	ea8e 1eb4 	eor.w	lr, lr, r4, ror #6
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
 801aabe:	f849 6c40 	str.w	r6, [r9, #-64]
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aac2:	ea8e 6e74 	eor.w	lr, lr, r4, ror #25
 801aac6:	4477      	add	r7, lr
 801aac8:	f853 ef04 	ldr.w	lr, [r3, #4]!
 801aacc:	4477      	add	r7, lr
 801aace:	930b      	str	r3, [sp, #44]	@ 0x2c
	return (((a) >> n) | ((a) << (32 - n)));
 801aad0:	9b00      	ldr	r3, [sp, #0]
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aad2:	4437      	add	r7, r6
 801aad4:	9e01      	ldr	r6, [sp, #4]
	return (((a) >> n) | ((a) << (32 - n)));
 801aad6:	ea4f 3e73 	mov.w	lr, r3, ror #13
 801aada:	f8cd c004 	str.w	ip, [sp, #4]
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
 801aade:	443e      	add	r6, r7
		t2 = Sigma0(a) + Maj(a, b, c);
 801aae0:	ea81 0705 	eor.w	r7, r1, r5
 801aae4:	ea8e 0eb3 	eor.w	lr, lr, r3, ror #2
 801aae8:	ea07 0703 	and.w	r7, r7, r3
 801aaec:	ea8e 5eb3 	eor.w	lr, lr, r3, ror #22
 801aaf0:	ea87 0708 	eor.w	r7, r7, r8
 801aaf4:	4477      	add	r7, lr
		h = g; g = f; f = e; e = d + t1;
 801aaf6:	eb06 0e0b 	add.w	lr, r6, fp
		d = c; c = b; b = a; a = t1 + t2;
 801aafa:	46ab      	mov	fp, r5
 801aafc:	4437      	add	r7, r6
	for ( ; i < 64; ++i) {
 801aafe:	d123      	bne.n	801ab48 <compress+0x1bc>
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
 801ab00:	9b03      	ldr	r3, [sp, #12]
 801ab02:	9e00      	ldr	r6, [sp, #0]
 801ab04:	19df      	adds	r7, r3, r7
 801ab06:	9b04      	ldr	r3, [sp, #16]
 801ab08:	4433      	add	r3, r6
 801ab0a:	6007      	str	r7, [r0, #0]
 801ab0c:	6043      	str	r3, [r0, #4]
 801ab0e:	9b05      	ldr	r3, [sp, #20]
 801ab10:	1859      	adds	r1, r3, r1
 801ab12:	9b06      	ldr	r3, [sp, #24]
 801ab14:	195d      	adds	r5, r3, r5
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
 801ab16:	9b07      	ldr	r3, [sp, #28]
	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
 801ab18:	6081      	str	r1, [r0, #8]
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
 801ab1a:	4473      	add	r3, lr
	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
 801ab1c:	60c5      	str	r5, [r0, #12]
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
 801ab1e:	6103      	str	r3, [r0, #16]
 801ab20:	9b08      	ldr	r3, [sp, #32]
 801ab22:	191c      	adds	r4, r3, r4
 801ab24:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801ab26:	189a      	adds	r2, r3, r2
 801ab28:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801ab2a:	6144      	str	r4, [r0, #20]
 801ab2c:	4463      	add	r3, ip
 801ab2e:	6182      	str	r2, [r0, #24]
 801ab30:	61c3      	str	r3, [r0, #28]
}
 801ab32:	b01d      	add	sp, #116	@ 0x74
 801ab34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801ab38:	46ab      	mov	fp, r5
 801ab3a:	f8cd c004 	str.w	ip, [sp, #4]
 801ab3e:	460d      	mov	r5, r1
 801ab40:	4694      	mov	ip, r2
 801ab42:	9900      	ldr	r1, [sp, #0]
 801ab44:	4622      	mov	r2, r4
 801ab46:	e743      	b.n	801a9d0 <compress+0x44>
 801ab48:	4694      	mov	ip, r2
 801ab4a:	460d      	mov	r5, r1
 801ab4c:	4622      	mov	r2, r4
 801ab4e:	9900      	ldr	r1, [sp, #0]
 801ab50:	4674      	mov	r4, lr
 801ab52:	9700      	str	r7, [sp, #0]
 801ab54:	e772      	b.n	801aa3c <compress+0xb0>
 801ab56:	bf00      	nop
 801ab58:	0801c714 	.word	0x0801c714
 801ab5c:	0801c6d8 	.word	0x0801c6d8

0801ab60 <tc_sha256_init>:
{
 801ab60:	b510      	push	{r4, lr}
 801ab62:	4604      	mov	r4, r0
	if (s == (TCSha256State_t) 0) {
 801ab64:	b1c8      	cbz	r0, 801ab9a <tc_sha256_init+0x3a>
	_set((uint8_t *) s, 0x00, sizeof(*s));
 801ab66:	2270      	movs	r2, #112	@ 0x70
 801ab68:	2100      	movs	r1, #0
 801ab6a:	f000 f8ad 	bl	801acc8 <_set>
	s->iv[1] = 0xbb67ae85;
 801ab6e:	4b0b      	ldr	r3, [pc, #44]	@ (801ab9c <tc_sha256_init+0x3c>)
 801ab70:	4a0b      	ldr	r2, [pc, #44]	@ (801aba0 <tc_sha256_init+0x40>)
	s->iv[3] = 0xa54ff53a;
 801ab72:	490c      	ldr	r1, [pc, #48]	@ (801aba4 <tc_sha256_init+0x44>)
	s->iv[5] = 0x9b05688c;
 801ab74:	480c      	ldr	r0, [pc, #48]	@ (801aba8 <tc_sha256_init+0x48>)
	s->iv[1] = 0xbb67ae85;
 801ab76:	e9c4 2300 	strd	r2, r3, [r4]
	s->iv[3] = 0xa54ff53a;
 801ab7a:	4b0c      	ldr	r3, [pc, #48]	@ (801abac <tc_sha256_init+0x4c>)
 801ab7c:	e9c4 1302 	strd	r1, r3, [r4, #8]
	s->iv[5] = 0x9b05688c;
 801ab80:	4b0b      	ldr	r3, [pc, #44]	@ (801abb0 <tc_sha256_init+0x50>)
 801ab82:	e9c4 0304 	strd	r0, r3, [r4, #16]
	s->iv[6] = 0x1f83d9ab;
 801ab86:	4b0b      	ldr	r3, [pc, #44]	@ (801abb4 <tc_sha256_init+0x54>)
	return TC_CRYPTO_SUCCESS;
 801ab88:	2001      	movs	r0, #1
	s->iv[6] = 0x1f83d9ab;
 801ab8a:	61a3      	str	r3, [r4, #24]
	s->iv[7] = 0x5be0cd19;
 801ab8c:	f103 5374 	add.w	r3, r3, #1023410176	@ 0x3d000000
 801ab90:	f5a3 0323 	sub.w	r3, r3, #10682368	@ 0xa30000
 801ab94:	f6a3 4392 	subw	r3, r3, #3218	@ 0xc92
 801ab98:	61e3      	str	r3, [r4, #28]
}
 801ab9a:	bd10      	pop	{r4, pc}
 801ab9c:	bb67ae85 	.word	0xbb67ae85
 801aba0:	6a09e667 	.word	0x6a09e667
 801aba4:	3c6ef372 	.word	0x3c6ef372
 801aba8:	510e527f 	.word	0x510e527f
 801abac:	a54ff53a 	.word	0xa54ff53a
 801abb0:	9b05688c 	.word	0x9b05688c
 801abb4:	1f83d9ab 	.word	0x1f83d9ab

0801abb8 <tc_sha256_update>:
{
 801abb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801abba:	460c      	mov	r4, r1
	if (s == (TCSha256State_t) 0 ||
 801abbc:	b110      	cbz	r0, 801abc4 <tc_sha256_update+0xc>
 801abbe:	b1f9      	cbz	r1, 801ac00 <tc_sha256_update+0x48>
	} else if (datalen == 0) {
 801abc0:	b90a      	cbnz	r2, 801abc6 <tc_sha256_update+0xe>
		return TC_CRYPTO_SUCCESS;
 801abc2:	2001      	movs	r0, #1
}
 801abc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801abc6:	188d      	adds	r5, r1, r2
			compress(s->iv, s->leftover);
 801abc8:	f100 0628 	add.w	r6, r0, #40	@ 0x28
			s->leftover_offset = 0;
 801abcc:	2700      	movs	r7, #0
	while (datalen-- > 0) {
 801abce:	42ac      	cmp	r4, r5
 801abd0:	d0f7      	beq.n	801abc2 <tc_sha256_update+0xa>
		s->leftover[s->leftover_offset++] = *(data++);
 801abd2:	6e83      	ldr	r3, [r0, #104]	@ 0x68
 801abd4:	1c5a      	adds	r2, r3, #1
 801abd6:	4403      	add	r3, r0
 801abd8:	6682      	str	r2, [r0, #104]	@ 0x68
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
 801abda:	2a3f      	cmp	r2, #63	@ 0x3f
		s->leftover[s->leftover_offset++] = *(data++);
 801abdc:	f814 1b01 	ldrb.w	r1, [r4], #1
 801abe0:	f883 1028 	strb.w	r1, [r3, #40]	@ 0x28
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
 801abe4:	d9f3      	bls.n	801abce <tc_sha256_update+0x16>
			compress(s->iv, s->leftover);
 801abe6:	4631      	mov	r1, r6
 801abe8:	f7ff fed0 	bl	801a98c <compress>
			s->leftover_offset = 0;
 801abec:	6687      	str	r7, [r0, #104]	@ 0x68
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
 801abee:	e9d0 3208 	ldrd	r3, r2, [r0, #32]
 801abf2:	f513 7300 	adds.w	r3, r3, #512	@ 0x200
 801abf6:	f142 0200 	adc.w	r2, r2, #0
 801abfa:	e9c0 3208 	strd	r3, r2, [r0, #32]
 801abfe:	e7e6      	b.n	801abce <tc_sha256_update+0x16>
		return TC_CRYPTO_FAIL;
 801ac00:	4608      	mov	r0, r1
 801ac02:	e7df      	b.n	801abc4 <tc_sha256_update+0xc>

0801ac04 <tc_sha256_final>:
{
 801ac04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ac06:	4605      	mov	r5, r0
 801ac08:	460c      	mov	r4, r1
	if (digest == (uint8_t *) 0 ||
 801ac0a:	2800      	cmp	r0, #0
 801ac0c:	d04c      	beq.n	801aca8 <tc_sha256_final+0xa4>
 801ac0e:	2900      	cmp	r1, #0
 801ac10:	d04b      	beq.n	801acaa <tc_sha256_final+0xa6>
	s->bits_hashed += (s->leftover_offset << 3);
 801ac12:	6e8b      	ldr	r3, [r1, #104]	@ 0x68
 801ac14:	2700      	movs	r7, #0
 801ac16:	f104 0628 	add.w	r6, r4, #40	@ 0x28
 801ac1a:	00d8      	lsls	r0, r3, #3
 801ac1c:	e9d1 2108 	ldrd	r2, r1, [r1, #32]
 801ac20:	1812      	adds	r2, r2, r0
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
 801ac22:	f103 0001 	add.w	r0, r3, #1
 801ac26:	4423      	add	r3, r4
	s->bits_hashed += (s->leftover_offset << 3);
 801ac28:	f141 0100 	adc.w	r1, r1, #0
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
 801ac2c:	2838      	cmp	r0, #56	@ 0x38
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
 801ac2e:	66a0      	str	r0, [r4, #104]	@ 0x68
	s->bits_hashed += (s->leftover_offset << 3);
 801ac30:	e9c4 2108 	strd	r2, r1, [r4, #32]
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
 801ac34:	f04f 0280 	mov.w	r2, #128	@ 0x80
 801ac38:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
 801ac3c:	d90b      	bls.n	801ac56 <tc_sha256_final+0x52>
		_set(s->leftover + s->leftover_offset, 0x00,
 801ac3e:	f1c0 0240 	rsb	r2, r0, #64	@ 0x40
 801ac42:	4639      	mov	r1, r7
 801ac44:	4430      	add	r0, r6
 801ac46:	f000 f83f 	bl	801acc8 <_set>
		compress(s->iv, s->leftover);
 801ac4a:	4620      	mov	r0, r4
 801ac4c:	4631      	mov	r1, r6
 801ac4e:	f7ff fe9d 	bl	801a98c <compress>
		s->leftover_offset = 0;
 801ac52:	4638      	mov	r0, r7
 801ac54:	66a7      	str	r7, [r4, #104]	@ 0x68
	_set(s->leftover + s->leftover_offset, 0x00,
 801ac56:	f1c0 0238 	rsb	r2, r0, #56	@ 0x38
 801ac5a:	2100      	movs	r1, #0
 801ac5c:	4430      	add	r0, r6
 801ac5e:	f000 f833 	bl	801acc8 <_set>
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
 801ac62:	6a23      	ldr	r3, [r4, #32]
 801ac64:	6a62      	ldr	r2, [r4, #36]	@ 0x24
	compress(s->iv, s->leftover);
 801ac66:	4631      	mov	r1, r6
 801ac68:	ba1b      	rev	r3, r3
 801ac6a:	4620      	mov	r0, r4
 801ac6c:	ba12      	rev	r2, r2
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
 801ac6e:	e9c4 2318 	strd	r2, r3, [r4, #96]	@ 0x60
	compress(s->iv, s->leftover);
 801ac72:	f7ff fe8b 	bl	801a98c <compress>
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
 801ac76:	1d2b      	adds	r3, r5, #4
 801ac78:	1f21      	subs	r1, r4, #4
 801ac7a:	3524      	adds	r5, #36	@ 0x24
		unsigned int t = *((unsigned int *) &s->iv[i]);
 801ac7c:	f851 2f04 	ldr.w	r2, [r1, #4]!
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
 801ac80:	3304      	adds	r3, #4
		*digest++ = (uint8_t)(t >> 24);
 801ac82:	0e10      	lsrs	r0, r2, #24
		*digest++ = (uint8_t)(t);
 801ac84:	f803 2c05 	strb.w	r2, [r3, #-5]
		*digest++ = (uint8_t)(t >> 24);
 801ac88:	f803 0c08 	strb.w	r0, [r3, #-8]
		*digest++ = (uint8_t)(t >> 16);
 801ac8c:	0c10      	lsrs	r0, r2, #16
 801ac8e:	f803 0c07 	strb.w	r0, [r3, #-7]
		*digest++ = (uint8_t)(t >> 8);
 801ac92:	0a10      	lsrs	r0, r2, #8
 801ac94:	f803 0c06 	strb.w	r0, [r3, #-6]
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
 801ac98:	42ab      	cmp	r3, r5
 801ac9a:	d1ef      	bne.n	801ac7c <tc_sha256_final+0x78>
	_set(s, 0, sizeof(*s));
 801ac9c:	4620      	mov	r0, r4
 801ac9e:	2270      	movs	r2, #112	@ 0x70
 801aca0:	2100      	movs	r1, #0
 801aca2:	f000 f811 	bl	801acc8 <_set>
	return TC_CRYPTO_SUCCESS;
 801aca6:	2001      	movs	r0, #1
}
 801aca8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
 801acaa:	4608      	mov	r0, r1
 801acac:	e7fc      	b.n	801aca8 <tc_sha256_final+0xa4>

0801acae <_copy>:

#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
 801acae:	b538      	push	{r3, r4, r5, lr}
 801acb0:	460d      	mov	r5, r1
 801acb2:	461c      	mov	r4, r3
 801acb4:	4611      	mov	r1, r2
	if (from_len <= to_len) {
 801acb6:	42ab      	cmp	r3, r5
 801acb8:	d804      	bhi.n	801acc4 <_copy+0x16>
		(void)memcpy(to, from, from_len);
 801acba:	461a      	mov	r2, r3
 801acbc:	f000 fa95 	bl	801b1ea <memcpy>
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
 801acc0:	4620      	mov	r0, r4
 801acc2:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
 801acc4:	2400      	movs	r4, #0
 801acc6:	e7fb      	b.n	801acc0 <_copy+0x12>

0801acc8 <_set>:

void _set(void *to, uint8_t val, unsigned int len)
{
	(void)memset(to, val, len);
 801acc8:	f000 ba04 	b.w	801b0d4 <memset>

0801accc <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
 801accc:	09c3      	lsrs	r3, r0, #7
 801acce:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801acd2:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 801acd6:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
 801acda:	b2c0      	uxtb	r0, r0
 801acdc:	4770      	bx	lr
	...

0801ace0 <__assert_func>:
 801ace0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 801ace2:	461d      	mov	r5, r3
 801ace4:	4b09      	ldr	r3, [pc, #36]	@ (801ad0c <__assert_func+0x2c>)
 801ace6:	681b      	ldr	r3, [r3, #0]
 801ace8:	4606      	mov	r6, r0
 801acea:	68d8      	ldr	r0, [r3, #12]
 801acec:	b152      	cbz	r2, 801ad04 <__assert_func+0x24>
 801acee:	4c08      	ldr	r4, [pc, #32]	@ (801ad10 <__assert_func+0x30>)
 801acf0:	9100      	str	r1, [sp, #0]
 801acf2:	e9cd 4201 	strd	r4, r2, [sp, #4]
 801acf6:	4907      	ldr	r1, [pc, #28]	@ (801ad14 <__assert_func+0x34>)
 801acf8:	4633      	mov	r3, r6
 801acfa:	462a      	mov	r2, r5
 801acfc:	f000 f95e 	bl	801afbc <fiprintf>
 801ad00:	f000 fa81 	bl	801b206 <abort>
 801ad04:	4c04      	ldr	r4, [pc, #16]	@ (801ad18 <__assert_func+0x38>)
 801ad06:	4622      	mov	r2, r4
 801ad08:	e7f2      	b.n	801acf0 <__assert_func+0x10>
 801ad0a:	bf00      	nop
 801ad0c:	20000018 	.word	0x20000018
 801ad10:	0801c359 	.word	0x0801c359
 801ad14:	0801c366 	.word	0x0801c366
 801ad18:	0801c14b 	.word	0x0801c14b

0801ad1c <sbrk_aligned>:
 801ad1c:	b570      	push	{r4, r5, r6, lr}
 801ad1e:	4c0f      	ldr	r4, [pc, #60]	@ (801ad5c <sbrk_aligned+0x40>)
 801ad20:	460e      	mov	r6, r1
 801ad22:	6821      	ldr	r1, [r4, #0]
 801ad24:	4605      	mov	r5, r0
 801ad26:	b911      	cbnz	r1, 801ad2e <sbrk_aligned+0x12>
 801ad28:	f000 fa10 	bl	801b14c <_sbrk_r>
 801ad2c:	6020      	str	r0, [r4, #0]
 801ad2e:	4631      	mov	r1, r6
 801ad30:	4628      	mov	r0, r5
 801ad32:	f000 fa0b 	bl	801b14c <_sbrk_r>
 801ad36:	1c43      	adds	r3, r0, #1
 801ad38:	d103      	bne.n	801ad42 <sbrk_aligned+0x26>
 801ad3a:	f04f 34ff 	mov.w	r4, #4294967295
 801ad3e:	4620      	mov	r0, r4
 801ad40:	bd70      	pop	{r4, r5, r6, pc}
 801ad42:	1cc4      	adds	r4, r0, #3
 801ad44:	f024 0403 	bic.w	r4, r4, #3
 801ad48:	42a0      	cmp	r0, r4
 801ad4a:	d0f8      	beq.n	801ad3e <sbrk_aligned+0x22>
 801ad4c:	1a21      	subs	r1, r4, r0
 801ad4e:	4628      	mov	r0, r5
 801ad50:	f000 f9fc 	bl	801b14c <_sbrk_r>
 801ad54:	3001      	adds	r0, #1
 801ad56:	d1f2      	bne.n	801ad3e <sbrk_aligned+0x22>
 801ad58:	e7ef      	b.n	801ad3a <sbrk_aligned+0x1e>
 801ad5a:	bf00      	nop
 801ad5c:	20001954 	.word	0x20001954

0801ad60 <_malloc_r>:
 801ad60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801ad64:	1ccd      	adds	r5, r1, #3
 801ad66:	f025 0503 	bic.w	r5, r5, #3
 801ad6a:	3508      	adds	r5, #8
 801ad6c:	2d0c      	cmp	r5, #12
 801ad6e:	bf38      	it	cc
 801ad70:	250c      	movcc	r5, #12
 801ad72:	2d00      	cmp	r5, #0
 801ad74:	4606      	mov	r6, r0
 801ad76:	db01      	blt.n	801ad7c <_malloc_r+0x1c>
 801ad78:	42a9      	cmp	r1, r5
 801ad7a:	d904      	bls.n	801ad86 <_malloc_r+0x26>
 801ad7c:	230c      	movs	r3, #12
 801ad7e:	6033      	str	r3, [r6, #0]
 801ad80:	2000      	movs	r0, #0
 801ad82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801ad86:	4f33      	ldr	r7, [pc, #204]	@ (801ae54 <_malloc_r+0xf4>)
 801ad88:	f000 f866 	bl	801ae58 <__malloc_lock>
 801ad8c:	683b      	ldr	r3, [r7, #0]
 801ad8e:	461c      	mov	r4, r3
 801ad90:	bb3c      	cbnz	r4, 801ade2 <_malloc_r+0x82>
 801ad92:	4629      	mov	r1, r5
 801ad94:	4630      	mov	r0, r6
 801ad96:	f7ff ffc1 	bl	801ad1c <sbrk_aligned>
 801ad9a:	1c43      	adds	r3, r0, #1
 801ad9c:	4604      	mov	r4, r0
 801ad9e:	d156      	bne.n	801ae4e <_malloc_r+0xee>
 801ada0:	683c      	ldr	r4, [r7, #0]
 801ada2:	46a0      	mov	r8, r4
 801ada4:	f1b8 0f00 	cmp.w	r8, #0
 801ada8:	d140      	bne.n	801ae2c <_malloc_r+0xcc>
 801adaa:	2c00      	cmp	r4, #0
 801adac:	d049      	beq.n	801ae42 <_malloc_r+0xe2>
 801adae:	6823      	ldr	r3, [r4, #0]
 801adb0:	4641      	mov	r1, r8
 801adb2:	4630      	mov	r0, r6
 801adb4:	eb04 0903 	add.w	r9, r4, r3
 801adb8:	f000 f9c8 	bl	801b14c <_sbrk_r>
 801adbc:	4581      	cmp	r9, r0
 801adbe:	d140      	bne.n	801ae42 <_malloc_r+0xe2>
 801adc0:	6821      	ldr	r1, [r4, #0]
 801adc2:	1a6d      	subs	r5, r5, r1
 801adc4:	4629      	mov	r1, r5
 801adc6:	4630      	mov	r0, r6
 801adc8:	f7ff ffa8 	bl	801ad1c <sbrk_aligned>
 801adcc:	3001      	adds	r0, #1
 801adce:	d038      	beq.n	801ae42 <_malloc_r+0xe2>
 801add0:	6823      	ldr	r3, [r4, #0]
 801add2:	442b      	add	r3, r5
 801add4:	6023      	str	r3, [r4, #0]
 801add6:	683b      	ldr	r3, [r7, #0]
 801add8:	685a      	ldr	r2, [r3, #4]
 801adda:	bb5a      	cbnz	r2, 801ae34 <_malloc_r+0xd4>
 801addc:	f8c7 8000 	str.w	r8, [r7]
 801ade0:	e00e      	b.n	801ae00 <_malloc_r+0xa0>
 801ade2:	6822      	ldr	r2, [r4, #0]
 801ade4:	1b52      	subs	r2, r2, r5
 801ade6:	d41e      	bmi.n	801ae26 <_malloc_r+0xc6>
 801ade8:	2a0b      	cmp	r2, #11
 801adea:	d916      	bls.n	801ae1a <_malloc_r+0xba>
 801adec:	1961      	adds	r1, r4, r5
 801adee:	42a3      	cmp	r3, r4
 801adf0:	6025      	str	r5, [r4, #0]
 801adf2:	bf18      	it	ne
 801adf4:	6059      	strne	r1, [r3, #4]
 801adf6:	6863      	ldr	r3, [r4, #4]
 801adf8:	bf08      	it	eq
 801adfa:	6039      	streq	r1, [r7, #0]
 801adfc:	5162      	str	r2, [r4, r5]
 801adfe:	604b      	str	r3, [r1, #4]
 801ae00:	4630      	mov	r0, r6
 801ae02:	f000 f82f 	bl	801ae64 <__malloc_unlock>
 801ae06:	f104 000b 	add.w	r0, r4, #11
 801ae0a:	1d23      	adds	r3, r4, #4
 801ae0c:	f020 0007 	bic.w	r0, r0, #7
 801ae10:	1ac2      	subs	r2, r0, r3
 801ae12:	bf1c      	itt	ne
 801ae14:	1a1b      	subne	r3, r3, r0
 801ae16:	50a3      	strne	r3, [r4, r2]
 801ae18:	e7b3      	b.n	801ad82 <_malloc_r+0x22>
 801ae1a:	6862      	ldr	r2, [r4, #4]
 801ae1c:	42a3      	cmp	r3, r4
 801ae1e:	bf0c      	ite	eq
 801ae20:	603a      	streq	r2, [r7, #0]
 801ae22:	605a      	strne	r2, [r3, #4]
 801ae24:	e7ec      	b.n	801ae00 <_malloc_r+0xa0>
 801ae26:	4623      	mov	r3, r4
 801ae28:	6864      	ldr	r4, [r4, #4]
 801ae2a:	e7b1      	b.n	801ad90 <_malloc_r+0x30>
 801ae2c:	4644      	mov	r4, r8
 801ae2e:	f8d8 8004 	ldr.w	r8, [r8, #4]
 801ae32:	e7b7      	b.n	801ada4 <_malloc_r+0x44>
 801ae34:	461a      	mov	r2, r3
 801ae36:	685b      	ldr	r3, [r3, #4]
 801ae38:	42a3      	cmp	r3, r4
 801ae3a:	d1fb      	bne.n	801ae34 <_malloc_r+0xd4>
 801ae3c:	2300      	movs	r3, #0
 801ae3e:	6053      	str	r3, [r2, #4]
 801ae40:	e7de      	b.n	801ae00 <_malloc_r+0xa0>
 801ae42:	230c      	movs	r3, #12
 801ae44:	6033      	str	r3, [r6, #0]
 801ae46:	4630      	mov	r0, r6
 801ae48:	f000 f80c 	bl	801ae64 <__malloc_unlock>
 801ae4c:	e798      	b.n	801ad80 <_malloc_r+0x20>
 801ae4e:	6005      	str	r5, [r0, #0]
 801ae50:	e7d6      	b.n	801ae00 <_malloc_r+0xa0>
 801ae52:	bf00      	nop
 801ae54:	20001958 	.word	0x20001958

0801ae58 <__malloc_lock>:
 801ae58:	4801      	ldr	r0, [pc, #4]	@ (801ae60 <__malloc_lock+0x8>)
 801ae5a:	f000 b9c4 	b.w	801b1e6 <__retarget_lock_acquire_recursive>
 801ae5e:	bf00      	nop
 801ae60:	20001a9c 	.word	0x20001a9c

0801ae64 <__malloc_unlock>:
 801ae64:	4801      	ldr	r0, [pc, #4]	@ (801ae6c <__malloc_unlock+0x8>)
 801ae66:	f000 b9bf 	b.w	801b1e8 <__retarget_lock_release_recursive>
 801ae6a:	bf00      	nop
 801ae6c:	20001a9c 	.word	0x20001a9c

0801ae70 <std>:
 801ae70:	2300      	movs	r3, #0
 801ae72:	b510      	push	{r4, lr}
 801ae74:	4604      	mov	r4, r0
 801ae76:	e9c0 3300 	strd	r3, r3, [r0]
 801ae7a:	e9c0 3304 	strd	r3, r3, [r0, #16]
 801ae7e:	6083      	str	r3, [r0, #8]
 801ae80:	8181      	strh	r1, [r0, #12]
 801ae82:	6643      	str	r3, [r0, #100]	@ 0x64
 801ae84:	81c2      	strh	r2, [r0, #14]
 801ae86:	6183      	str	r3, [r0, #24]
 801ae88:	4619      	mov	r1, r3
 801ae8a:	2208      	movs	r2, #8
 801ae8c:	305c      	adds	r0, #92	@ 0x5c
 801ae8e:	f000 f921 	bl	801b0d4 <memset>
 801ae92:	4b0d      	ldr	r3, [pc, #52]	@ (801aec8 <std+0x58>)
 801ae94:	6263      	str	r3, [r4, #36]	@ 0x24
 801ae96:	4b0d      	ldr	r3, [pc, #52]	@ (801aecc <std+0x5c>)
 801ae98:	62a3      	str	r3, [r4, #40]	@ 0x28
 801ae9a:	4b0d      	ldr	r3, [pc, #52]	@ (801aed0 <std+0x60>)
 801ae9c:	62e3      	str	r3, [r4, #44]	@ 0x2c
 801ae9e:	4b0d      	ldr	r3, [pc, #52]	@ (801aed4 <std+0x64>)
 801aea0:	6323      	str	r3, [r4, #48]	@ 0x30
 801aea2:	4b0d      	ldr	r3, [pc, #52]	@ (801aed8 <std+0x68>)
 801aea4:	6224      	str	r4, [r4, #32]
 801aea6:	429c      	cmp	r4, r3
 801aea8:	d006      	beq.n	801aeb8 <std+0x48>
 801aeaa:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 801aeae:	4294      	cmp	r4, r2
 801aeb0:	d002      	beq.n	801aeb8 <std+0x48>
 801aeb2:	33d0      	adds	r3, #208	@ 0xd0
 801aeb4:	429c      	cmp	r4, r3
 801aeb6:	d105      	bne.n	801aec4 <std+0x54>
 801aeb8:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 801aebc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801aec0:	f000 b990 	b.w	801b1e4 <__retarget_lock_init_recursive>
 801aec4:	bd10      	pop	{r4, pc}
 801aec6:	bf00      	nop
 801aec8:	0801b01b 	.word	0x0801b01b
 801aecc:	0801b03d 	.word	0x0801b03d
 801aed0:	0801b075 	.word	0x0801b075
 801aed4:	0801b09b 	.word	0x0801b09b
 801aed8:	2000195c 	.word	0x2000195c

0801aedc <stdio_exit_handler>:
 801aedc:	4a02      	ldr	r2, [pc, #8]	@ (801aee8 <stdio_exit_handler+0xc>)
 801aede:	4903      	ldr	r1, [pc, #12]	@ (801aeec <stdio_exit_handler+0x10>)
 801aee0:	4803      	ldr	r0, [pc, #12]	@ (801aef0 <stdio_exit_handler+0x14>)
 801aee2:	f000 b87d 	b.w	801afe0 <_fwalk_sglue>
 801aee6:	bf00      	nop
 801aee8:	2000000c 	.word	0x2000000c
 801aeec:	0801b965 	.word	0x0801b965
 801aef0:	2000001c 	.word	0x2000001c

0801aef4 <cleanup_stdio>:
 801aef4:	6841      	ldr	r1, [r0, #4]
 801aef6:	4b0c      	ldr	r3, [pc, #48]	@ (801af28 <cleanup_stdio+0x34>)
 801aef8:	4299      	cmp	r1, r3
 801aefa:	b510      	push	{r4, lr}
 801aefc:	4604      	mov	r4, r0
 801aefe:	d001      	beq.n	801af04 <cleanup_stdio+0x10>
 801af00:	f000 fd30 	bl	801b964 <_fflush_r>
 801af04:	68a1      	ldr	r1, [r4, #8]
 801af06:	4b09      	ldr	r3, [pc, #36]	@ (801af2c <cleanup_stdio+0x38>)
 801af08:	4299      	cmp	r1, r3
 801af0a:	d002      	beq.n	801af12 <cleanup_stdio+0x1e>
 801af0c:	4620      	mov	r0, r4
 801af0e:	f000 fd29 	bl	801b964 <_fflush_r>
 801af12:	68e1      	ldr	r1, [r4, #12]
 801af14:	4b06      	ldr	r3, [pc, #24]	@ (801af30 <cleanup_stdio+0x3c>)
 801af16:	4299      	cmp	r1, r3
 801af18:	d004      	beq.n	801af24 <cleanup_stdio+0x30>
 801af1a:	4620      	mov	r0, r4
 801af1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801af20:	f000 bd20 	b.w	801b964 <_fflush_r>
 801af24:	bd10      	pop	{r4, pc}
 801af26:	bf00      	nop
 801af28:	2000195c 	.word	0x2000195c
 801af2c:	200019c4 	.word	0x200019c4
 801af30:	20001a2c 	.word	0x20001a2c

0801af34 <global_stdio_init.part.0>:
 801af34:	b510      	push	{r4, lr}
 801af36:	4b0a      	ldr	r3, [pc, #40]	@ (801af60 <global_stdio_init.part.0+0x2c>)
 801af38:	4a0a      	ldr	r2, [pc, #40]	@ (801af64 <global_stdio_init.part.0+0x30>)
 801af3a:	601a      	str	r2, [r3, #0]
 801af3c:	480a      	ldr	r0, [pc, #40]	@ (801af68 <global_stdio_init.part.0+0x34>)
 801af3e:	2200      	movs	r2, #0
 801af40:	2104      	movs	r1, #4
 801af42:	f7ff ff95 	bl	801ae70 <std>
 801af46:	4809      	ldr	r0, [pc, #36]	@ (801af6c <global_stdio_init.part.0+0x38>)
 801af48:	2201      	movs	r2, #1
 801af4a:	2109      	movs	r1, #9
 801af4c:	f7ff ff90 	bl	801ae70 <std>
 801af50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801af54:	4806      	ldr	r0, [pc, #24]	@ (801af70 <global_stdio_init.part.0+0x3c>)
 801af56:	2202      	movs	r2, #2
 801af58:	2112      	movs	r1, #18
 801af5a:	f7ff bf89 	b.w	801ae70 <std>
 801af5e:	bf00      	nop
 801af60:	20001a94 	.word	0x20001a94
 801af64:	0801aedd 	.word	0x0801aedd
 801af68:	2000195c 	.word	0x2000195c
 801af6c:	200019c4 	.word	0x200019c4
 801af70:	20001a2c 	.word	0x20001a2c

0801af74 <__sfp_lock_acquire>:
 801af74:	4801      	ldr	r0, [pc, #4]	@ (801af7c <__sfp_lock_acquire+0x8>)
 801af76:	f000 b936 	b.w	801b1e6 <__retarget_lock_acquire_recursive>
 801af7a:	bf00      	nop
 801af7c:	20001a9d 	.word	0x20001a9d

0801af80 <__sfp_lock_release>:
 801af80:	4801      	ldr	r0, [pc, #4]	@ (801af88 <__sfp_lock_release+0x8>)
 801af82:	f000 b931 	b.w	801b1e8 <__retarget_lock_release_recursive>
 801af86:	bf00      	nop
 801af88:	20001a9d 	.word	0x20001a9d

0801af8c <__sinit>:
 801af8c:	b510      	push	{r4, lr}
 801af8e:	4604      	mov	r4, r0
 801af90:	f7ff fff0 	bl	801af74 <__sfp_lock_acquire>
 801af94:	6a23      	ldr	r3, [r4, #32]
 801af96:	b11b      	cbz	r3, 801afa0 <__sinit+0x14>
 801af98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801af9c:	f7ff bff0 	b.w	801af80 <__sfp_lock_release>
 801afa0:	4b04      	ldr	r3, [pc, #16]	@ (801afb4 <__sinit+0x28>)
 801afa2:	6223      	str	r3, [r4, #32]
 801afa4:	4b04      	ldr	r3, [pc, #16]	@ (801afb8 <__sinit+0x2c>)
 801afa6:	681b      	ldr	r3, [r3, #0]
 801afa8:	2b00      	cmp	r3, #0
 801afaa:	d1f5      	bne.n	801af98 <__sinit+0xc>
 801afac:	f7ff ffc2 	bl	801af34 <global_stdio_init.part.0>
 801afb0:	e7f2      	b.n	801af98 <__sinit+0xc>
 801afb2:	bf00      	nop
 801afb4:	0801aef5 	.word	0x0801aef5
 801afb8:	20001a94 	.word	0x20001a94

0801afbc <fiprintf>:
 801afbc:	b40e      	push	{r1, r2, r3}
 801afbe:	b503      	push	{r0, r1, lr}
 801afc0:	4601      	mov	r1, r0
 801afc2:	ab03      	add	r3, sp, #12
 801afc4:	4805      	ldr	r0, [pc, #20]	@ (801afdc <fiprintf+0x20>)
 801afc6:	f853 2b04 	ldr.w	r2, [r3], #4
 801afca:	6800      	ldr	r0, [r0, #0]
 801afcc:	9301      	str	r3, [sp, #4]
 801afce:	f000 f995 	bl	801b2fc <_vfiprintf_r>
 801afd2:	b002      	add	sp, #8
 801afd4:	f85d eb04 	ldr.w	lr, [sp], #4
 801afd8:	b003      	add	sp, #12
 801afda:	4770      	bx	lr
 801afdc:	20000018 	.word	0x20000018

0801afe0 <_fwalk_sglue>:
 801afe0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801afe4:	4680      	mov	r8, r0
 801afe6:	4689      	mov	r9, r1
 801afe8:	4614      	mov	r4, r2
 801afea:	2600      	movs	r6, #0
 801afec:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 801aff0:	3f01      	subs	r7, #1
 801aff2:	d505      	bpl.n	801b000 <_fwalk_sglue+0x20>
 801aff4:	6824      	ldr	r4, [r4, #0]
 801aff6:	2c00      	cmp	r4, #0
 801aff8:	d1f8      	bne.n	801afec <_fwalk_sglue+0xc>
 801affa:	4630      	mov	r0, r6
 801affc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801b000:	89ab      	ldrh	r3, [r5, #12]
 801b002:	2b01      	cmp	r3, #1
 801b004:	d907      	bls.n	801b016 <_fwalk_sglue+0x36>
 801b006:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 801b00a:	3301      	adds	r3, #1
 801b00c:	d003      	beq.n	801b016 <_fwalk_sglue+0x36>
 801b00e:	4629      	mov	r1, r5
 801b010:	4640      	mov	r0, r8
 801b012:	47c8      	blx	r9
 801b014:	4306      	orrs	r6, r0
 801b016:	3568      	adds	r5, #104	@ 0x68
 801b018:	e7ea      	b.n	801aff0 <_fwalk_sglue+0x10>

0801b01a <__sread>:
 801b01a:	b510      	push	{r4, lr}
 801b01c:	460c      	mov	r4, r1
 801b01e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801b022:	f000 f881 	bl	801b128 <_read_r>
 801b026:	2800      	cmp	r0, #0
 801b028:	bfab      	itete	ge
 801b02a:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 801b02c:	89a3      	ldrhlt	r3, [r4, #12]
 801b02e:	181b      	addge	r3, r3, r0
 801b030:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 801b034:	bfac      	ite	ge
 801b036:	6563      	strge	r3, [r4, #84]	@ 0x54
 801b038:	81a3      	strhlt	r3, [r4, #12]
 801b03a:	bd10      	pop	{r4, pc}

0801b03c <__swrite>:
 801b03c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801b040:	461f      	mov	r7, r3
 801b042:	898b      	ldrh	r3, [r1, #12]
 801b044:	05db      	lsls	r3, r3, #23
 801b046:	4605      	mov	r5, r0
 801b048:	460c      	mov	r4, r1
 801b04a:	4616      	mov	r6, r2
 801b04c:	d505      	bpl.n	801b05a <__swrite+0x1e>
 801b04e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801b052:	2302      	movs	r3, #2
 801b054:	2200      	movs	r2, #0
 801b056:	f000 f855 	bl	801b104 <_lseek_r>
 801b05a:	89a3      	ldrh	r3, [r4, #12]
 801b05c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801b060:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 801b064:	81a3      	strh	r3, [r4, #12]
 801b066:	4632      	mov	r2, r6
 801b068:	463b      	mov	r3, r7
 801b06a:	4628      	mov	r0, r5
 801b06c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 801b070:	f000 b87c 	b.w	801b16c <_write_r>

0801b074 <__sseek>:
 801b074:	b510      	push	{r4, lr}
 801b076:	460c      	mov	r4, r1
 801b078:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801b07c:	f000 f842 	bl	801b104 <_lseek_r>
 801b080:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801b084:	1c42      	adds	r2, r0, #1
 801b086:	bf0b      	itete	eq
 801b088:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 801b08c:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 801b090:	81a3      	strheq	r3, [r4, #12]
 801b092:	81a3      	strhne	r3, [r4, #12]
 801b094:	bf18      	it	ne
 801b096:	6560      	strne	r0, [r4, #84]	@ 0x54
 801b098:	bd10      	pop	{r4, pc}

0801b09a <__sclose>:
 801b09a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801b09e:	f000 b821 	b.w	801b0e4 <_close_r>

0801b0a2 <memmove>:
 801b0a2:	4288      	cmp	r0, r1
 801b0a4:	b510      	push	{r4, lr}
 801b0a6:	eb01 0402 	add.w	r4, r1, r2
 801b0aa:	d902      	bls.n	801b0b2 <memmove+0x10>
 801b0ac:	4284      	cmp	r4, r0
 801b0ae:	4623      	mov	r3, r4
 801b0b0:	d807      	bhi.n	801b0c2 <memmove+0x20>
 801b0b2:	1e43      	subs	r3, r0, #1
 801b0b4:	42a1      	cmp	r1, r4
 801b0b6:	d007      	beq.n	801b0c8 <memmove+0x26>
 801b0b8:	f811 2b01 	ldrb.w	r2, [r1], #1
 801b0bc:	f803 2f01 	strb.w	r2, [r3, #1]!
 801b0c0:	e7f8      	b.n	801b0b4 <memmove+0x12>
 801b0c2:	4402      	add	r2, r0
 801b0c4:	4282      	cmp	r2, r0
 801b0c6:	d100      	bne.n	801b0ca <memmove+0x28>
 801b0c8:	bd10      	pop	{r4, pc}
 801b0ca:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
 801b0ce:	f802 1d01 	strb.w	r1, [r2, #-1]!
 801b0d2:	e7f7      	b.n	801b0c4 <memmove+0x22>

0801b0d4 <memset>:
 801b0d4:	4402      	add	r2, r0
 801b0d6:	4603      	mov	r3, r0
 801b0d8:	4293      	cmp	r3, r2
 801b0da:	d100      	bne.n	801b0de <memset+0xa>
 801b0dc:	4770      	bx	lr
 801b0de:	f803 1b01 	strb.w	r1, [r3], #1
 801b0e2:	e7f9      	b.n	801b0d8 <memset+0x4>

0801b0e4 <_close_r>:
 801b0e4:	b538      	push	{r3, r4, r5, lr}
 801b0e6:	4c06      	ldr	r4, [pc, #24]	@ (801b100 <_close_r+0x1c>)
 801b0e8:	2300      	movs	r3, #0
 801b0ea:	4605      	mov	r5, r0
 801b0ec:	4608      	mov	r0, r1
 801b0ee:	6023      	str	r3, [r4, #0]
 801b0f0:	f7fc fc6f 	bl	80179d2 <_close>
 801b0f4:	1c43      	adds	r3, r0, #1
 801b0f6:	d102      	bne.n	801b0fe <_close_r+0x1a>
 801b0f8:	6823      	ldr	r3, [r4, #0]
 801b0fa:	b103      	cbz	r3, 801b0fe <_close_r+0x1a>
 801b0fc:	602b      	str	r3, [r5, #0]
 801b0fe:	bd38      	pop	{r3, r4, r5, pc}
 801b100:	20001a98 	.word	0x20001a98

0801b104 <_lseek_r>:
 801b104:	b538      	push	{r3, r4, r5, lr}
 801b106:	4c07      	ldr	r4, [pc, #28]	@ (801b124 <_lseek_r+0x20>)
 801b108:	4605      	mov	r5, r0
 801b10a:	4608      	mov	r0, r1
 801b10c:	4611      	mov	r1, r2
 801b10e:	2200      	movs	r2, #0
 801b110:	6022      	str	r2, [r4, #0]
 801b112:	461a      	mov	r2, r3
 801b114:	f7fc fc67 	bl	80179e6 <_lseek>
 801b118:	1c43      	adds	r3, r0, #1
 801b11a:	d102      	bne.n	801b122 <_lseek_r+0x1e>
 801b11c:	6823      	ldr	r3, [r4, #0]
 801b11e:	b103      	cbz	r3, 801b122 <_lseek_r+0x1e>
 801b120:	602b      	str	r3, [r5, #0]
 801b122:	bd38      	pop	{r3, r4, r5, pc}
 801b124:	20001a98 	.word	0x20001a98

0801b128 <_read_r>:
 801b128:	b538      	push	{r3, r4, r5, lr}
 801b12a:	4c07      	ldr	r4, [pc, #28]	@ (801b148 <_read_r+0x20>)
 801b12c:	4605      	mov	r5, r0
 801b12e:	4608      	mov	r0, r1
 801b130:	4611      	mov	r1, r2
 801b132:	2200      	movs	r2, #0
 801b134:	6022      	str	r2, [r4, #0]
 801b136:	461a      	mov	r2, r3
 801b138:	f7fc fc2f 	bl	801799a <_read>
 801b13c:	1c43      	adds	r3, r0, #1
 801b13e:	d102      	bne.n	801b146 <_read_r+0x1e>
 801b140:	6823      	ldr	r3, [r4, #0]
 801b142:	b103      	cbz	r3, 801b146 <_read_r+0x1e>
 801b144:	602b      	str	r3, [r5, #0]
 801b146:	bd38      	pop	{r3, r4, r5, pc}
 801b148:	20001a98 	.word	0x20001a98

0801b14c <_sbrk_r>:
 801b14c:	b538      	push	{r3, r4, r5, lr}
 801b14e:	4c06      	ldr	r4, [pc, #24]	@ (801b168 <_sbrk_r+0x1c>)
 801b150:	2300      	movs	r3, #0
 801b152:	4605      	mov	r5, r0
 801b154:	4608      	mov	r0, r1
 801b156:	6023      	str	r3, [r4, #0]
 801b158:	f7fc fc48 	bl	80179ec <_sbrk>
 801b15c:	1c43      	adds	r3, r0, #1
 801b15e:	d102      	bne.n	801b166 <_sbrk_r+0x1a>
 801b160:	6823      	ldr	r3, [r4, #0]
 801b162:	b103      	cbz	r3, 801b166 <_sbrk_r+0x1a>
 801b164:	602b      	str	r3, [r5, #0]
 801b166:	bd38      	pop	{r3, r4, r5, pc}
 801b168:	20001a98 	.word	0x20001a98

0801b16c <_write_r>:
 801b16c:	b538      	push	{r3, r4, r5, lr}
 801b16e:	4c07      	ldr	r4, [pc, #28]	@ (801b18c <_write_r+0x20>)
 801b170:	4605      	mov	r5, r0
 801b172:	4608      	mov	r0, r1
 801b174:	4611      	mov	r1, r2
 801b176:	2200      	movs	r2, #0
 801b178:	6022      	str	r2, [r4, #0]
 801b17a:	461a      	mov	r2, r3
 801b17c:	f7fc fc1b 	bl	80179b6 <_write>
 801b180:	1c43      	adds	r3, r0, #1
 801b182:	d102      	bne.n	801b18a <_write_r+0x1e>
 801b184:	6823      	ldr	r3, [r4, #0]
 801b186:	b103      	cbz	r3, 801b18a <_write_r+0x1e>
 801b188:	602b      	str	r3, [r5, #0]
 801b18a:	bd38      	pop	{r3, r4, r5, pc}
 801b18c:	20001a98 	.word	0x20001a98

0801b190 <__errno>:
 801b190:	4b01      	ldr	r3, [pc, #4]	@ (801b198 <__errno+0x8>)
 801b192:	6818      	ldr	r0, [r3, #0]
 801b194:	4770      	bx	lr
 801b196:	bf00      	nop
 801b198:	20000018 	.word	0x20000018

0801b19c <__libc_init_array>:
 801b19c:	b570      	push	{r4, r5, r6, lr}
 801b19e:	4b0d      	ldr	r3, [pc, #52]	@ (801b1d4 <__libc_init_array+0x38>)
 801b1a0:	4c0d      	ldr	r4, [pc, #52]	@ (801b1d8 <__libc_init_array+0x3c>)
 801b1a2:	2600      	movs	r6, #0
 801b1a4:	1b1d      	subs	r5, r3, r4
 801b1a6:	ebb6 0fa5 	cmp.w	r6, r5, asr #2
 801b1aa:	d109      	bne.n	801b1c0 <__libc_init_array+0x24>
 801b1ac:	f000 fee8 	bl	801bf80 <_init>
 801b1b0:	4c0a      	ldr	r4, [pc, #40]	@ (801b1dc <__libc_init_array+0x40>)
 801b1b2:	4b0b      	ldr	r3, [pc, #44]	@ (801b1e0 <__libc_init_array+0x44>)
 801b1b4:	2600      	movs	r6, #0
 801b1b6:	1b1d      	subs	r5, r3, r4
 801b1b8:	ebb6 0fa5 	cmp.w	r6, r5, asr #2
 801b1bc:	d105      	bne.n	801b1ca <__libc_init_array+0x2e>
 801b1be:	bd70      	pop	{r4, r5, r6, pc}
 801b1c0:	f854 3b04 	ldr.w	r3, [r4], #4
 801b1c4:	4798      	blx	r3
 801b1c6:	3601      	adds	r6, #1
 801b1c8:	e7ed      	b.n	801b1a6 <__libc_init_array+0xa>
 801b1ca:	f854 3b04 	ldr.w	r3, [r4], #4
 801b1ce:	4798      	blx	r3
 801b1d0:	3601      	adds	r6, #1
 801b1d2:	e7f1      	b.n	801b1b8 <__libc_init_array+0x1c>
 801b1d4:	0801c7e0 	.word	0x0801c7e0
 801b1d8:	0801c7e0 	.word	0x0801c7e0
 801b1dc:	0801c7e0 	.word	0x0801c7e0
 801b1e0:	0801c7e4 	.word	0x0801c7e4

0801b1e4 <__retarget_lock_init_recursive>:
 801b1e4:	4770      	bx	lr

0801b1e6 <__retarget_lock_acquire_recursive>:
 801b1e6:	4770      	bx	lr

0801b1e8 <__retarget_lock_release_recursive>:
 801b1e8:	4770      	bx	lr

0801b1ea <memcpy>:
 801b1ea:	440a      	add	r2, r1
 801b1ec:	4291      	cmp	r1, r2
 801b1ee:	f100 33ff 	add.w	r3, r0, #4294967295
 801b1f2:	d100      	bne.n	801b1f6 <memcpy+0xc>
 801b1f4:	4770      	bx	lr
 801b1f6:	b510      	push	{r4, lr}
 801b1f8:	f811 4b01 	ldrb.w	r4, [r1], #1
 801b1fc:	f803 4f01 	strb.w	r4, [r3, #1]!
 801b200:	4291      	cmp	r1, r2
 801b202:	d1f9      	bne.n	801b1f8 <memcpy+0xe>
 801b204:	bd10      	pop	{r4, pc}

0801b206 <abort>:
 801b206:	b508      	push	{r3, lr}
 801b208:	2006      	movs	r0, #6
 801b20a:	f000 fc8d 	bl	801bb28 <raise>
 801b20e:	2001      	movs	r0, #1
 801b210:	f7fc fbbd 	bl	801798e <_exit>

0801b214 <_free_r>:
 801b214:	b537      	push	{r0, r1, r2, r4, r5, lr}
 801b216:	2900      	cmp	r1, #0
 801b218:	d044      	beq.n	801b2a4 <_free_r+0x90>
 801b21a:	f851 3c04 	ldr.w	r3, [r1, #-4]
 801b21e:	9001      	str	r0, [sp, #4]
 801b220:	2b00      	cmp	r3, #0
 801b222:	f1a1 0404 	sub.w	r4, r1, #4
 801b226:	bfb8      	it	lt
 801b228:	18e4      	addlt	r4, r4, r3
 801b22a:	f7ff fe15 	bl	801ae58 <__malloc_lock>
 801b22e:	4a1e      	ldr	r2, [pc, #120]	@ (801b2a8 <_free_r+0x94>)
 801b230:	9801      	ldr	r0, [sp, #4]
 801b232:	6813      	ldr	r3, [r2, #0]
 801b234:	b933      	cbnz	r3, 801b244 <_free_r+0x30>
 801b236:	6063      	str	r3, [r4, #4]
 801b238:	6014      	str	r4, [r2, #0]
 801b23a:	b003      	add	sp, #12
 801b23c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 801b240:	f7ff be10 	b.w	801ae64 <__malloc_unlock>
 801b244:	42a3      	cmp	r3, r4
 801b246:	d908      	bls.n	801b25a <_free_r+0x46>
 801b248:	6825      	ldr	r5, [r4, #0]
 801b24a:	1961      	adds	r1, r4, r5
 801b24c:	428b      	cmp	r3, r1
 801b24e:	bf01      	itttt	eq
 801b250:	6819      	ldreq	r1, [r3, #0]
 801b252:	685b      	ldreq	r3, [r3, #4]
 801b254:	1949      	addeq	r1, r1, r5
 801b256:	6021      	streq	r1, [r4, #0]
 801b258:	e7ed      	b.n	801b236 <_free_r+0x22>
 801b25a:	461a      	mov	r2, r3
 801b25c:	685b      	ldr	r3, [r3, #4]
 801b25e:	b10b      	cbz	r3, 801b264 <_free_r+0x50>
 801b260:	42a3      	cmp	r3, r4
 801b262:	d9fa      	bls.n	801b25a <_free_r+0x46>
 801b264:	6811      	ldr	r1, [r2, #0]
 801b266:	1855      	adds	r5, r2, r1
 801b268:	42a5      	cmp	r5, r4
 801b26a:	d10b      	bne.n	801b284 <_free_r+0x70>
 801b26c:	6824      	ldr	r4, [r4, #0]
 801b26e:	4421      	add	r1, r4
 801b270:	1854      	adds	r4, r2, r1
 801b272:	42a3      	cmp	r3, r4
 801b274:	6011      	str	r1, [r2, #0]
 801b276:	d1e0      	bne.n	801b23a <_free_r+0x26>
 801b278:	681c      	ldr	r4, [r3, #0]
 801b27a:	685b      	ldr	r3, [r3, #4]
 801b27c:	6053      	str	r3, [r2, #4]
 801b27e:	440c      	add	r4, r1
 801b280:	6014      	str	r4, [r2, #0]
 801b282:	e7da      	b.n	801b23a <_free_r+0x26>
 801b284:	d902      	bls.n	801b28c <_free_r+0x78>
 801b286:	230c      	movs	r3, #12
 801b288:	6003      	str	r3, [r0, #0]
 801b28a:	e7d6      	b.n	801b23a <_free_r+0x26>
 801b28c:	6825      	ldr	r5, [r4, #0]
 801b28e:	1961      	adds	r1, r4, r5
 801b290:	428b      	cmp	r3, r1
 801b292:	bf04      	itt	eq
 801b294:	6819      	ldreq	r1, [r3, #0]
 801b296:	685b      	ldreq	r3, [r3, #4]
 801b298:	6063      	str	r3, [r4, #4]
 801b29a:	bf04      	itt	eq
 801b29c:	1949      	addeq	r1, r1, r5
 801b29e:	6021      	streq	r1, [r4, #0]
 801b2a0:	6054      	str	r4, [r2, #4]
 801b2a2:	e7ca      	b.n	801b23a <_free_r+0x26>
 801b2a4:	b003      	add	sp, #12
 801b2a6:	bd30      	pop	{r4, r5, pc}
 801b2a8:	20001958 	.word	0x20001958

0801b2ac <__sfputc_r>:
 801b2ac:	6893      	ldr	r3, [r2, #8]
 801b2ae:	3b01      	subs	r3, #1
 801b2b0:	2b00      	cmp	r3, #0
 801b2b2:	b410      	push	{r4}
 801b2b4:	6093      	str	r3, [r2, #8]
 801b2b6:	da07      	bge.n	801b2c8 <__sfputc_r+0x1c>
 801b2b8:	6994      	ldr	r4, [r2, #24]
 801b2ba:	42a3      	cmp	r3, r4
 801b2bc:	db01      	blt.n	801b2c2 <__sfputc_r+0x16>
 801b2be:	290a      	cmp	r1, #10
 801b2c0:	d102      	bne.n	801b2c8 <__sfputc_r+0x1c>
 801b2c2:	bc10      	pop	{r4}
 801b2c4:	f000 bb76 	b.w	801b9b4 <__swbuf_r>
 801b2c8:	6813      	ldr	r3, [r2, #0]
 801b2ca:	1c58      	adds	r0, r3, #1
 801b2cc:	6010      	str	r0, [r2, #0]
 801b2ce:	7019      	strb	r1, [r3, #0]
 801b2d0:	4608      	mov	r0, r1
 801b2d2:	bc10      	pop	{r4}
 801b2d4:	4770      	bx	lr

0801b2d6 <__sfputs_r>:
 801b2d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b2d8:	4606      	mov	r6, r0
 801b2da:	460f      	mov	r7, r1
 801b2dc:	4614      	mov	r4, r2
 801b2de:	18d5      	adds	r5, r2, r3
 801b2e0:	42ac      	cmp	r4, r5
 801b2e2:	d101      	bne.n	801b2e8 <__sfputs_r+0x12>
 801b2e4:	2000      	movs	r0, #0
 801b2e6:	e007      	b.n	801b2f8 <__sfputs_r+0x22>
 801b2e8:	f814 1b01 	ldrb.w	r1, [r4], #1
 801b2ec:	463a      	mov	r2, r7
 801b2ee:	4630      	mov	r0, r6
 801b2f0:	f7ff ffdc 	bl	801b2ac <__sfputc_r>
 801b2f4:	1c43      	adds	r3, r0, #1
 801b2f6:	d1f3      	bne.n	801b2e0 <__sfputs_r+0xa>
 801b2f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0801b2fc <_vfiprintf_r>:
 801b2fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801b300:	4606      	mov	r6, r0
 801b302:	b09c      	sub	sp, #112	@ 0x70
 801b304:	460d      	mov	r5, r1
 801b306:	4614      	mov	r4, r2
 801b308:	461f      	mov	r7, r3
 801b30a:	b118      	cbz	r0, 801b314 <_vfiprintf_r+0x18>
 801b30c:	6a03      	ldr	r3, [r0, #32]
 801b30e:	b90b      	cbnz	r3, 801b314 <_vfiprintf_r+0x18>
 801b310:	f7ff fe3c 	bl	801af8c <__sinit>
 801b314:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801b316:	07d9      	lsls	r1, r3, #31
 801b318:	d405      	bmi.n	801b326 <_vfiprintf_r+0x2a>
 801b31a:	89ab      	ldrh	r3, [r5, #12]
 801b31c:	059a      	lsls	r2, r3, #22
 801b31e:	d402      	bmi.n	801b326 <_vfiprintf_r+0x2a>
 801b320:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 801b322:	f7ff ff60 	bl	801b1e6 <__retarget_lock_acquire_recursive>
 801b326:	89ab      	ldrh	r3, [r5, #12]
 801b328:	071b      	lsls	r3, r3, #28
 801b32a:	d501      	bpl.n	801b330 <_vfiprintf_r+0x34>
 801b32c:	692b      	ldr	r3, [r5, #16]
 801b32e:	b99b      	cbnz	r3, 801b358 <_vfiprintf_r+0x5c>
 801b330:	4629      	mov	r1, r5
 801b332:	4630      	mov	r0, r6
 801b334:	f000 fb7c 	bl	801ba30 <__swsetup_r>
 801b338:	b170      	cbz	r0, 801b358 <_vfiprintf_r+0x5c>
 801b33a:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801b33c:	07de      	lsls	r6, r3, #31
 801b33e:	d504      	bpl.n	801b34a <_vfiprintf_r+0x4e>
 801b340:	f04f 30ff 	mov.w	r0, #4294967295
 801b344:	b01c      	add	sp, #112	@ 0x70
 801b346:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801b34a:	89ab      	ldrh	r3, [r5, #12]
 801b34c:	059c      	lsls	r4, r3, #22
 801b34e:	d4f7      	bmi.n	801b340 <_vfiprintf_r+0x44>
 801b350:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 801b352:	f7ff ff49 	bl	801b1e8 <__retarget_lock_release_recursive>
 801b356:	e7f3      	b.n	801b340 <_vfiprintf_r+0x44>
 801b358:	2300      	movs	r3, #0
 801b35a:	9309      	str	r3, [sp, #36]	@ 0x24
 801b35c:	2320      	movs	r3, #32
 801b35e:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 801b362:	9703      	str	r7, [sp, #12]
 801b364:	2330      	movs	r3, #48	@ 0x30
 801b366:	4f6a      	ldr	r7, [pc, #424]	@ (801b510 <_vfiprintf_r+0x214>)
 801b368:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 801b36c:	f04f 0801 	mov.w	r8, #1
 801b370:	4623      	mov	r3, r4
 801b372:	781a      	ldrb	r2, [r3, #0]
 801b374:	4699      	mov	r9, r3
 801b376:	b11a      	cbz	r2, 801b380 <_vfiprintf_r+0x84>
 801b378:	2a25      	cmp	r2, #37	@ 0x25
 801b37a:	f103 0301 	add.w	r3, r3, #1
 801b37e:	d1f8      	bne.n	801b372 <_vfiprintf_r+0x76>
 801b380:	ebb9 0a04 	subs.w	sl, r9, r4
 801b384:	d00b      	beq.n	801b39e <_vfiprintf_r+0xa2>
 801b386:	4653      	mov	r3, sl
 801b388:	4622      	mov	r2, r4
 801b38a:	4629      	mov	r1, r5
 801b38c:	4630      	mov	r0, r6
 801b38e:	f7ff ffa2 	bl	801b2d6 <__sfputs_r>
 801b392:	3001      	adds	r0, #1
 801b394:	f000 80a3 	beq.w	801b4de <_vfiprintf_r+0x1e2>
 801b398:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 801b39a:	4452      	add	r2, sl
 801b39c:	9209      	str	r2, [sp, #36]	@ 0x24
 801b39e:	f899 3000 	ldrb.w	r3, [r9]
 801b3a2:	2b00      	cmp	r3, #0
 801b3a4:	f000 809b 	beq.w	801b4de <_vfiprintf_r+0x1e2>
 801b3a8:	2200      	movs	r2, #0
 801b3aa:	f04f 33ff 	mov.w	r3, #4294967295
 801b3ae:	e9cd 3205 	strd	r3, r2, [sp, #20]
 801b3b2:	f109 0901 	add.w	r9, r9, #1
 801b3b6:	9204      	str	r2, [sp, #16]
 801b3b8:	9207      	str	r2, [sp, #28]
 801b3ba:	f88d 2053 	strb.w	r2, [sp, #83]	@ 0x53
 801b3be:	921a      	str	r2, [sp, #104]	@ 0x68
 801b3c0:	464c      	mov	r4, r9
 801b3c2:	2205      	movs	r2, #5
 801b3c4:	f814 1b01 	ldrb.w	r1, [r4], #1
 801b3c8:	4851      	ldr	r0, [pc, #324]	@ (801b510 <_vfiprintf_r+0x214>)
 801b3ca:	f7fb fe29 	bl	8017020 <memchr>
 801b3ce:	9a04      	ldr	r2, [sp, #16]
 801b3d0:	b9d0      	cbnz	r0, 801b408 <_vfiprintf_r+0x10c>
 801b3d2:	06d0      	lsls	r0, r2, #27
 801b3d4:	bf44      	itt	mi
 801b3d6:	2320      	movmi	r3, #32
 801b3d8:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 801b3dc:	0711      	lsls	r1, r2, #28
 801b3de:	bf44      	itt	mi
 801b3e0:	232b      	movmi	r3, #43	@ 0x2b
 801b3e2:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 801b3e6:	f899 3000 	ldrb.w	r3, [r9]
 801b3ea:	2b2a      	cmp	r3, #42	@ 0x2a
 801b3ec:	d013      	beq.n	801b416 <_vfiprintf_r+0x11a>
 801b3ee:	9907      	ldr	r1, [sp, #28]
 801b3f0:	464b      	mov	r3, r9
 801b3f2:	2000      	movs	r0, #0
 801b3f4:	f04f 0c0a 	mov.w	ip, #10
 801b3f8:	781a      	ldrb	r2, [r3, #0]
 801b3fa:	3a30      	subs	r2, #48	@ 0x30
 801b3fc:	2a09      	cmp	r2, #9
 801b3fe:	461c      	mov	r4, r3
 801b400:	d94a      	bls.n	801b498 <_vfiprintf_r+0x19c>
 801b402:	b1a8      	cbz	r0, 801b430 <_vfiprintf_r+0x134>
 801b404:	9107      	str	r1, [sp, #28]
 801b406:	e013      	b.n	801b430 <_vfiprintf_r+0x134>
 801b408:	1bc0      	subs	r0, r0, r7
 801b40a:	fa08 f000 	lsl.w	r0, r8, r0
 801b40e:	4310      	orrs	r0, r2
 801b410:	9004      	str	r0, [sp, #16]
 801b412:	46a1      	mov	r9, r4
 801b414:	e7d4      	b.n	801b3c0 <_vfiprintf_r+0xc4>
 801b416:	9b03      	ldr	r3, [sp, #12]
 801b418:	1d19      	adds	r1, r3, #4
 801b41a:	681b      	ldr	r3, [r3, #0]
 801b41c:	9103      	str	r1, [sp, #12]
 801b41e:	2b00      	cmp	r3, #0
 801b420:	bfbb      	ittet	lt
 801b422:	425b      	neglt	r3, r3
 801b424:	f042 0202 	orrlt.w	r2, r2, #2
 801b428:	9307      	strge	r3, [sp, #28]
 801b42a:	9307      	strlt	r3, [sp, #28]
 801b42c:	bfb8      	it	lt
 801b42e:	9204      	strlt	r2, [sp, #16]
 801b430:	7823      	ldrb	r3, [r4, #0]
 801b432:	2b2e      	cmp	r3, #46	@ 0x2e
 801b434:	d10a      	bne.n	801b44c <_vfiprintf_r+0x150>
 801b436:	7863      	ldrb	r3, [r4, #1]
 801b438:	2b2a      	cmp	r3, #42	@ 0x2a
 801b43a:	d132      	bne.n	801b4a2 <_vfiprintf_r+0x1a6>
 801b43c:	9b03      	ldr	r3, [sp, #12]
 801b43e:	1d1a      	adds	r2, r3, #4
 801b440:	681b      	ldr	r3, [r3, #0]
 801b442:	9203      	str	r2, [sp, #12]
 801b444:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 801b448:	3402      	adds	r4, #2
 801b44a:	9305      	str	r3, [sp, #20]
 801b44c:	f8df 90d0 	ldr.w	r9, [pc, #208]	@ 801b520 <_vfiprintf_r+0x224>
 801b450:	7821      	ldrb	r1, [r4, #0]
 801b452:	2203      	movs	r2, #3
 801b454:	4648      	mov	r0, r9
 801b456:	f7fb fde3 	bl	8017020 <memchr>
 801b45a:	b138      	cbz	r0, 801b46c <_vfiprintf_r+0x170>
 801b45c:	9b04      	ldr	r3, [sp, #16]
 801b45e:	eba0 0009 	sub.w	r0, r0, r9
 801b462:	2240      	movs	r2, #64	@ 0x40
 801b464:	4082      	lsls	r2, r0
 801b466:	4313      	orrs	r3, r2
 801b468:	3401      	adds	r4, #1
 801b46a:	9304      	str	r3, [sp, #16]
 801b46c:	7821      	ldrb	r1, [r4, #0]
 801b46e:	4829      	ldr	r0, [pc, #164]	@ (801b514 <_vfiprintf_r+0x218>)
 801b470:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 801b474:	2206      	movs	r2, #6
 801b476:	f7fb fdd3 	bl	8017020 <memchr>
 801b47a:	2800      	cmp	r0, #0
 801b47c:	d03e      	beq.n	801b4fc <_vfiprintf_r+0x200>
 801b47e:	4826      	ldr	r0, [pc, #152]	@ (801b518 <_vfiprintf_r+0x21c>)
 801b480:	bb18      	cbnz	r0, 801b4ca <_vfiprintf_r+0x1ce>
 801b482:	9b03      	ldr	r3, [sp, #12]
 801b484:	3307      	adds	r3, #7
 801b486:	f023 0307 	bic.w	r3, r3, #7
 801b48a:	3308      	adds	r3, #8
 801b48c:	9303      	str	r3, [sp, #12]
 801b48e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801b490:	4403      	add	r3, r0
 801b492:	3401      	adds	r4, #1
 801b494:	9309      	str	r3, [sp, #36]	@ 0x24
 801b496:	e76b      	b.n	801b370 <_vfiprintf_r+0x74>
 801b498:	3301      	adds	r3, #1
 801b49a:	fb0c 2101 	mla	r1, ip, r1, r2
 801b49e:	2001      	movs	r0, #1
 801b4a0:	e7aa      	b.n	801b3f8 <_vfiprintf_r+0xfc>
 801b4a2:	2300      	movs	r3, #0
 801b4a4:	9305      	str	r3, [sp, #20]
 801b4a6:	1c61      	adds	r1, r4, #1
 801b4a8:	4618      	mov	r0, r3
 801b4aa:	f04f 0c0a 	mov.w	ip, #10
 801b4ae:	780a      	ldrb	r2, [r1, #0]
 801b4b0:	3a30      	subs	r2, #48	@ 0x30
 801b4b2:	2a09      	cmp	r2, #9
 801b4b4:	460c      	mov	r4, r1
 801b4b6:	d903      	bls.n	801b4c0 <_vfiprintf_r+0x1c4>
 801b4b8:	2b00      	cmp	r3, #0
 801b4ba:	d0c7      	beq.n	801b44c <_vfiprintf_r+0x150>
 801b4bc:	9005      	str	r0, [sp, #20]
 801b4be:	e7c5      	b.n	801b44c <_vfiprintf_r+0x150>
 801b4c0:	3101      	adds	r1, #1
 801b4c2:	fb0c 2000 	mla	r0, ip, r0, r2
 801b4c6:	2301      	movs	r3, #1
 801b4c8:	e7f1      	b.n	801b4ae <_vfiprintf_r+0x1b2>
 801b4ca:	ab03      	add	r3, sp, #12
 801b4cc:	9300      	str	r3, [sp, #0]
 801b4ce:	462a      	mov	r2, r5
 801b4d0:	4b12      	ldr	r3, [pc, #72]	@ (801b51c <_vfiprintf_r+0x220>)
 801b4d2:	a904      	add	r1, sp, #16
 801b4d4:	4630      	mov	r0, r6
 801b4d6:	f3af 8000 	nop.w
 801b4da:	1c43      	adds	r3, r0, #1
 801b4dc:	d1d7      	bne.n	801b48e <_vfiprintf_r+0x192>
 801b4de:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 801b4e0:	07d9      	lsls	r1, r3, #31
 801b4e2:	d405      	bmi.n	801b4f0 <_vfiprintf_r+0x1f4>
 801b4e4:	89ab      	ldrh	r3, [r5, #12]
 801b4e6:	059a      	lsls	r2, r3, #22
 801b4e8:	d402      	bmi.n	801b4f0 <_vfiprintf_r+0x1f4>
 801b4ea:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 801b4ec:	f7ff fe7c 	bl	801b1e8 <__retarget_lock_release_recursive>
 801b4f0:	89ab      	ldrh	r3, [r5, #12]
 801b4f2:	065b      	lsls	r3, r3, #25
 801b4f4:	f53f af24 	bmi.w	801b340 <_vfiprintf_r+0x44>
 801b4f8:	9809      	ldr	r0, [sp, #36]	@ 0x24
 801b4fa:	e723      	b.n	801b344 <_vfiprintf_r+0x48>
 801b4fc:	ab03      	add	r3, sp, #12
 801b4fe:	9300      	str	r3, [sp, #0]
 801b500:	462a      	mov	r2, r5
 801b502:	4b06      	ldr	r3, [pc, #24]	@ (801b51c <_vfiprintf_r+0x220>)
 801b504:	a904      	add	r1, sp, #16
 801b506:	4630      	mov	r0, r6
 801b508:	f000 f882 	bl	801b610 <_printf_i>
 801b50c:	e7e5      	b.n	801b4da <_vfiprintf_r+0x1de>
 801b50e:	bf00      	nop
 801b510:	0801c395 	.word	0x0801c395
 801b514:	0801c39f 	.word	0x0801c39f
 801b518:	00000000 	.word	0x00000000
 801b51c:	0801b2d7 	.word	0x0801b2d7
 801b520:	0801c39b 	.word	0x0801c39b

0801b524 <_printf_common>:
 801b524:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801b528:	4691      	mov	r9, r2
 801b52a:	4698      	mov	r8, r3
 801b52c:	688a      	ldr	r2, [r1, #8]
 801b52e:	690b      	ldr	r3, [r1, #16]
 801b530:	9e08      	ldr	r6, [sp, #32]
 801b532:	4293      	cmp	r3, r2
 801b534:	bfb8      	it	lt
 801b536:	4613      	movlt	r3, r2
 801b538:	f8c9 3000 	str.w	r3, [r9]
 801b53c:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 801b540:	4607      	mov	r7, r0
 801b542:	460c      	mov	r4, r1
 801b544:	b112      	cbz	r2, 801b54c <_printf_common+0x28>
 801b546:	3301      	adds	r3, #1
 801b548:	f8c9 3000 	str.w	r3, [r9]
 801b54c:	6823      	ldr	r3, [r4, #0]
 801b54e:	0699      	lsls	r1, r3, #26
 801b550:	bf42      	ittt	mi
 801b552:	f8d9 3000 	ldrmi.w	r3, [r9]
 801b556:	3302      	addmi	r3, #2
 801b558:	f8c9 3000 	strmi.w	r3, [r9]
 801b55c:	6825      	ldr	r5, [r4, #0]
 801b55e:	f015 0506 	ands.w	r5, r5, #6
 801b562:	d107      	bne.n	801b574 <_printf_common+0x50>
 801b564:	f104 0a19 	add.w	sl, r4, #25
 801b568:	68e3      	ldr	r3, [r4, #12]
 801b56a:	f8d9 2000 	ldr.w	r2, [r9]
 801b56e:	1a9b      	subs	r3, r3, r2
 801b570:	42ab      	cmp	r3, r5
 801b572:	dc29      	bgt.n	801b5c8 <_printf_common+0xa4>
 801b574:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 801b578:	6822      	ldr	r2, [r4, #0]
 801b57a:	3b00      	subs	r3, #0
 801b57c:	bf18      	it	ne
 801b57e:	2301      	movne	r3, #1
 801b580:	0692      	lsls	r2, r2, #26
 801b582:	d42e      	bmi.n	801b5e2 <_printf_common+0xbe>
 801b584:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 801b588:	4641      	mov	r1, r8
 801b58a:	4638      	mov	r0, r7
 801b58c:	47b0      	blx	r6
 801b58e:	3001      	adds	r0, #1
 801b590:	d021      	beq.n	801b5d6 <_printf_common+0xb2>
 801b592:	6823      	ldr	r3, [r4, #0]
 801b594:	68a1      	ldr	r1, [r4, #8]
 801b596:	6922      	ldr	r2, [r4, #16]
 801b598:	f003 0306 	and.w	r3, r3, #6
 801b59c:	2b04      	cmp	r3, #4
 801b59e:	bf01      	itttt	eq
 801b5a0:	68e5      	ldreq	r5, [r4, #12]
 801b5a2:	f8d9 3000 	ldreq.w	r3, [r9]
 801b5a6:	1aed      	subeq	r5, r5, r3
 801b5a8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 801b5ac:	bf18      	it	ne
 801b5ae:	2500      	movne	r5, #0
 801b5b0:	1a8b      	subs	r3, r1, r2
 801b5b2:	442b      	add	r3, r5
 801b5b4:	4291      	cmp	r1, r2
 801b5b6:	bfc8      	it	gt
 801b5b8:	461d      	movgt	r5, r3
 801b5ba:	f04f 0900 	mov.w	r9, #0
 801b5be:	341a      	adds	r4, #26
 801b5c0:	454d      	cmp	r5, r9
 801b5c2:	d11a      	bne.n	801b5fa <_printf_common+0xd6>
 801b5c4:	2000      	movs	r0, #0
 801b5c6:	e008      	b.n	801b5da <_printf_common+0xb6>
 801b5c8:	2301      	movs	r3, #1
 801b5ca:	4652      	mov	r2, sl
 801b5cc:	4641      	mov	r1, r8
 801b5ce:	4638      	mov	r0, r7
 801b5d0:	47b0      	blx	r6
 801b5d2:	3001      	adds	r0, #1
 801b5d4:	d103      	bne.n	801b5de <_printf_common+0xba>
 801b5d6:	f04f 30ff 	mov.w	r0, #4294967295
 801b5da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801b5de:	3501      	adds	r5, #1
 801b5e0:	e7c2      	b.n	801b568 <_printf_common+0x44>
 801b5e2:	18e1      	adds	r1, r4, r3
 801b5e4:	1c5a      	adds	r2, r3, #1
 801b5e6:	2030      	movs	r0, #48	@ 0x30
 801b5e8:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 801b5ec:	4422      	add	r2, r4
 801b5ee:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 801b5f2:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 801b5f6:	3302      	adds	r3, #2
 801b5f8:	e7c4      	b.n	801b584 <_printf_common+0x60>
 801b5fa:	2301      	movs	r3, #1
 801b5fc:	4622      	mov	r2, r4
 801b5fe:	4641      	mov	r1, r8
 801b600:	4638      	mov	r0, r7
 801b602:	47b0      	blx	r6
 801b604:	3001      	adds	r0, #1
 801b606:	d0e6      	beq.n	801b5d6 <_printf_common+0xb2>
 801b608:	f109 0901 	add.w	r9, r9, #1
 801b60c:	e7d8      	b.n	801b5c0 <_printf_common+0x9c>
	...

0801b610 <_printf_i>:
 801b610:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 801b614:	4698      	mov	r8, r3
 801b616:	7e0b      	ldrb	r3, [r1, #24]
 801b618:	b085      	sub	sp, #20
 801b61a:	2b78      	cmp	r3, #120	@ 0x78
 801b61c:	4617      	mov	r7, r2
 801b61e:	4606      	mov	r6, r0
 801b620:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 801b622:	460c      	mov	r4, r1
 801b624:	d809      	bhi.n	801b63a <_printf_i+0x2a>
 801b626:	2b62      	cmp	r3, #98	@ 0x62
 801b628:	f101 0143 	add.w	r1, r1, #67	@ 0x43
 801b62c:	d808      	bhi.n	801b640 <_printf_i+0x30>
 801b62e:	2b00      	cmp	r3, #0
 801b630:	f000 80dc 	beq.w	801b7ec <_printf_i+0x1dc>
 801b634:	2b58      	cmp	r3, #88	@ 0x58
 801b636:	f000 80bd 	beq.w	801b7b4 <_printf_i+0x1a4>
 801b63a:	f104 0542 	add.w	r5, r4, #66	@ 0x42
 801b63e:	e039      	b.n	801b6b4 <_printf_i+0xa4>
 801b640:	f1a3 0063 	sub.w	r0, r3, #99	@ 0x63
 801b644:	2815      	cmp	r0, #21
 801b646:	d8f8      	bhi.n	801b63a <_printf_i+0x2a>
 801b648:	a501      	add	r5, pc, #4	@ (adr r5, 801b650 <_printf_i+0x40>)
 801b64a:	f855 f020 	ldr.w	pc, [r5, r0, lsl #2]
 801b64e:	bf00      	nop
 801b650:	0801b6a9 	.word	0x0801b6a9
 801b654:	0801b6bd 	.word	0x0801b6bd
 801b658:	0801b63b 	.word	0x0801b63b
 801b65c:	0801b63b 	.word	0x0801b63b
 801b660:	0801b63b 	.word	0x0801b63b
 801b664:	0801b63b 	.word	0x0801b63b
 801b668:	0801b6bd 	.word	0x0801b6bd
 801b66c:	0801b63b 	.word	0x0801b63b
 801b670:	0801b63b 	.word	0x0801b63b
 801b674:	0801b63b 	.word	0x0801b63b
 801b678:	0801b63b 	.word	0x0801b63b
 801b67c:	0801b7cd 	.word	0x0801b7cd
 801b680:	0801b6e9 	.word	0x0801b6e9
 801b684:	0801b77b 	.word	0x0801b77b
 801b688:	0801b63b 	.word	0x0801b63b
 801b68c:	0801b63b 	.word	0x0801b63b
 801b690:	0801b7f5 	.word	0x0801b7f5
 801b694:	0801b63b 	.word	0x0801b63b
 801b698:	0801b6e9 	.word	0x0801b6e9
 801b69c:	0801b63b 	.word	0x0801b63b
 801b6a0:	0801b63b 	.word	0x0801b63b
 801b6a4:	0801b783 	.word	0x0801b783
 801b6a8:	6813      	ldr	r3, [r2, #0]
 801b6aa:	1d19      	adds	r1, r3, #4
 801b6ac:	681b      	ldr	r3, [r3, #0]
 801b6ae:	6011      	str	r1, [r2, #0]
 801b6b0:	f104 0542 	add.w	r5, r4, #66	@ 0x42
 801b6b4:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 801b6b8:	2301      	movs	r3, #1
 801b6ba:	e0a8      	b.n	801b80e <_printf_i+0x1fe>
 801b6bc:	6813      	ldr	r3, [r2, #0]
 801b6be:	6825      	ldr	r5, [r4, #0]
 801b6c0:	1d18      	adds	r0, r3, #4
 801b6c2:	6010      	str	r0, [r2, #0]
 801b6c4:	0628      	lsls	r0, r5, #24
 801b6c6:	d501      	bpl.n	801b6cc <_printf_i+0xbc>
 801b6c8:	681b      	ldr	r3, [r3, #0]
 801b6ca:	e003      	b.n	801b6d4 <_printf_i+0xc4>
 801b6cc:	066a      	lsls	r2, r5, #25
 801b6ce:	d5fb      	bpl.n	801b6c8 <_printf_i+0xb8>
 801b6d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b6d4:	2b00      	cmp	r3, #0
 801b6d6:	da03      	bge.n	801b6e0 <_printf_i+0xd0>
 801b6d8:	222d      	movs	r2, #45	@ 0x2d
 801b6da:	425b      	negs	r3, r3
 801b6dc:	f884 2043 	strb.w	r2, [r4, #67]	@ 0x43
 801b6e0:	f8df c178 	ldr.w	ip, [pc, #376]	@ 801b85c <_printf_i+0x24c>
 801b6e4:	220a      	movs	r2, #10
 801b6e6:	e013      	b.n	801b710 <_printf_i+0x100>
 801b6e8:	6825      	ldr	r5, [r4, #0]
 801b6ea:	6810      	ldr	r0, [r2, #0]
 801b6ec:	f015 0f80 	tst.w	r5, #128	@ 0x80
 801b6f0:	f850 3b04 	ldr.w	r3, [r0], #4
 801b6f4:	d102      	bne.n	801b6fc <_printf_i+0xec>
 801b6f6:	066d      	lsls	r5, r5, #25
 801b6f8:	bf48      	it	mi
 801b6fa:	b29b      	uxthmi	r3, r3
 801b6fc:	6010      	str	r0, [r2, #0]
 801b6fe:	7e22      	ldrb	r2, [r4, #24]
 801b700:	f8df c158 	ldr.w	ip, [pc, #344]	@ 801b85c <_printf_i+0x24c>
 801b704:	2a6f      	cmp	r2, #111	@ 0x6f
 801b706:	d15d      	bne.n	801b7c4 <_printf_i+0x1b4>
 801b708:	2208      	movs	r2, #8
 801b70a:	2000      	movs	r0, #0
 801b70c:	f884 0043 	strb.w	r0, [r4, #67]	@ 0x43
 801b710:	6865      	ldr	r5, [r4, #4]
 801b712:	60a5      	str	r5, [r4, #8]
 801b714:	2d00      	cmp	r5, #0
 801b716:	db05      	blt.n	801b724 <_printf_i+0x114>
 801b718:	6820      	ldr	r0, [r4, #0]
 801b71a:	431d      	orrs	r5, r3
 801b71c:	f020 0004 	bic.w	r0, r0, #4
 801b720:	6020      	str	r0, [r4, #0]
 801b722:	d051      	beq.n	801b7c8 <_printf_i+0x1b8>
 801b724:	460d      	mov	r5, r1
 801b726:	fbb3 f0f2 	udiv	r0, r3, r2
 801b72a:	fb02 3e10 	mls	lr, r2, r0, r3
 801b72e:	429a      	cmp	r2, r3
 801b730:	f81c e00e 	ldrb.w	lr, [ip, lr]
 801b734:	f805 ed01 	strb.w	lr, [r5, #-1]!
 801b738:	4603      	mov	r3, r0
 801b73a:	d9f4      	bls.n	801b726 <_printf_i+0x116>
 801b73c:	2a08      	cmp	r2, #8
 801b73e:	d10b      	bne.n	801b758 <_printf_i+0x148>
 801b740:	6823      	ldr	r3, [r4, #0]
 801b742:	07da      	lsls	r2, r3, #31
 801b744:	d508      	bpl.n	801b758 <_printf_i+0x148>
 801b746:	6923      	ldr	r3, [r4, #16]
 801b748:	6862      	ldr	r2, [r4, #4]
 801b74a:	429a      	cmp	r2, r3
 801b74c:	bfde      	ittt	le
 801b74e:	2330      	movle	r3, #48	@ 0x30
 801b750:	f805 3c01 	strble.w	r3, [r5, #-1]
 801b754:	f105 35ff 	addle.w	r5, r5, #4294967295
 801b758:	1b49      	subs	r1, r1, r5
 801b75a:	6121      	str	r1, [r4, #16]
 801b75c:	f8cd 8000 	str.w	r8, [sp]
 801b760:	463b      	mov	r3, r7
 801b762:	aa03      	add	r2, sp, #12
 801b764:	4621      	mov	r1, r4
 801b766:	4630      	mov	r0, r6
 801b768:	f7ff fedc 	bl	801b524 <_printf_common>
 801b76c:	3001      	adds	r0, #1
 801b76e:	d153      	bne.n	801b818 <_printf_i+0x208>
 801b770:	f04f 30ff 	mov.w	r0, #4294967295
 801b774:	b005      	add	sp, #20
 801b776:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801b77a:	6823      	ldr	r3, [r4, #0]
 801b77c:	f043 0320 	orr.w	r3, r3, #32
 801b780:	6023      	str	r3, [r4, #0]
 801b782:	f8df c0dc 	ldr.w	ip, [pc, #220]	@ 801b860 <_printf_i+0x250>
 801b786:	2378      	movs	r3, #120	@ 0x78
 801b788:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 801b78c:	6820      	ldr	r0, [r4, #0]
 801b78e:	6815      	ldr	r5, [r2, #0]
 801b790:	f010 0f80 	tst.w	r0, #128	@ 0x80
 801b794:	f855 3b04 	ldr.w	r3, [r5], #4
 801b798:	d103      	bne.n	801b7a2 <_printf_i+0x192>
 801b79a:	f010 0f40 	tst.w	r0, #64	@ 0x40
 801b79e:	bf18      	it	ne
 801b7a0:	b29b      	uxthne	r3, r3
 801b7a2:	6015      	str	r5, [r2, #0]
 801b7a4:	07c5      	lsls	r5, r0, #31
 801b7a6:	bf44      	itt	mi
 801b7a8:	f040 0020 	orrmi.w	r0, r0, #32
 801b7ac:	6020      	strmi	r0, [r4, #0]
 801b7ae:	b123      	cbz	r3, 801b7ba <_printf_i+0x1aa>
 801b7b0:	2210      	movs	r2, #16
 801b7b2:	e7aa      	b.n	801b70a <_printf_i+0xfa>
 801b7b4:	f8df c0a4 	ldr.w	ip, [pc, #164]	@ 801b85c <_printf_i+0x24c>
 801b7b8:	e7e6      	b.n	801b788 <_printf_i+0x178>
 801b7ba:	6822      	ldr	r2, [r4, #0]
 801b7bc:	f022 0220 	bic.w	r2, r2, #32
 801b7c0:	6022      	str	r2, [r4, #0]
 801b7c2:	e7f5      	b.n	801b7b0 <_printf_i+0x1a0>
 801b7c4:	220a      	movs	r2, #10
 801b7c6:	e7a0      	b.n	801b70a <_printf_i+0xfa>
 801b7c8:	460d      	mov	r5, r1
 801b7ca:	e7b7      	b.n	801b73c <_printf_i+0x12c>
 801b7cc:	6813      	ldr	r3, [r2, #0]
 801b7ce:	f8d4 c000 	ldr.w	ip, [r4]
 801b7d2:	6960      	ldr	r0, [r4, #20]
 801b7d4:	1d1d      	adds	r5, r3, #4
 801b7d6:	6015      	str	r5, [r2, #0]
 801b7d8:	f01c 0f80 	tst.w	ip, #128	@ 0x80
 801b7dc:	681b      	ldr	r3, [r3, #0]
 801b7de:	d001      	beq.n	801b7e4 <_printf_i+0x1d4>
 801b7e0:	6018      	str	r0, [r3, #0]
 801b7e2:	e003      	b.n	801b7ec <_printf_i+0x1dc>
 801b7e4:	f01c 0f40 	tst.w	ip, #64	@ 0x40
 801b7e8:	d0fa      	beq.n	801b7e0 <_printf_i+0x1d0>
 801b7ea:	8018      	strh	r0, [r3, #0]
 801b7ec:	2300      	movs	r3, #0
 801b7ee:	6123      	str	r3, [r4, #16]
 801b7f0:	460d      	mov	r5, r1
 801b7f2:	e7b3      	b.n	801b75c <_printf_i+0x14c>
 801b7f4:	6813      	ldr	r3, [r2, #0]
 801b7f6:	1d19      	adds	r1, r3, #4
 801b7f8:	6011      	str	r1, [r2, #0]
 801b7fa:	681d      	ldr	r5, [r3, #0]
 801b7fc:	6862      	ldr	r2, [r4, #4]
 801b7fe:	2100      	movs	r1, #0
 801b800:	4628      	mov	r0, r5
 801b802:	f7fb fc0d 	bl	8017020 <memchr>
 801b806:	b108      	cbz	r0, 801b80c <_printf_i+0x1fc>
 801b808:	1b40      	subs	r0, r0, r5
 801b80a:	6060      	str	r0, [r4, #4]
 801b80c:	6863      	ldr	r3, [r4, #4]
 801b80e:	6123      	str	r3, [r4, #16]
 801b810:	2300      	movs	r3, #0
 801b812:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 801b816:	e7a1      	b.n	801b75c <_printf_i+0x14c>
 801b818:	6923      	ldr	r3, [r4, #16]
 801b81a:	462a      	mov	r2, r5
 801b81c:	4639      	mov	r1, r7
 801b81e:	4630      	mov	r0, r6
 801b820:	47c0      	blx	r8
 801b822:	3001      	adds	r0, #1
 801b824:	d0a4      	beq.n	801b770 <_printf_i+0x160>
 801b826:	6823      	ldr	r3, [r4, #0]
 801b828:	079b      	lsls	r3, r3, #30
 801b82a:	d414      	bmi.n	801b856 <_printf_i+0x246>
 801b82c:	68e0      	ldr	r0, [r4, #12]
 801b82e:	9b03      	ldr	r3, [sp, #12]
 801b830:	4298      	cmp	r0, r3
 801b832:	bfb8      	it	lt
 801b834:	4618      	movlt	r0, r3
 801b836:	e79d      	b.n	801b774 <_printf_i+0x164>
 801b838:	2301      	movs	r3, #1
 801b83a:	f104 0219 	add.w	r2, r4, #25
 801b83e:	4639      	mov	r1, r7
 801b840:	4630      	mov	r0, r6
 801b842:	47c0      	blx	r8
 801b844:	3001      	adds	r0, #1
 801b846:	d093      	beq.n	801b770 <_printf_i+0x160>
 801b848:	3501      	adds	r5, #1
 801b84a:	68e3      	ldr	r3, [r4, #12]
 801b84c:	9903      	ldr	r1, [sp, #12]
 801b84e:	1a5b      	subs	r3, r3, r1
 801b850:	42ab      	cmp	r3, r5
 801b852:	dcf1      	bgt.n	801b838 <_printf_i+0x228>
 801b854:	e7ea      	b.n	801b82c <_printf_i+0x21c>
 801b856:	2500      	movs	r5, #0
 801b858:	e7f7      	b.n	801b84a <_printf_i+0x23a>
 801b85a:	bf00      	nop
 801b85c:	0801c2f5 	.word	0x0801c2f5
 801b860:	0801c3a6 	.word	0x0801c3a6

0801b864 <__sflush_r>:
 801b864:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 801b868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801b86c:	0716      	lsls	r6, r2, #28
 801b86e:	4605      	mov	r5, r0
 801b870:	460c      	mov	r4, r1
 801b872:	d451      	bmi.n	801b918 <__sflush_r+0xb4>
 801b874:	684b      	ldr	r3, [r1, #4]
 801b876:	2b00      	cmp	r3, #0
 801b878:	dc02      	bgt.n	801b880 <__sflush_r+0x1c>
 801b87a:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 801b87c:	2b00      	cmp	r3, #0
 801b87e:	dd49      	ble.n	801b914 <__sflush_r+0xb0>
 801b880:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 801b882:	2e00      	cmp	r6, #0
 801b884:	d046      	beq.n	801b914 <__sflush_r+0xb0>
 801b886:	2300      	movs	r3, #0
 801b888:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 801b88c:	682f      	ldr	r7, [r5, #0]
 801b88e:	602b      	str	r3, [r5, #0]
 801b890:	d031      	beq.n	801b8f6 <__sflush_r+0x92>
 801b892:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 801b894:	89a3      	ldrh	r3, [r4, #12]
 801b896:	0759      	lsls	r1, r3, #29
 801b898:	d505      	bpl.n	801b8a6 <__sflush_r+0x42>
 801b89a:	6863      	ldr	r3, [r4, #4]
 801b89c:	1ad2      	subs	r2, r2, r3
 801b89e:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 801b8a0:	b10b      	cbz	r3, 801b8a6 <__sflush_r+0x42>
 801b8a2:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 801b8a4:	1ad2      	subs	r2, r2, r3
 801b8a6:	2300      	movs	r3, #0
 801b8a8:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 801b8aa:	6a21      	ldr	r1, [r4, #32]
 801b8ac:	4628      	mov	r0, r5
 801b8ae:	47b0      	blx	r6
 801b8b0:	1c42      	adds	r2, r0, #1
 801b8b2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801b8b6:	d106      	bne.n	801b8c6 <__sflush_r+0x62>
 801b8b8:	6829      	ldr	r1, [r5, #0]
 801b8ba:	291d      	cmp	r1, #29
 801b8bc:	d845      	bhi.n	801b94a <__sflush_r+0xe6>
 801b8be:	4a28      	ldr	r2, [pc, #160]	@ (801b960 <__sflush_r+0xfc>)
 801b8c0:	40ca      	lsrs	r2, r1
 801b8c2:	07d6      	lsls	r6, r2, #31
 801b8c4:	d541      	bpl.n	801b94a <__sflush_r+0xe6>
 801b8c6:	2200      	movs	r2, #0
 801b8c8:	6062      	str	r2, [r4, #4]
 801b8ca:	04d9      	lsls	r1, r3, #19
 801b8cc:	6922      	ldr	r2, [r4, #16]
 801b8ce:	6022      	str	r2, [r4, #0]
 801b8d0:	d504      	bpl.n	801b8dc <__sflush_r+0x78>
 801b8d2:	1c42      	adds	r2, r0, #1
 801b8d4:	d101      	bne.n	801b8da <__sflush_r+0x76>
 801b8d6:	682b      	ldr	r3, [r5, #0]
 801b8d8:	b903      	cbnz	r3, 801b8dc <__sflush_r+0x78>
 801b8da:	6560      	str	r0, [r4, #84]	@ 0x54
 801b8dc:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 801b8de:	602f      	str	r7, [r5, #0]
 801b8e0:	b1c1      	cbz	r1, 801b914 <__sflush_r+0xb0>
 801b8e2:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 801b8e6:	4299      	cmp	r1, r3
 801b8e8:	d002      	beq.n	801b8f0 <__sflush_r+0x8c>
 801b8ea:	4628      	mov	r0, r5
 801b8ec:	f7ff fc92 	bl	801b214 <_free_r>
 801b8f0:	2300      	movs	r3, #0
 801b8f2:	6363      	str	r3, [r4, #52]	@ 0x34
 801b8f4:	e00e      	b.n	801b914 <__sflush_r+0xb0>
 801b8f6:	6a21      	ldr	r1, [r4, #32]
 801b8f8:	2301      	movs	r3, #1
 801b8fa:	4628      	mov	r0, r5
 801b8fc:	47b0      	blx	r6
 801b8fe:	4602      	mov	r2, r0
 801b900:	1c50      	adds	r0, r2, #1
 801b902:	d1c7      	bne.n	801b894 <__sflush_r+0x30>
 801b904:	682b      	ldr	r3, [r5, #0]
 801b906:	2b00      	cmp	r3, #0
 801b908:	d0c4      	beq.n	801b894 <__sflush_r+0x30>
 801b90a:	2b1d      	cmp	r3, #29
 801b90c:	d001      	beq.n	801b912 <__sflush_r+0xae>
 801b90e:	2b16      	cmp	r3, #22
 801b910:	d11a      	bne.n	801b948 <__sflush_r+0xe4>
 801b912:	602f      	str	r7, [r5, #0]
 801b914:	2000      	movs	r0, #0
 801b916:	e01d      	b.n	801b954 <__sflush_r+0xf0>
 801b918:	690f      	ldr	r7, [r1, #16]
 801b91a:	2f00      	cmp	r7, #0
 801b91c:	d0fa      	beq.n	801b914 <__sflush_r+0xb0>
 801b91e:	0793      	lsls	r3, r2, #30
 801b920:	680e      	ldr	r6, [r1, #0]
 801b922:	bf08      	it	eq
 801b924:	694b      	ldreq	r3, [r1, #20]
 801b926:	600f      	str	r7, [r1, #0]
 801b928:	bf18      	it	ne
 801b92a:	2300      	movne	r3, #0
 801b92c:	eba6 0807 	sub.w	r8, r6, r7
 801b930:	608b      	str	r3, [r1, #8]
 801b932:	f1b8 0f00 	cmp.w	r8, #0
 801b936:	dded      	ble.n	801b914 <__sflush_r+0xb0>
 801b938:	6a21      	ldr	r1, [r4, #32]
 801b93a:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 801b93c:	4643      	mov	r3, r8
 801b93e:	463a      	mov	r2, r7
 801b940:	4628      	mov	r0, r5
 801b942:	47b0      	blx	r6
 801b944:	2800      	cmp	r0, #0
 801b946:	dc07      	bgt.n	801b958 <__sflush_r+0xf4>
 801b948:	89a3      	ldrh	r3, [r4, #12]
 801b94a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801b94e:	81a3      	strh	r3, [r4, #12]
 801b950:	f04f 30ff 	mov.w	r0, #4294967295
 801b954:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801b958:	4407      	add	r7, r0
 801b95a:	eba8 0800 	sub.w	r8, r8, r0
 801b95e:	e7e8      	b.n	801b932 <__sflush_r+0xce>
 801b960:	20400001 	.word	0x20400001

0801b964 <_fflush_r>:
 801b964:	b538      	push	{r3, r4, r5, lr}
 801b966:	690b      	ldr	r3, [r1, #16]
 801b968:	4605      	mov	r5, r0
 801b96a:	460c      	mov	r4, r1
 801b96c:	b913      	cbnz	r3, 801b974 <_fflush_r+0x10>
 801b96e:	461d      	mov	r5, r3
 801b970:	4628      	mov	r0, r5
 801b972:	bd38      	pop	{r3, r4, r5, pc}
 801b974:	b118      	cbz	r0, 801b97e <_fflush_r+0x1a>
 801b976:	6a03      	ldr	r3, [r0, #32]
 801b978:	b90b      	cbnz	r3, 801b97e <_fflush_r+0x1a>
 801b97a:	f7ff fb07 	bl	801af8c <__sinit>
 801b97e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801b982:	2b00      	cmp	r3, #0
 801b984:	d0f3      	beq.n	801b96e <_fflush_r+0xa>
 801b986:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 801b988:	07d0      	lsls	r0, r2, #31
 801b98a:	d404      	bmi.n	801b996 <_fflush_r+0x32>
 801b98c:	0599      	lsls	r1, r3, #22
 801b98e:	d402      	bmi.n	801b996 <_fflush_r+0x32>
 801b990:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 801b992:	f7ff fc28 	bl	801b1e6 <__retarget_lock_acquire_recursive>
 801b996:	4628      	mov	r0, r5
 801b998:	4621      	mov	r1, r4
 801b99a:	f7ff ff63 	bl	801b864 <__sflush_r>
 801b99e:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 801b9a0:	07da      	lsls	r2, r3, #31
 801b9a2:	4605      	mov	r5, r0
 801b9a4:	d4e4      	bmi.n	801b970 <_fflush_r+0xc>
 801b9a6:	89a3      	ldrh	r3, [r4, #12]
 801b9a8:	059b      	lsls	r3, r3, #22
 801b9aa:	d4e1      	bmi.n	801b970 <_fflush_r+0xc>
 801b9ac:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 801b9ae:	f7ff fc1b 	bl	801b1e8 <__retarget_lock_release_recursive>
 801b9b2:	e7dd      	b.n	801b970 <_fflush_r+0xc>

0801b9b4 <__swbuf_r>:
 801b9b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801b9b6:	4605      	mov	r5, r0
 801b9b8:	460f      	mov	r7, r1
 801b9ba:	4614      	mov	r4, r2
 801b9bc:	b118      	cbz	r0, 801b9c6 <__swbuf_r+0x12>
 801b9be:	6a03      	ldr	r3, [r0, #32]
 801b9c0:	b90b      	cbnz	r3, 801b9c6 <__swbuf_r+0x12>
 801b9c2:	f7ff fae3 	bl	801af8c <__sinit>
 801b9c6:	69a3      	ldr	r3, [r4, #24]
 801b9c8:	60a3      	str	r3, [r4, #8]
 801b9ca:	89a3      	ldrh	r3, [r4, #12]
 801b9cc:	071a      	lsls	r2, r3, #28
 801b9ce:	d501      	bpl.n	801b9d4 <__swbuf_r+0x20>
 801b9d0:	6923      	ldr	r3, [r4, #16]
 801b9d2:	b943      	cbnz	r3, 801b9e6 <__swbuf_r+0x32>
 801b9d4:	4621      	mov	r1, r4
 801b9d6:	4628      	mov	r0, r5
 801b9d8:	f000 f82a 	bl	801ba30 <__swsetup_r>
 801b9dc:	b118      	cbz	r0, 801b9e6 <__swbuf_r+0x32>
 801b9de:	f04f 36ff 	mov.w	r6, #4294967295
 801b9e2:	4630      	mov	r0, r6
 801b9e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801b9e6:	6923      	ldr	r3, [r4, #16]
 801b9e8:	6820      	ldr	r0, [r4, #0]
 801b9ea:	1ac0      	subs	r0, r0, r3
 801b9ec:	6963      	ldr	r3, [r4, #20]
 801b9ee:	4283      	cmp	r3, r0
 801b9f0:	dc05      	bgt.n	801b9fe <__swbuf_r+0x4a>
 801b9f2:	4621      	mov	r1, r4
 801b9f4:	4628      	mov	r0, r5
 801b9f6:	f7ff ffb5 	bl	801b964 <_fflush_r>
 801b9fa:	2800      	cmp	r0, #0
 801b9fc:	d1ef      	bne.n	801b9de <__swbuf_r+0x2a>
 801b9fe:	68a3      	ldr	r3, [r4, #8]
 801ba00:	3b01      	subs	r3, #1
 801ba02:	60a3      	str	r3, [r4, #8]
 801ba04:	6823      	ldr	r3, [r4, #0]
 801ba06:	1c5a      	adds	r2, r3, #1
 801ba08:	6022      	str	r2, [r4, #0]
 801ba0a:	701f      	strb	r7, [r3, #0]
 801ba0c:	6963      	ldr	r3, [r4, #20]
 801ba0e:	3001      	adds	r0, #1
 801ba10:	4283      	cmp	r3, r0
 801ba12:	b2fe      	uxtb	r6, r7
 801ba14:	d004      	beq.n	801ba20 <__swbuf_r+0x6c>
 801ba16:	89a3      	ldrh	r3, [r4, #12]
 801ba18:	07db      	lsls	r3, r3, #31
 801ba1a:	d5e2      	bpl.n	801b9e2 <__swbuf_r+0x2e>
 801ba1c:	2e0a      	cmp	r6, #10
 801ba1e:	d1e0      	bne.n	801b9e2 <__swbuf_r+0x2e>
 801ba20:	4621      	mov	r1, r4
 801ba22:	4628      	mov	r0, r5
 801ba24:	f7ff ff9e 	bl	801b964 <_fflush_r>
 801ba28:	2800      	cmp	r0, #0
 801ba2a:	d0da      	beq.n	801b9e2 <__swbuf_r+0x2e>
 801ba2c:	e7d7      	b.n	801b9de <__swbuf_r+0x2a>
	...

0801ba30 <__swsetup_r>:
 801ba30:	b538      	push	{r3, r4, r5, lr}
 801ba32:	4b28      	ldr	r3, [pc, #160]	@ (801bad4 <__swsetup_r+0xa4>)
 801ba34:	4605      	mov	r5, r0
 801ba36:	6818      	ldr	r0, [r3, #0]
 801ba38:	460c      	mov	r4, r1
 801ba3a:	b118      	cbz	r0, 801ba44 <__swsetup_r+0x14>
 801ba3c:	6a03      	ldr	r3, [r0, #32]
 801ba3e:	b90b      	cbnz	r3, 801ba44 <__swsetup_r+0x14>
 801ba40:	f7ff faa4 	bl	801af8c <__sinit>
 801ba44:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801ba48:	0719      	lsls	r1, r3, #28
 801ba4a:	d420      	bmi.n	801ba8e <__swsetup_r+0x5e>
 801ba4c:	06da      	lsls	r2, r3, #27
 801ba4e:	d407      	bmi.n	801ba60 <__swsetup_r+0x30>
 801ba50:	2209      	movs	r2, #9
 801ba52:	602a      	str	r2, [r5, #0]
 801ba54:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801ba58:	81a3      	strh	r3, [r4, #12]
 801ba5a:	f04f 30ff 	mov.w	r0, #4294967295
 801ba5e:	e031      	b.n	801bac4 <__swsetup_r+0x94>
 801ba60:	0758      	lsls	r0, r3, #29
 801ba62:	d511      	bpl.n	801ba88 <__swsetup_r+0x58>
 801ba64:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 801ba66:	b141      	cbz	r1, 801ba7a <__swsetup_r+0x4a>
 801ba68:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 801ba6c:	4299      	cmp	r1, r3
 801ba6e:	d002      	beq.n	801ba76 <__swsetup_r+0x46>
 801ba70:	4628      	mov	r0, r5
 801ba72:	f7ff fbcf 	bl	801b214 <_free_r>
 801ba76:	2300      	movs	r3, #0
 801ba78:	6363      	str	r3, [r4, #52]	@ 0x34
 801ba7a:	2200      	movs	r2, #0
 801ba7c:	89a3      	ldrh	r3, [r4, #12]
 801ba7e:	6062      	str	r2, [r4, #4]
 801ba80:	6922      	ldr	r2, [r4, #16]
 801ba82:	6022      	str	r2, [r4, #0]
 801ba84:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 801ba88:	f043 0308 	orr.w	r3, r3, #8
 801ba8c:	81a3      	strh	r3, [r4, #12]
 801ba8e:	6923      	ldr	r3, [r4, #16]
 801ba90:	b94b      	cbnz	r3, 801baa6 <__swsetup_r+0x76>
 801ba92:	89a3      	ldrh	r3, [r4, #12]
 801ba94:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 801ba98:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801ba9c:	d003      	beq.n	801baa6 <__swsetup_r+0x76>
 801ba9e:	4621      	mov	r1, r4
 801baa0:	4628      	mov	r0, r5
 801baa2:	f000 f881 	bl	801bba8 <__smakebuf_r>
 801baa6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801baaa:	f013 0201 	ands.w	r2, r3, #1
 801baae:	d00a      	beq.n	801bac6 <__swsetup_r+0x96>
 801bab0:	2200      	movs	r2, #0
 801bab2:	60a2      	str	r2, [r4, #8]
 801bab4:	6962      	ldr	r2, [r4, #20]
 801bab6:	4252      	negs	r2, r2
 801bab8:	61a2      	str	r2, [r4, #24]
 801baba:	6922      	ldr	r2, [r4, #16]
 801babc:	b942      	cbnz	r2, 801bad0 <__swsetup_r+0xa0>
 801babe:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 801bac2:	d1c7      	bne.n	801ba54 <__swsetup_r+0x24>
 801bac4:	bd38      	pop	{r3, r4, r5, pc}
 801bac6:	0799      	lsls	r1, r3, #30
 801bac8:	bf58      	it	pl
 801baca:	6962      	ldrpl	r2, [r4, #20]
 801bacc:	60a2      	str	r2, [r4, #8]
 801bace:	e7f4      	b.n	801baba <__swsetup_r+0x8a>
 801bad0:	2000      	movs	r0, #0
 801bad2:	e7f7      	b.n	801bac4 <__swsetup_r+0x94>
 801bad4:	20000018 	.word	0x20000018

0801bad8 <_raise_r>:
 801bad8:	291f      	cmp	r1, #31
 801bada:	b538      	push	{r3, r4, r5, lr}
 801badc:	4605      	mov	r5, r0
 801bade:	460c      	mov	r4, r1
 801bae0:	d904      	bls.n	801baec <_raise_r+0x14>
 801bae2:	2316      	movs	r3, #22
 801bae4:	6003      	str	r3, [r0, #0]
 801bae6:	f04f 30ff 	mov.w	r0, #4294967295
 801baea:	bd38      	pop	{r3, r4, r5, pc}
 801baec:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 801baee:	b112      	cbz	r2, 801baf6 <_raise_r+0x1e>
 801baf0:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 801baf4:	b94b      	cbnz	r3, 801bb0a <_raise_r+0x32>
 801baf6:	4628      	mov	r0, r5
 801baf8:	f000 f830 	bl	801bb5c <_getpid_r>
 801bafc:	4622      	mov	r2, r4
 801bafe:	4601      	mov	r1, r0
 801bb00:	4628      	mov	r0, r5
 801bb02:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801bb06:	f000 b817 	b.w	801bb38 <_kill_r>
 801bb0a:	2b01      	cmp	r3, #1
 801bb0c:	d00a      	beq.n	801bb24 <_raise_r+0x4c>
 801bb0e:	1c59      	adds	r1, r3, #1
 801bb10:	d103      	bne.n	801bb1a <_raise_r+0x42>
 801bb12:	2316      	movs	r3, #22
 801bb14:	6003      	str	r3, [r0, #0]
 801bb16:	2001      	movs	r0, #1
 801bb18:	e7e7      	b.n	801baea <_raise_r+0x12>
 801bb1a:	2100      	movs	r1, #0
 801bb1c:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 801bb20:	4620      	mov	r0, r4
 801bb22:	4798      	blx	r3
 801bb24:	2000      	movs	r0, #0
 801bb26:	e7e0      	b.n	801baea <_raise_r+0x12>

0801bb28 <raise>:
 801bb28:	4b02      	ldr	r3, [pc, #8]	@ (801bb34 <raise+0xc>)
 801bb2a:	4601      	mov	r1, r0
 801bb2c:	6818      	ldr	r0, [r3, #0]
 801bb2e:	f7ff bfd3 	b.w	801bad8 <_raise_r>
 801bb32:	bf00      	nop
 801bb34:	20000018 	.word	0x20000018

0801bb38 <_kill_r>:
 801bb38:	b538      	push	{r3, r4, r5, lr}
 801bb3a:	4c07      	ldr	r4, [pc, #28]	@ (801bb58 <_kill_r+0x20>)
 801bb3c:	2300      	movs	r3, #0
 801bb3e:	4605      	mov	r5, r0
 801bb40:	4608      	mov	r0, r1
 801bb42:	4611      	mov	r1, r2
 801bb44:	6023      	str	r3, [r4, #0]
 801bb46:	f7fb ff1a 	bl	801797e <_kill>
 801bb4a:	1c43      	adds	r3, r0, #1
 801bb4c:	d102      	bne.n	801bb54 <_kill_r+0x1c>
 801bb4e:	6823      	ldr	r3, [r4, #0]
 801bb50:	b103      	cbz	r3, 801bb54 <_kill_r+0x1c>
 801bb52:	602b      	str	r3, [r5, #0]
 801bb54:	bd38      	pop	{r3, r4, r5, pc}
 801bb56:	bf00      	nop
 801bb58:	20001a98 	.word	0x20001a98

0801bb5c <_getpid_r>:
 801bb5c:	f7fb bf0d 	b.w	801797a <_getpid>

0801bb60 <__swhatbuf_r>:
 801bb60:	b570      	push	{r4, r5, r6, lr}
 801bb62:	460e      	mov	r6, r1
 801bb64:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801bb68:	2900      	cmp	r1, #0
 801bb6a:	b096      	sub	sp, #88	@ 0x58
 801bb6c:	4614      	mov	r4, r2
 801bb6e:	461d      	mov	r5, r3
 801bb70:	da0a      	bge.n	801bb88 <__swhatbuf_r+0x28>
 801bb72:	89b2      	ldrh	r2, [r6, #12]
 801bb74:	f012 0280 	ands.w	r2, r2, #128	@ 0x80
 801bb78:	d113      	bne.n	801bba2 <__swhatbuf_r+0x42>
 801bb7a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 801bb7e:	2000      	movs	r0, #0
 801bb80:	602a      	str	r2, [r5, #0]
 801bb82:	6021      	str	r1, [r4, #0]
 801bb84:	b016      	add	sp, #88	@ 0x58
 801bb86:	bd70      	pop	{r4, r5, r6, pc}
 801bb88:	466a      	mov	r2, sp
 801bb8a:	f000 f847 	bl	801bc1c <_fstat_r>
 801bb8e:	2800      	cmp	r0, #0
 801bb90:	dbef      	blt.n	801bb72 <__swhatbuf_r+0x12>
 801bb92:	9a01      	ldr	r2, [sp, #4]
 801bb94:	f402 4270 	and.w	r2, r2, #61440	@ 0xf000
 801bb98:	f5a2 5300 	sub.w	r3, r2, #8192	@ 0x2000
 801bb9c:	425a      	negs	r2, r3
 801bb9e:	415a      	adcs	r2, r3
 801bba0:	e7eb      	b.n	801bb7a <__swhatbuf_r+0x1a>
 801bba2:	2200      	movs	r2, #0
 801bba4:	2140      	movs	r1, #64	@ 0x40
 801bba6:	e7ea      	b.n	801bb7e <__swhatbuf_r+0x1e>

0801bba8 <__smakebuf_r>:
 801bba8:	898b      	ldrh	r3, [r1, #12]
 801bbaa:	b573      	push	{r0, r1, r4, r5, r6, lr}
 801bbac:	079e      	lsls	r6, r3, #30
 801bbae:	4605      	mov	r5, r0
 801bbb0:	460c      	mov	r4, r1
 801bbb2:	d507      	bpl.n	801bbc4 <__smakebuf_r+0x1c>
 801bbb4:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 801bbb8:	6023      	str	r3, [r4, #0]
 801bbba:	6123      	str	r3, [r4, #16]
 801bbbc:	2301      	movs	r3, #1
 801bbbe:	6163      	str	r3, [r4, #20]
 801bbc0:	b002      	add	sp, #8
 801bbc2:	bd70      	pop	{r4, r5, r6, pc}
 801bbc4:	ab01      	add	r3, sp, #4
 801bbc6:	466a      	mov	r2, sp
 801bbc8:	f7ff ffca 	bl	801bb60 <__swhatbuf_r>
 801bbcc:	9e00      	ldr	r6, [sp, #0]
 801bbce:	4628      	mov	r0, r5
 801bbd0:	4631      	mov	r1, r6
 801bbd2:	f7ff f8c5 	bl	801ad60 <_malloc_r>
 801bbd6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801bbda:	b938      	cbnz	r0, 801bbec <__smakebuf_r+0x44>
 801bbdc:	059a      	lsls	r2, r3, #22
 801bbde:	d4ef      	bmi.n	801bbc0 <__smakebuf_r+0x18>
 801bbe0:	f023 0303 	bic.w	r3, r3, #3
 801bbe4:	f043 0302 	orr.w	r3, r3, #2
 801bbe8:	81a3      	strh	r3, [r4, #12]
 801bbea:	e7e3      	b.n	801bbb4 <__smakebuf_r+0xc>
 801bbec:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801bbf0:	81a3      	strh	r3, [r4, #12]
 801bbf2:	9b01      	ldr	r3, [sp, #4]
 801bbf4:	6020      	str	r0, [r4, #0]
 801bbf6:	e9c4 0604 	strd	r0, r6, [r4, #16]
 801bbfa:	2b00      	cmp	r3, #0
 801bbfc:	d0e0      	beq.n	801bbc0 <__smakebuf_r+0x18>
 801bbfe:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801bc02:	4628      	mov	r0, r5
 801bc04:	f000 f81c 	bl	801bc40 <_isatty_r>
 801bc08:	2800      	cmp	r0, #0
 801bc0a:	d0d9      	beq.n	801bbc0 <__smakebuf_r+0x18>
 801bc0c:	89a3      	ldrh	r3, [r4, #12]
 801bc0e:	f023 0303 	bic.w	r3, r3, #3
 801bc12:	f043 0301 	orr.w	r3, r3, #1
 801bc16:	81a3      	strh	r3, [r4, #12]
 801bc18:	e7d2      	b.n	801bbc0 <__smakebuf_r+0x18>
	...

0801bc1c <_fstat_r>:
 801bc1c:	b538      	push	{r3, r4, r5, lr}
 801bc1e:	4c07      	ldr	r4, [pc, #28]	@ (801bc3c <_fstat_r+0x20>)
 801bc20:	2300      	movs	r3, #0
 801bc22:	4605      	mov	r5, r0
 801bc24:	4608      	mov	r0, r1
 801bc26:	4611      	mov	r1, r2
 801bc28:	6023      	str	r3, [r4, #0]
 801bc2a:	f7fb fed5 	bl	80179d8 <_fstat>
 801bc2e:	1c43      	adds	r3, r0, #1
 801bc30:	d102      	bne.n	801bc38 <_fstat_r+0x1c>
 801bc32:	6823      	ldr	r3, [r4, #0]
 801bc34:	b103      	cbz	r3, 801bc38 <_fstat_r+0x1c>
 801bc36:	602b      	str	r3, [r5, #0]
 801bc38:	bd38      	pop	{r3, r4, r5, pc}
 801bc3a:	bf00      	nop
 801bc3c:	20001a98 	.word	0x20001a98

0801bc40 <_isatty_r>:
 801bc40:	b538      	push	{r3, r4, r5, lr}
 801bc42:	4c06      	ldr	r4, [pc, #24]	@ (801bc5c <_isatty_r+0x1c>)
 801bc44:	2300      	movs	r3, #0
 801bc46:	4605      	mov	r5, r0
 801bc48:	4608      	mov	r0, r1
 801bc4a:	6023      	str	r3, [r4, #0]
 801bc4c:	f7fb fec9 	bl	80179e2 <_isatty>
 801bc50:	1c43      	adds	r3, r0, #1
 801bc52:	d102      	bne.n	801bc5a <_isatty_r+0x1a>
 801bc54:	6823      	ldr	r3, [r4, #0]
 801bc56:	b103      	cbz	r3, 801bc5a <_isatty_r+0x1a>
 801bc58:	602b      	str	r3, [r5, #0]
 801bc5a:	bd38      	pop	{r3, r4, r5, pc}
 801bc5c:	20001a98 	.word	0x20001a98

0801bc60 <__udivmoddi4>:
 801bc60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801bc64:	b082      	sub	sp, #8
 801bc66:	4606      	mov	r6, r0
 801bc68:	f8dd e028 	ldr.w	lr, [sp, #40]	@ 0x28
 801bc6c:	4608      	mov	r0, r1
 801bc6e:	46b4      	mov	ip, r6
 801bc70:	460d      	mov	r5, r1
 801bc72:	2b00      	cmp	r3, #0
 801bc74:	d14e      	bne.n	801bd14 <__udivmoddi4+0xb4>
 801bc76:	428a      	cmp	r2, r1
 801bc78:	4614      	mov	r4, r2
 801bc7a:	d96d      	bls.n	801bd58 <__udivmoddi4+0xf8>
 801bc7c:	fab2 f282 	clz	r2, r2
 801bc80:	b142      	cbz	r2, 801bc94 <__udivmoddi4+0x34>
 801bc82:	f1c2 0320 	rsb	r3, r2, #32
 801bc86:	4095      	lsls	r5, r2
 801bc88:	fa26 f303 	lsr.w	r3, r6, r3
 801bc8c:	4094      	lsls	r4, r2
 801bc8e:	431d      	orrs	r5, r3
 801bc90:	fa06 fc02 	lsl.w	ip, r6, r2
 801bc94:	0c26      	lsrs	r6, r4, #16
 801bc96:	b2a7      	uxth	r7, r4
 801bc98:	fbb5 f1f6 	udiv	r1, r5, r6
 801bc9c:	ea4f 431c 	mov.w	r3, ip, lsr #16
 801bca0:	fb06 5511 	mls	r5, r6, r1, r5
 801bca4:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 801bca8:	fb01 f007 	mul.w	r0, r1, r7
 801bcac:	4298      	cmp	r0, r3
 801bcae:	d909      	bls.n	801bcc4 <__udivmoddi4+0x64>
 801bcb0:	18e3      	adds	r3, r4, r3
 801bcb2:	f101 35ff 	add.w	r5, r1, #4294967295
 801bcb6:	f080 8103 	bcs.w	801bec0 <__udivmoddi4+0x260>
 801bcba:	4298      	cmp	r0, r3
 801bcbc:	f240 8100 	bls.w	801bec0 <__udivmoddi4+0x260>
 801bcc0:	3902      	subs	r1, #2
 801bcc2:	4423      	add	r3, r4
 801bcc4:	1a1b      	subs	r3, r3, r0
 801bcc6:	fa1f fc8c 	uxth.w	ip, ip
 801bcca:	fbb3 f0f6 	udiv	r0, r3, r6
 801bcce:	fb06 3310 	mls	r3, r6, r0, r3
 801bcd2:	ea4c 4c03 	orr.w	ip, ip, r3, lsl #16
 801bcd6:	fb00 f307 	mul.w	r3, r0, r7
 801bcda:	4563      	cmp	r3, ip
 801bcdc:	d90a      	bls.n	801bcf4 <__udivmoddi4+0x94>
 801bcde:	eb14 0c0c 	adds.w	ip, r4, ip
 801bce2:	f100 35ff 	add.w	r5, r0, #4294967295
 801bce6:	f080 80ed 	bcs.w	801bec4 <__udivmoddi4+0x264>
 801bcea:	4563      	cmp	r3, ip
 801bcec:	f240 80ea 	bls.w	801bec4 <__udivmoddi4+0x264>
 801bcf0:	44a4      	add	ip, r4
 801bcf2:	3802      	subs	r0, #2
 801bcf4:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 801bcf8:	ebac 0c03 	sub.w	ip, ip, r3
 801bcfc:	2100      	movs	r1, #0
 801bcfe:	f1be 0f00 	cmp.w	lr, #0
 801bd02:	d004      	beq.n	801bd0e <__udivmoddi4+0xae>
 801bd04:	fa2c f302 	lsr.w	r3, ip, r2
 801bd08:	2200      	movs	r2, #0
 801bd0a:	e9ce 3200 	strd	r3, r2, [lr]
 801bd0e:	b002      	add	sp, #8
 801bd10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801bd14:	428b      	cmp	r3, r1
 801bd16:	d909      	bls.n	801bd2c <__udivmoddi4+0xcc>
 801bd18:	f1be 0f00 	cmp.w	lr, #0
 801bd1c:	d001      	beq.n	801bd22 <__udivmoddi4+0xc2>
 801bd1e:	e9ce 6100 	strd	r6, r1, [lr]
 801bd22:	2100      	movs	r1, #0
 801bd24:	4608      	mov	r0, r1
 801bd26:	b002      	add	sp, #8
 801bd28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801bd2c:	fab3 f183 	clz	r1, r3
 801bd30:	4617      	mov	r7, r2
 801bd32:	2900      	cmp	r1, #0
 801bd34:	d14d      	bne.n	801bdd2 <__udivmoddi4+0x172>
 801bd36:	4283      	cmp	r3, r0
 801bd38:	d302      	bcc.n	801bd40 <__udivmoddi4+0xe0>
 801bd3a:	42b2      	cmp	r2, r6
 801bd3c:	f200 810f 	bhi.w	801bf5e <__udivmoddi4+0x2fe>
 801bd40:	ebb6 0c07 	subs.w	ip, r6, r7
 801bd44:	eb60 0303 	sbc.w	r3, r0, r3
 801bd48:	2001      	movs	r0, #1
 801bd4a:	461d      	mov	r5, r3
 801bd4c:	f1be 0f00 	cmp.w	lr, #0
 801bd50:	d0dd      	beq.n	801bd0e <__udivmoddi4+0xae>
 801bd52:	e9ce c500 	strd	ip, r5, [lr]
 801bd56:	e7da      	b.n	801bd0e <__udivmoddi4+0xae>
 801bd58:	2a00      	cmp	r2, #0
 801bd5a:	f000 8098 	beq.w	801be8e <__udivmoddi4+0x22e>
 801bd5e:	461a      	mov	r2, r3
 801bd60:	fab4 f384 	clz	r3, r4
 801bd64:	2b00      	cmp	r3, #0
 801bd66:	f040 80af 	bne.w	801bec8 <__udivmoddi4+0x268>
 801bd6a:	1b0b      	subs	r3, r1, r4
 801bd6c:	0c27      	lsrs	r7, r4, #16
 801bd6e:	b2a6      	uxth	r6, r4
 801bd70:	2101      	movs	r1, #1
 801bd72:	fbb3 f5f7 	udiv	r5, r3, r7
 801bd76:	ea4f 401c 	mov.w	r0, ip, lsr #16
 801bd7a:	fb07 3315 	mls	r3, r7, r5, r3
 801bd7e:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 801bd82:	fb06 f805 	mul.w	r8, r6, r5
 801bd86:	4598      	cmp	r8, r3
 801bd88:	d907      	bls.n	801bd9a <__udivmoddi4+0x13a>
 801bd8a:	18e3      	adds	r3, r4, r3
 801bd8c:	f105 30ff 	add.w	r0, r5, #4294967295
 801bd90:	d202      	bcs.n	801bd98 <__udivmoddi4+0x138>
 801bd92:	4598      	cmp	r8, r3
 801bd94:	f200 80e8 	bhi.w	801bf68 <__udivmoddi4+0x308>
 801bd98:	4605      	mov	r5, r0
 801bd9a:	eba3 0308 	sub.w	r3, r3, r8
 801bd9e:	fa1f fc8c 	uxth.w	ip, ip
 801bda2:	fbb3 f0f7 	udiv	r0, r3, r7
 801bda6:	fb07 3310 	mls	r3, r7, r0, r3
 801bdaa:	ea4c 4c03 	orr.w	ip, ip, r3, lsl #16
 801bdae:	fb06 f300 	mul.w	r3, r6, r0
 801bdb2:	4563      	cmp	r3, ip
 801bdb4:	d908      	bls.n	801bdc8 <__udivmoddi4+0x168>
 801bdb6:	eb14 0c0c 	adds.w	ip, r4, ip
 801bdba:	f100 36ff 	add.w	r6, r0, #4294967295
 801bdbe:	d202      	bcs.n	801bdc6 <__udivmoddi4+0x166>
 801bdc0:	4563      	cmp	r3, ip
 801bdc2:	f200 80ce 	bhi.w	801bf62 <__udivmoddi4+0x302>
 801bdc6:	4630      	mov	r0, r6
 801bdc8:	ebac 0c03 	sub.w	ip, ip, r3
 801bdcc:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 801bdd0:	e795      	b.n	801bcfe <__udivmoddi4+0x9e>
 801bdd2:	f1c1 0520 	rsb	r5, r1, #32
 801bdd6:	408b      	lsls	r3, r1
 801bdd8:	fa22 fc05 	lsr.w	ip, r2, r5
 801bddc:	ea4c 0c03 	orr.w	ip, ip, r3
 801bde0:	fa00 f401 	lsl.w	r4, r0, r1
 801bde4:	fa26 f305 	lsr.w	r3, r6, r5
 801bde8:	40e8      	lsrs	r0, r5
 801bdea:	fa02 f901 	lsl.w	r9, r2, r1
 801bdee:	ea43 0804 	orr.w	r8, r3, r4
 801bdf2:	ea4f 421c 	mov.w	r2, ip, lsr #16
 801bdf6:	fa06 fa01 	lsl.w	sl, r6, r1
 801bdfa:	fbb0 f7f2 	udiv	r7, r0, r2
 801bdfe:	fa1f f68c 	uxth.w	r6, ip
 801be02:	fb02 0017 	mls	r0, r2, r7, r0
 801be06:	ea4f 4418 	mov.w	r4, r8, lsr #16
 801be0a:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
 801be0e:	fb07 f006 	mul.w	r0, r7, r6
 801be12:	42a0      	cmp	r0, r4
 801be14:	d90a      	bls.n	801be2c <__udivmoddi4+0x1cc>
 801be16:	eb1c 0404 	adds.w	r4, ip, r4
 801be1a:	f107 33ff 	add.w	r3, r7, #4294967295
 801be1e:	f080 809c 	bcs.w	801bf5a <__udivmoddi4+0x2fa>
 801be22:	42a0      	cmp	r0, r4
 801be24:	f240 8099 	bls.w	801bf5a <__udivmoddi4+0x2fa>
 801be28:	3f02      	subs	r7, #2
 801be2a:	4464      	add	r4, ip
 801be2c:	1a24      	subs	r4, r4, r0
 801be2e:	fa1f f388 	uxth.w	r3, r8
 801be32:	fbb4 f0f2 	udiv	r0, r4, r2
 801be36:	fb02 4410 	mls	r4, r2, r0, r4
 801be3a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 801be3e:	fb00 f606 	mul.w	r6, r0, r6
 801be42:	429e      	cmp	r6, r3
 801be44:	d909      	bls.n	801be5a <__udivmoddi4+0x1fa>
 801be46:	eb1c 0303 	adds.w	r3, ip, r3
 801be4a:	f100 34ff 	add.w	r4, r0, #4294967295
 801be4e:	f080 8082 	bcs.w	801bf56 <__udivmoddi4+0x2f6>
 801be52:	429e      	cmp	r6, r3
 801be54:	d97f      	bls.n	801bf56 <__udivmoddi4+0x2f6>
 801be56:	3802      	subs	r0, #2
 801be58:	4463      	add	r3, ip
 801be5a:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 801be5e:	fba0 7409 	umull	r7, r4, r0, r9
 801be62:	1b9b      	subs	r3, r3, r6
 801be64:	42a3      	cmp	r3, r4
 801be66:	463e      	mov	r6, r7
 801be68:	46a0      	mov	r8, r4
 801be6a:	d364      	bcc.n	801bf36 <__udivmoddi4+0x2d6>
 801be6c:	d061      	beq.n	801bf32 <__udivmoddi4+0x2d2>
 801be6e:	f1be 0f00 	cmp.w	lr, #0
 801be72:	d00a      	beq.n	801be8a <__udivmoddi4+0x22a>
 801be74:	ebba 0206 	subs.w	r2, sl, r6
 801be78:	eb63 0308 	sbc.w	r3, r3, r8
 801be7c:	fa03 f505 	lsl.w	r5, r3, r5
 801be80:	40ca      	lsrs	r2, r1
 801be82:	4315      	orrs	r5, r2
 801be84:	40cb      	lsrs	r3, r1
 801be86:	e9ce 5300 	strd	r5, r3, [lr]
 801be8a:	2100      	movs	r1, #0
 801be8c:	e73f      	b.n	801bd0e <__udivmoddi4+0xae>
 801be8e:	0873      	lsrs	r3, r6, #1
 801be90:	ea43 73c1 	orr.w	r3, r3, r1, lsl #31
 801be94:	084a      	lsrs	r2, r1, #1
 801be96:	0c19      	lsrs	r1, r3, #16
 801be98:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 801be9c:	ea4f 7cc6 	mov.w	ip, r6, lsl #31
 801bea0:	b29b      	uxth	r3, r3
 801bea2:	fbb2 f0f4 	udiv	r0, r2, r4
 801bea6:	4626      	mov	r6, r4
 801bea8:	46a0      	mov	r8, r4
 801beaa:	4627      	mov	r7, r4
 801beac:	221f      	movs	r2, #31
 801beae:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 801beb2:	fbb1 f1f4 	udiv	r1, r1, r4
 801beb6:	eba3 0308 	sub.w	r3, r3, r8
 801beba:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 801bebe:	e758      	b.n	801bd72 <__udivmoddi4+0x112>
 801bec0:	4629      	mov	r1, r5
 801bec2:	e6ff      	b.n	801bcc4 <__udivmoddi4+0x64>
 801bec4:	4628      	mov	r0, r5
 801bec6:	e715      	b.n	801bcf4 <__udivmoddi4+0x94>
 801bec8:	461a      	mov	r2, r3
 801beca:	f1c3 0120 	rsb	r1, r3, #32
 801bece:	409c      	lsls	r4, r3
 801bed0:	fa26 f301 	lsr.w	r3, r6, r1
 801bed4:	fa20 f101 	lsr.w	r1, r0, r1
 801bed8:	4090      	lsls	r0, r2
 801beda:	4303      	orrs	r3, r0
 801bedc:	0c27      	lsrs	r7, r4, #16
 801bede:	fa06 fc02 	lsl.w	ip, r6, r2
 801bee2:	fbb1 f0f7 	udiv	r0, r1, r7
 801bee6:	b2a6      	uxth	r6, r4
 801bee8:	fb07 1510 	mls	r5, r7, r0, r1
 801beec:	0c19      	lsrs	r1, r3, #16
 801beee:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 801bef2:	fb00 f506 	mul.w	r5, r0, r6
 801bef6:	428d      	cmp	r5, r1
 801bef8:	d93b      	bls.n	801bf72 <__udivmoddi4+0x312>
 801befa:	1861      	adds	r1, r4, r1
 801befc:	d201      	bcs.n	801bf02 <__udivmoddi4+0x2a2>
 801befe:	428d      	cmp	r5, r1
 801bf00:	d820      	bhi.n	801bf44 <__udivmoddi4+0x2e4>
 801bf02:	1b49      	subs	r1, r1, r5
 801bf04:	3801      	subs	r0, #1
 801bf06:	fbb1 f5f7 	udiv	r5, r1, r7
 801bf0a:	9501      	str	r5, [sp, #4]
 801bf0c:	fb05 f806 	mul.w	r8, r5, r6
 801bf10:	9d01      	ldr	r5, [sp, #4]
 801bf12:	b29b      	uxth	r3, r3
 801bf14:	fb07 1115 	mls	r1, r7, r5, r1
 801bf18:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 801bf1c:	4543      	cmp	r3, r8
 801bf1e:	d226      	bcs.n	801bf6e <__udivmoddi4+0x30e>
 801bf20:	18e3      	adds	r3, r4, r3
 801bf22:	f105 31ff 	add.w	r1, r5, #4294967295
 801bf26:	d2c6      	bcs.n	801beb6 <__udivmoddi4+0x256>
 801bf28:	4543      	cmp	r3, r8
 801bf2a:	d2c4      	bcs.n	801beb6 <__udivmoddi4+0x256>
 801bf2c:	1ea9      	subs	r1, r5, #2
 801bf2e:	4423      	add	r3, r4
 801bf30:	e7c1      	b.n	801beb6 <__udivmoddi4+0x256>
 801bf32:	45ba      	cmp	sl, r7
 801bf34:	d29b      	bcs.n	801be6e <__udivmoddi4+0x20e>
 801bf36:	ebb7 0609 	subs.w	r6, r7, r9
 801bf3a:	eb64 040c 	sbc.w	r4, r4, ip
 801bf3e:	3801      	subs	r0, #1
 801bf40:	46a0      	mov	r8, r4
 801bf42:	e794      	b.n	801be6e <__udivmoddi4+0x20e>
 801bf44:	1b65      	subs	r5, r4, r5
 801bf46:	4429      	add	r1, r5
 801bf48:	3802      	subs	r0, #2
 801bf4a:	fbb1 f5f7 	udiv	r5, r1, r7
 801bf4e:	9501      	str	r5, [sp, #4]
 801bf50:	fb05 f806 	mul.w	r8, r5, r6
 801bf54:	e7dc      	b.n	801bf10 <__udivmoddi4+0x2b0>
 801bf56:	4620      	mov	r0, r4
 801bf58:	e77f      	b.n	801be5a <__udivmoddi4+0x1fa>
 801bf5a:	461f      	mov	r7, r3
 801bf5c:	e766      	b.n	801be2c <__udivmoddi4+0x1cc>
 801bf5e:	4608      	mov	r0, r1
 801bf60:	e6f4      	b.n	801bd4c <__udivmoddi4+0xec>
 801bf62:	44a4      	add	ip, r4
 801bf64:	3802      	subs	r0, #2
 801bf66:	e72f      	b.n	801bdc8 <__udivmoddi4+0x168>
 801bf68:	3d02      	subs	r5, #2
 801bf6a:	4423      	add	r3, r4
 801bf6c:	e715      	b.n	801bd9a <__udivmoddi4+0x13a>
 801bf6e:	9901      	ldr	r1, [sp, #4]
 801bf70:	e7a1      	b.n	801beb6 <__udivmoddi4+0x256>
 801bf72:	1b49      	subs	r1, r1, r5
 801bf74:	fbb1 f5f7 	udiv	r5, r1, r7
 801bf78:	9501      	str	r5, [sp, #4]
 801bf7a:	fb05 f806 	mul.w	r8, r5, r6
 801bf7e:	e7c7      	b.n	801bf10 <__udivmoddi4+0x2b0>

0801bf80 <_init>:
 801bf80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801bf82:	bf00      	nop
 801bf84:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801bf86:	bc08      	pop	{r3}
 801bf88:	469e      	mov	lr, r3
 801bf8a:	4770      	bx	lr

0801bf8c <_fini>:
 801bf8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801bf8e:	bf00      	nop
 801bf90:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801bf92:	bc08      	pop	{r3}
 801bf94:	469e      	mov	lr, r3
 801bf96:	4770      	bx	lr
